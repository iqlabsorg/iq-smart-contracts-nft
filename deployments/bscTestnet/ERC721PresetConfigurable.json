{
  "address": "0x490dA4B41ad64E2589ff1160eEfE8ed846E8Fc03",
  "abi": [
    {
      "inputs": [],
      "name": "BalanceQueryForZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CallForwardToZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CallerIsNotMetahub",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CallerIsNotWarperAdmin",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ContractIsAlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ContractIsNotInitializing",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidAvailabilityPeriodEnd",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidAvailabilityPeriodStart",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidMaxRentalPeriod",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidMinRentalPeriod",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "original",
          "type": "address"
        },
        {
          "internalType": "bytes4",
          "name": "requiredInterfaceId",
          "type": "bytes4"
        }
      ],
      "name": "InvalidOriginalTokenInterface",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MethodNotAllowed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MintToTheZeroAddress",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "OperatorQueryForNonexistentToken",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "OwnerQueryForNonexistentToken",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "TokenIsAlreadyMinted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        }
      ],
      "name": "TransferToNonERC721ReceiverImplementer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TransferToTheZeroAddress",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentTime",
          "type": "uint256"
        },
        {
          "internalType": "uint32",
          "name": "availabilityPeriodStart",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "availabilityPeriodEnd",
          "type": "uint32"
        }
      ],
      "name": "WarperIsNotAvailableForRenting",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "requestedRentalPeriod",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "minRentalPeriod",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "maxRentalPeriod",
          "type": "uint32"
        }
      ],
      "name": "WarperRentalPeriodIsOutOfRange",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "__assetClass",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "__availabilityPeriodEnd",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "__availabilityPeriodRange",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "availabilityPeriodStart",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "availabilityPeriodEnd",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "__availabilityPeriodStart",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "config",
          "type": "bytes"
        }
      ],
      "name": "__initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "__maxRentalPeriod",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "__metahub",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "__minRentalPeriod",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "__original",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "__rentalPeriodRange",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "minRentalPeriod",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "maxRentalPeriod",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "availabilityPeriodEnd",
          "type": "uint32"
        }
      ],
      "name": "__setAvailabilityPeriodEnd",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "availabilityPeriodStart",
          "type": "uint32"
        }
      ],
      "name": "__setAvailabilityPeriodStart",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "maxRentalPeriod",
          "type": "uint32"
        }
      ],
      "name": "__setMaxRentalPeriod",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "minRentalPeriod",
          "type": "uint32"
        }
      ],
      "name": "__setMinRentalPeriod",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4[]",
          "name": "interfaceIds",
          "type": "bytes4[]"
        }
      ],
      "name": "__supportedInterfaces",
      "outputs": [
        {
          "internalType": "bool[]",
          "name": "",
          "type": "bool[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "mint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "multicall",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "results",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x5a03c1010ce00e0e3a3bcbb0af3c387795c0723b143354c6e177edcdd1fba342",
  "receipt": {
    "to": null,
    "from": "0xa944195A4a0c3a679Bea853579126c308b34c8D4",
    "contractAddress": "0x490dA4B41ad64E2589ff1160eEfE8ed846E8Fc03",
    "transactionIndex": 4,
    "gasUsed": "1947412",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x09a890812a97acbe8af28a4aaa6694795a26e3ddfeb6f77082f4083582892260",
    "transactionHash": "0x5a03c1010ce00e0e3a3bcbb0af3c387795c0723b143354c6e177edcdd1fba342",
    "logs": [],
    "blockNumber": 19643113,
    "cumulativeGasUsed": "5377305",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "60d11795a5629b39ace9fd9e8b24ce14",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallForwardToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotMetahub\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerIsNotWarperAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractIsAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractIsNotInitializing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAvailabilityPeriodEnd\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAvailabilityPeriodStart\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMaxRentalPeriod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMinRentalPeriod\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"original\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"requiredInterfaceId\",\"type\":\"bytes4\"}],\"name\":\"InvalidOriginalTokenInterface\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MethodNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"OperatorQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TokenIsAlreadyMinted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToTheZeroAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"availabilityPeriodStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"availabilityPeriodEnd\",\"type\":\"uint32\"}],\"name\":\"WarperIsNotAvailableForRenting\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"requestedRentalPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"minRentalPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxRentalPeriod\",\"type\":\"uint32\"}],\"name\":\"WarperRentalPeriodIsOutOfRange\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"__assetClass\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"__availabilityPeriodEnd\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"__availabilityPeriodRange\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"availabilityPeriodStart\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"availabilityPeriodEnd\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"__availabilityPeriodStart\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"config\",\"type\":\"bytes\"}],\"name\":\"__initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"__maxRentalPeriod\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"__metahub\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"__minRentalPeriod\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"__original\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"__rentalPeriodRange\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"minRentalPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxRentalPeriod\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"availabilityPeriodEnd\",\"type\":\"uint32\"}],\"name\":\"__setAvailabilityPeriodEnd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"availabilityPeriodStart\",\"type\":\"uint32\"}],\"name\":\"__setAvailabilityPeriodStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"maxRentalPeriod\",\"type\":\"uint32\"}],\"name\":\"__setMaxRentalPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"minRentalPeriod\",\"type\":\"uint32\"}],\"name\":\"__setMinRentalPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"interfaceIds\",\"type\":\"bytes4[]\"}],\"name\":\"__supportedInterfaces\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"errors\":{\"CallForwardToZeroAddress()\":[{\"details\":\"Thrown when a call is forwarded to a zero address.\"}],\"CallerIsNotMetahub()\":[{\"details\":\"Thrown when the message sender doesn't match the Metahub address.\"}],\"CallerIsNotWarperAdmin()\":[{\"details\":\"Thrown when the message sender doesn't match the warper admin address.\"}],\"ContractIsAlreadyInitialized()\":[{\"details\":\"Thrown upon attempt to initialize a contract again.\"}],\"ContractIsNotInitializing()\":[{\"details\":\"Thrown when a function is invoked outside of initialization transaction.\"}],\"InvalidAvailabilityPeriodEnd()\":[{\"details\":\"Thrown when the availability period end time is not greater or equal than the start time\"}],\"InvalidAvailabilityPeriodStart()\":[{\"details\":\"Thrown when the availability period start time is not strictly lesser than the end time\"}],\"InvalidMaxRentalPeriod()\":[{\"details\":\"Thrown when the max rental period is not greater or equal than min rental period\"}],\"InvalidMinRentalPeriod()\":[{\"details\":\"Thrown when the the min rental period is not strictly lesser than max rental period\"}],\"InvalidOriginalTokenInterface(address,bytes4)\":[{\"details\":\"Thrown when the original asset contract does not implement the interface, expected by Warper.\"}],\"WarperIsNotAvailableForRenting(uint256,uint32,uint32)\":[{\"details\":\"Thrown when the current time is not withing the warper availability period.\"}],\"WarperRentalPeriodIsOutOfRange(uint32,uint32,uint32)\":[{\"details\":\"Thrown when the requested rental period is not withing the warper allowed rental period range.\"}]},\"kind\":\"dev\",\"methods\":{\"__assetClass()\":{\"details\":\"Returns the warper asset class ID.\"},\"__availabilityPeriodEnd()\":{\"details\":\"Returns warper availability period ending time.\",\"returns\":{\"_0\":\"Unix timestamp after which the warper is NOT rentable.\"}},\"__availabilityPeriodRange()\":{\"details\":\"Returns warper availability period.\",\"returns\":{\"availabilityPeriodEnd\":\"Unix timestamp after which the warper is NOT rentable.\",\"availabilityPeriodStart\":\"Unix timestamp after which the warper is rentable.\"}},\"__availabilityPeriodStart()\":{\"details\":\"Returns warper availability period starting time.\",\"returns\":{\"_0\":\"Unix timestamp after which the warper is rentable.\"}},\"__initialize(bytes)\":{\"details\":\"Warper generic initialization method.\",\"params\":{\"config\":\"Warper configuration parameters.\"}},\"__maxRentalPeriod()\":{\"details\":\"Returns warper maximal rental period.\",\"returns\":{\"_0\":\"Time is seconds.\"}},\"__metahub()\":{\"details\":\"Returns the Metahub address.\"},\"__minRentalPeriod()\":{\"details\":\"Returns warper minimal rental period.\",\"returns\":{\"_0\":\"Time is seconds.\"}},\"__original()\":{\"details\":\"Returns the original NFT address.\"},\"__rentalPeriodRange()\":{\"details\":\"Returns warper rental period range.\",\"returns\":{\"maxRentalPeriod\":\"The maximal amount of time the warper can be rented for.\",\"minRentalPeriod\":\"The minimal amount of time the warper can be rented for.\"}},\"__setAvailabilityPeriodEnd(uint32)\":{\"details\":\"Sets warper availability period ending time.\",\"params\":{\"availabilityPeriodEnd\":\"Unix timestamp after which the warper is NOT rentable.\"}},\"__setAvailabilityPeriodStart(uint32)\":{\"details\":\"Sets warper availability period starting time.\",\"params\":{\"availabilityPeriodStart\":\"Unix timestamp after which the warper is rentable.\"}},\"__setMaxRentalPeriod(uint32)\":{\"details\":\"Sets warper max rental period.\",\"params\":{\"maxRentalPeriod\":\"New max rental period value.\"}},\"__setMinRentalPeriod(uint32)\":{\"details\":\"Sets warper min rental period.\",\"params\":{\"minRentalPeriod\":\"New min rental period value.\"}},\"__supportedInterfaces(bytes4[])\":{\"details\":\"Validates if a warper supports multiple interfaces at once.\",\"returns\":{\"_0\":\"an array of `bool` flags in order as the `interfaceIds` were passed.\"}},\"approve(address,uint256)\":{\"details\":\"Method is disabled, kept only for interface compatibility purposes.\"},\"balanceOf(address)\":{\"details\":\"The rental count calculations get offloaded to the Metahub\"},\"getApproved(uint256)\":{\"details\":\"Method is disabled, kept only for interface compatibility purposes.\"},\"isApprovedForAll(address,address)\":{\"details\":\"Method is disabled, kept only for interface compatibility purposes.\"},\"mint(address,uint256,bytes)\":{\"details\":\"Safely mints `tokenId` and transfers it to `to`. Requirements: - needs to pass validation of `_beforeTokenTransfer()`. - `tokenId` must not exist. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event.\"},\"multicall(bytes[])\":{\"details\":\"Receives and executes a batch of function calls on this contract.\"},\"ownerOf(uint256)\":{\"details\":\"The ownership is dependant on the rental status - metahub is      responsible for tracking the state:          - NONE: revert with an error          - AVAILABLE: means, that the token is not currently rented. Metahub is the owner.          - RENTED: Use the Warpers internal ownership constructs\"},\"safeTransferFrom(address,address,uint256)\":{\"details\":\"Need to fulfill all the requirements of `_transfer()`\"},\"safeTransferFrom(address,address,uint256,bytes)\":{\"details\":\"Need to fulfill all the requirements of `_transfer()`\"},\"setApprovalForAll(address,bool)\":{\"details\":\"Method is disabled, kept only for interface compatibility purposes.\"},\"supportsInterface(bytes4)\":{\"details\":\"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"Need to fulfill all the requirements of `_transfer()`\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/warper/ERC721/presets/ERC721PresetConfigurable.sol\":\"ERC721PresetConfigurable\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3e26a49d2fa5ef8338b8a9467c91e54f417cb07e849b1cc0f4ebc4d2a147938e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x55cf2bd9fc76704ddcdc19834cd288b7de00fc0f298a40ea16a954ae8991db2d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary CountersUpgradeable {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\",\"keccak256\":\"0x798741e231b22b81e2dd2eddaaf8832dee4baf5cd8e2dbaa5c1dd12a1c053c4d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableMapUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableMap.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./EnumerableSetUpgradeable.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`) since v4.6.0\\n */\\nlibrary EnumerableMapUpgradeable {\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.Bytes32Set;\\n\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct Bytes32ToBytes32Map {\\n        // Storage of keys\\n        EnumerableSetUpgradeable.Bytes32Set _keys;\\n        mapping(bytes32 => bytes32) _values;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n        bytes32 key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == bytes32(0)) {\\n            return (contains(map, key), bytes32(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), \\\"EnumerableMap: nonexistent key\\\");\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\\n     */\\n    function get(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), errorMessage);\\n        return value;\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        address value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\\n    }\\n\\n    // AddressToUintMap\\n\\n    struct AddressToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        AddressToUintMap storage map,\\n        address key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n        return remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (address(uint160(uint256(key))), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        AddressToUintMap storage map,\\n        address key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\\n    }\\n}\\n\",\"keccak256\":\"0x44183e3aa61358ae381c27fa837010552ba90f66d620cf1ba6544f567caa7f3f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x1976ce0aadaa551a0fecab9930a7f4956252fa40594c8d165f682020f0e826c0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\",\"keccak256\":\"0xaf297d12d8d4a57fe01a70f0ef38908f208e3faedc577056d0b728fa2f3ccf0c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/extensions/IERC721Metadata.sol\\\";\\n\",\"keccak256\":\"0x1e88abdf82fcbbf98f97be17ea56c924376350637896bc37366ec9f89b7c2628\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721Receiver.sol\\\";\\n\",\"keccak256\":\"0x7bd5dc796c245d4c52836610455d172cdfcc1f8dcf0d9b1c4cbde212fde02965\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0d4de01fe5360c38b4ad2b0822a12722958428f5138a7ff47c1720eb6fa52bba\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Multicall.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract Multicall {\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     */\\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n}\\n\",\"keccak256\":\"0x35e30a35e23f856cbcee3558b7efdd83f6017a8f1b419710645143d98e892463\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xfe1b7a9aa2a530a9e705b220e26cd584e2fbdc9602a3a1066032b12816b46aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\\n        if (result.length < 32) return false;\\n        return success && abi.decode(result, (bool));\\n    }\\n}\\n\",\"keccak256\":\"0xf7291d7213336b00ee7edbf7cd5034778dd7b0bda2a7489e664f1e5cacc6c24e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/accounting/Accounts.sol\":{\"content\":\"// solhint-disable private-vars-leading-underscore\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableMapUpgradeable.sol\\\";\\nimport \\\"../renting/Rentings.sol\\\";\\nimport \\\"../universe/IUniverseRegistry.sol\\\";\\nimport \\\"../listing/Listings.sol\\\";\\nimport \\\"./IPaymentManager.sol\\\";\\n\\nlibrary Accounts {\\n    using Accounts for Account;\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n    using EnumerableMapUpgradeable for EnumerableMapUpgradeable.AddressToUintMap;\\n\\n    /**\\n     * @dev Thrown when the estimated rental fee calculated upon renting\\n     * is higher than maximal payment amount the renter is willing to pay.\\n     */\\n    error RentalFeeSlippage();\\n\\n    /**\\n     * @dev Thrown when the amount requested to be paid out is not valid.\\n     */\\n    error InvalidWithdrawalAmount(uint256 amount);\\n\\n    /**\\n     * @dev Thrown when the amount requested to be paid out is larger than available balance.\\n     */\\n    error InsufficientBalance(uint256 balance);\\n\\n    /**\\n     * @dev A structure that describes account balance in ERC20 tokens.\\n     */\\n    struct Balance {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * @dev Describes an account state.\\n     * @param tokenBalances Mapping from an ERC20 token address to the amount.\\n     */\\n    struct Account {\\n        EnumerableMapUpgradeable.AddressToUintMap tokenBalances;\\n    }\\n\\n    /**\\n     * @dev Transfers funds from the account balance to the specific address after validating balance sufficiency.\\n     */\\n    function withdraw(\\n        Account storage self,\\n        address token,\\n        uint256 amount,\\n        address to\\n    ) external {\\n        if (amount == 0) revert InvalidWithdrawalAmount(amount);\\n        uint256 currentBalance = self.balance(token);\\n        if (amount > currentBalance) revert InsufficientBalance(currentBalance);\\n        unchecked {\\n            self.tokenBalances.set(token, currentBalance - amount);\\n        }\\n        IERC20Upgradeable(token).safeTransfer(to, amount);\\n    }\\n\\n    struct RentalEarnings {\\n        // Lister\\n        address lister;\\n        uint256 listerFee;\\n        address listerPaymentToken;\\n        IPaymentManager.EarningType earningType;\\n        // Universe\\n        uint256 universeId;\\n        uint256 universeFee;\\n        address universePaymentToken;\\n        // Protocol\\n        uint256 protocolFee;\\n        address protocolPaymentToken;\\n    }\\n\\n    function handleRentalPayment(\\n        Accounts.Registry storage self,\\n        Rentings.Params calldata rentingParams,\\n        Rentings.RentalFees calldata fees,\\n        address payer,\\n        uint256 maxPaymentAmount,\\n        Warpers.Registry storage warperRegistry,\\n        Listings.Registry storage listingRegistry\\n    ) external returns (RentalEarnings memory earnings) {\\n        earnings.listerPaymentToken = rentingParams.paymentToken;\\n        earnings.universePaymentToken = rentingParams.paymentToken;\\n        earnings.protocolPaymentToken = rentingParams.paymentToken;\\n\\n        // Ensure no rental fee payment slippage.\\n        if (fees.total > maxPaymentAmount) revert RentalFeeSlippage();\\n\\n        // The amount of payment tokens to be accumulated on the Metahub for future payouts.\\n        // This will include all fees which are not being paid out immediately.\\n        uint256 accumulatedTokens = 0;\\n\\n        // Handle lister fee component.\\n        Listings.Listing storage listing = listingRegistry.listings[rentingParams.listingId];\\n        earnings.listerFee = fees.listerBaseFee + fees.listerPremium;\\n        earnings.earningType = IPaymentManager.EarningType.LISTER_FEE;\\n        // If lister requested immediate payouts, transfer the lister fee part directly to the lister account.\\n        // Otherwise increase the lister balance.\\n        earnings.lister = listing.lister;\\n        if (listing.immediatePayout) {\\n            IERC20Upgradeable(rentingParams.paymentToken).safeTransferFrom(payer, earnings.lister, earnings.listerFee);\\n        } else {\\n            self.users[earnings.lister].increaseBalance(rentingParams.paymentToken, earnings.listerFee);\\n            accumulatedTokens += earnings.listerFee;\\n        }\\n\\n        // Handle universe fee component.\\n        earnings.universeId = warperRegistry.warpers[rentingParams.warper].universeId;\\n        earnings.universeFee = fees.universeBaseFee + fees.universePremium;\\n        // Increase universe balance.\\n        self.universes[earnings.universeId].increaseBalance(rentingParams.paymentToken, earnings.universeFee);\\n        accumulatedTokens += earnings.universeFee;\\n\\n        // Handle protocol fee component.\\n        earnings.protocolFee = fees.protocolFee;\\n        self.protocol.increaseBalance(rentingParams.paymentToken, earnings.protocolFee);\\n        accumulatedTokens += earnings.protocolFee;\\n\\n        // Transfer the accumulated token amount from payer to the metahub.\\n        IERC20Upgradeable(rentingParams.paymentToken).safeTransferFrom(payer, address(this), accumulatedTokens);\\n    }\\n\\n    /**\\n     * @dev Increments value of the particular account balance.\\n     */\\n    function increaseBalance(\\n        Account storage self,\\n        address token,\\n        uint256 amount\\n    ) internal {\\n        uint256 currentBalance = self.balance(token);\\n        self.tokenBalances.set(token, currentBalance + amount);\\n    }\\n\\n    /**\\n     * @dev Returns account current balance.\\n     * Does not revert if `token` is not in the map.\\n     */\\n    function balance(Account storage self, address token) internal view returns (uint256) {\\n        (, uint256 value) = self.tokenBalances.tryGet(token);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns the list of account balances in various tokens.\\n     */\\n    function balances(Account storage self) internal view returns (Balance[] memory) {\\n        uint256 length = self.tokenBalances.length();\\n        Balance[] memory allBalances = new Balance[](length);\\n        for (uint256 i = 0; i < length; i++) {\\n            (address token, uint256 amount) = self.tokenBalances.at(i);\\n            allBalances[i] = Balance({token: token, amount: amount});\\n        }\\n        return allBalances;\\n    }\\n\\n    /**\\n     * @dev Account registry.\\n     * @param protocol The protocol account state.\\n     * @param universes Mapping from a universe ID to the universe account state.\\n     * @param users Mapping from a user address to the account state.\\n     */\\n    struct Registry {\\n        Account protocol;\\n        mapping(uint256 => Account) universes;\\n        mapping(address => Account) users;\\n    }\\n}\\n\",\"keccak256\":\"0x3a5144759186501e2167eb0ad5e7cc22c6d128ece974d70504467ef8c44abffd\",\"license\":\"MIT\"},\"contracts/accounting/IPaymentManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./Accounts.sol\\\";\\n\\ninterface IPaymentManager {\\n    /**\\n     * @notice Describes the earning type.\\n     */\\n    enum EarningType {\\n        LISTER_FEE\\n    }\\n\\n    /**\\n     * @dev Emitted when a user has earned some amount tokens.\\n     * @param user Address of the user that earned some amount.\\n     * @param earningType Describes the type of the user.\\n     * @param paymentToken The currency that the user has earned.\\n     * @param amount The amount of tokens that the user has earned.\\n     */\\n    event UserEarned(\\n        address indexed user,\\n        EarningType indexed earningType,\\n        address indexed paymentToken,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted when the universe has earned some amount of tokens.\\n     * @param universeId ID of the universe that earned the tokens.\\n     * @param paymentToken The currency that the user has earned.\\n     * @param amount The amount of tokens that the user has earned.\\n     */\\n    event UniverseEarned(uint256 indexed universeId, address indexed paymentToken, uint256 amount);\\n\\n    /**\\n     * @dev Emitted when the protocol has earned some amount of tokens.\\n     * @param paymentToken The currency that the user has earned.\\n     * @param amount The amount of tokens that the user has earned.\\n     */\\n    event ProtocolEarned(address indexed paymentToken, uint256 amount);\\n\\n    /**\\n     * @dev Transfers the specific `amount` of `token` from a protocol balance to an arbitrary address.\\n     * @param token The token address.\\n     * @param amount The amount to be withdrawn.\\n     * @param to The payee address.\\n     */\\n    function withdrawProtocolFunds(\\n        address token,\\n        uint256 amount,\\n        address to\\n    ) external;\\n\\n    /**\\n     * @dev Transfers the specific `amount` of `token` from a universe balance to an arbitrary address.\\n     * @param universeId The universe ID.\\n     * @param token The token address.\\n     * @param amount The amount to be withdrawn.\\n     * @param to The payee address.\\n     */\\n    function withdrawUniverseFunds(\\n        uint256 universeId,\\n        address token,\\n        uint256 amount,\\n        address to\\n    ) external;\\n\\n    /**\\n     * @dev Transfers the specific `amount` of `token` from a user balance to an arbitrary address.\\n     * @param token The token address.\\n     * @param amount The amount to be withdrawn.\\n     * @param to The payee address.\\n     */\\n    function withdrawFunds(\\n        address token,\\n        uint256 amount,\\n        address to\\n    ) external;\\n\\n    /**\\n     * @dev Returns the amount of `token`, currently accumulated by the protocol.\\n     * @param token The token address.\\n     * @return Balance of `token`.\\n     */\\n    function protocolBalance(address token) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the list of protocol balances in various tokens.\\n     * @return List of balances.\\n     */\\n    function protocolBalances() external view returns (Accounts.Balance[] memory);\\n\\n    /**\\n     * @dev Returns the amount of `token`, currently accumulated by the universe.\\n     * @param universeId The universe ID.\\n     * @param token The token address.\\n     * @return Balance of `token`.\\n     */\\n    function universeBalance(uint256 universeId, address token) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the list of universe balances in various tokens.\\n     * @param universeId The universe ID.\\n     * @return List of balances.\\n     */\\n    function universeBalances(uint256 universeId) external view returns (Accounts.Balance[] memory);\\n\\n    /**\\n     * @dev Returns the amount of `token`, currently accumulated by the user.\\n     * @param account The account to query the balance for.\\n     * @param token The token address.\\n     * @return Balance of `token`.\\n     */\\n    function balance(address account, address token) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the list of user balances in various tokens.\\n     * @param account The account to query the balance for.\\n     * @return List of balances.\\n     */\\n    function balances(address account) external view returns (Accounts.Balance[] memory);\\n}\\n\",\"keccak256\":\"0x3d2b71e5b7d2c2a96919443ee96f2951596d537bb71a671db355d35862e372e9\",\"license\":\"MIT\"},\"contracts/asset/Assets.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"./IAssetController.sol\\\";\\nimport \\\"./IAssetVault.sol\\\";\\nimport \\\"./IAssetClassRegistry.sol\\\";\\n\\nlibrary Assets {\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n    using Address for address;\\n    using Assets for Registry;\\n    using Assets for Asset;\\n\\n    /*\\n     * @dev This is the list of asset class identifiers to be used across the system.\\n     */\\n    bytes4 public constant ERC721 = bytes4(keccak256(\\\"ERC721\\\"));\\n    bytes4 public constant ERC1155 = bytes4(keccak256(\\\"ERC1155\\\"));\\n\\n    bytes32 public constant ASSET_ID_TYPEHASH = keccak256(\\\"AssetId(bytes4 class,bytes data)\\\");\\n\\n    bytes32 public constant ASSET_TYPEHASH =\\n        keccak256(\\\"Asset(AssetId id,uint256 value)AssetId(bytes4 class,bytes data)\\\");\\n\\n    /**\\n     * @dev Thrown when the asset class is not registered or deprecated.\\n     * @param assetClass Asset class ID.\\n     */\\n    error UnsupportedAssetClass(bytes4 assetClass);\\n\\n    /**\\n     * @dev Thrown upon attempting to register an asset twice.\\n     * @param asset Duplicate asset address.\\n     */\\n    error AssetIsAlreadyRegistered(address asset);\\n\\n    /**\\n     * @dev Communicates asset identification information.\\n     * The structure designed to be token-standard agnostic,\\n     * so the layout of `data` might vary for different token standards.\\n     * For example, in case of ERC721 token, the `data` will contain contract address and tokenId.\\n     * @param class Asset class ID\\n     * @param data Asset identification data.\\n     */\\n    struct AssetId {\\n        bytes4 class;\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Calculates Asset ID hash\\n     */\\n    function hash(AssetId memory assetId) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(ASSET_ID_TYPEHASH, assetId.class, keccak256(assetId.data)));\\n    }\\n\\n    /**\\n     * @dev Extracts token contract address from the Asset ID structure.\\n     * The address is the common attribute for all assets regardless of their asset class.\\n     */\\n    function token(AssetId memory self) internal pure returns (address) {\\n        return abi.decode(self.data, (address));\\n    }\\n\\n    /**\\n     * @dev Uniformed structure to describe arbitrary asset (token) and its value.\\n     * @param id Asset ID structure.\\n     * @param value Asset value (amount).\\n     */\\n    struct Asset {\\n        AssetId id;\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Calculates Asset hash\\n     */\\n    function hash(Asset memory asset) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(ASSET_TYPEHASH, hash(asset.id), asset.value));\\n    }\\n\\n    /**\\n     * @dev Extracts token contract address from the Asset structure.\\n     * The address is the common attribute for all assets regardless of their asset class.\\n     */\\n    function token(Asset memory self) internal pure returns (address) {\\n        return abi.decode(self.id.data, (address));\\n    }\\n\\n    /**\\n     * @dev Original asset data.\\n     * @param controller Asset controller.\\n     * @param assetClass The asset class identifier.\\n     * @param vault Asset vault.\\n     */\\n    struct AssetConfig {\\n        IAssetController controller;\\n        bytes4 assetClass;\\n        IAssetVault vault;\\n    }\\n\\n    /**\\n     * @dev Asset registry.\\n     * @param classRegistry Asset class registry contract.\\n     * @param assetIndex Set of registered asset addresses.\\n     * @param assets Mapping from asset address to the asset configuration.\\n     */\\n    struct Registry {\\n        IAssetClassRegistry classRegistry;\\n        EnumerableSetUpgradeable.AddressSet assetIndex;\\n        mapping(address => AssetConfig) assets;\\n    }\\n\\n    /**\\n     * @dev Registers new asset.\\n     */\\n    function registerAsset(\\n        Registry storage self,\\n        bytes4 assetClass,\\n        address asset\\n    ) external {\\n        if (!self.assetIndex.add(asset)) revert AssetIsAlreadyRegistered(asset);\\n\\n        IAssetClassRegistry.ClassConfig memory assetClassConfig = self.classRegistry.assetClassConfig(assetClass);\\n        self.assets[asset] = AssetConfig({\\n            controller: IAssetController(assetClassConfig.controller),\\n            assetClass: assetClass,\\n            vault: IAssetVault(assetClassConfig.vault)\\n        });\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings and their corresponding asset configs.\\n     */\\n    function supportedAssets(\\n        Registry storage self,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory, AssetConfig[] memory) {\\n        uint256 indexSize = self.assetIndex.length();\\n        if (offset >= indexSize) return (new address[](0), new AssetConfig[](0));\\n\\n        if (limit > indexSize - offset) {\\n            limit = indexSize - offset;\\n        }\\n\\n        AssetConfig[] memory assetConfigs = new AssetConfig[](limit);\\n        address[] memory assetAddresses = new address[](limit);\\n        for (uint256 i = 0; i < limit; i++) {\\n            assetAddresses[i] = self.assetIndex.at(offset + i);\\n            assetConfigs[i] = self.assets[assetAddresses[i]];\\n        }\\n        return (assetAddresses, assetConfigs);\\n    }\\n\\n    /**\\n     * @dev Transfers an asset to the vault using associated controller.\\n     */\\n    function transferAssetToVault(\\n        Registry storage self,\\n        Assets.Asset memory asset,\\n        address from\\n    ) external {\\n        // Extract token address from asset struct and check whether the asset is supported.\\n        address assetToken = asset.token();\\n\\n        // Transfer asset to the class asset specific vault.\\n        address assetController = address(self.assets[assetToken].controller);\\n        address assetVault = address(self.assets[assetToken].vault);\\n        assetController.functionDelegateCall(\\n            abi.encodeWithSelector(IAssetController.transferAssetToVault.selector, asset, from, assetVault)\\n        );\\n    }\\n\\n    /**\\n     * @dev Transfers an asset from the vault using associated controller.\\n     */\\n    function returnAssetFromVault(Registry storage self, Assets.Asset memory asset) external {\\n        address assetToken = asset.token();\\n        address assetController = address(self.assets[assetToken].controller);\\n        address assetVault = address(self.assets[assetToken].vault);\\n\\n        assetController.functionDelegateCall(\\n            abi.encodeWithSelector(IAssetController.returnAssetFromVault.selector, asset, assetVault)\\n        );\\n    }\\n\\n    function assetCount(Registry storage self) internal view returns (uint256) {\\n        return self.assetIndex.length();\\n    }\\n\\n    /**\\n     * @dev Checks asset registration by address.\\n     */\\n    function isRegisteredAsset(Registry storage self, address asset) internal view returns (bool) {\\n        return self.assetIndex.contains(asset);\\n    }\\n\\n    /**\\n     * @dev Reverts if asset class is not supported.\\n     * @param assetClass Asset class ID.\\n     */\\n    function checkSupportedAssetClass(Registry storage self, bytes4 assetClass) internal view {\\n        if (!self.classRegistry.isRegisteredAssetClass(assetClass)) revert UnsupportedAssetClass(assetClass);\\n    }\\n\\n    /**\\n     * @dev Returns controller for asset class.\\n     * @param assetClass Asset class ID.\\n     */\\n    function assetClassController(Registry storage self, bytes4 assetClass) internal view returns (address) {\\n        return self.classRegistry.assetClassConfig(assetClass).controller;\\n    }\\n}\\n\",\"keccak256\":\"0x9b4edcf42a986391b41e6b70850c8befaf74d11e5be6f13268a71a2d21b3b45c\",\"license\":\"MIT\"},\"contracts/asset/IAssetClassRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./IAssetController.sol\\\";\\nimport \\\"./IAssetVault.sol\\\";\\n\\ninterface IAssetClassRegistry {\\n    /**\\n     * @dev Thrown when the asset class supported by contract does not match the required one.\\n     * @param provided Provided class ID.\\n     * @param required Required class ID.\\n     */\\n    error AssetClassMismatch(bytes4 provided, bytes4 required);\\n\\n    /**\\n     * @dev Thrown upon attempting to register an asset class twice.\\n     * @param assetClass Duplicate asset class ID.\\n     */\\n    error AssetClassIsAlreadyRegistered(bytes4 assetClass);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with unregistered asset class.\\n     * @param assetClass Asset class ID.\\n     */\\n    error UnregisteredAssetClass(bytes4 assetClass);\\n\\n    /**\\n     * @dev Thrown when the asset controller contract does not implement the required interface.\\n     */\\n    error InvalidAssetControllerInterface();\\n\\n    /**\\n     * @dev Thrown when the vault contract does not implement the required interface.\\n     */\\n    error InvalidAssetVaultInterface();\\n\\n    /**\\n     * @dev Emitted when the new asset class is registered.\\n     * @param assetClass Asset class ID.\\n     * @param controller Controller address.\\n     * @param vault Vault address.\\n     */\\n    event AssetClassRegistered(bytes4 indexed assetClass, address indexed controller, address indexed vault);\\n\\n    /**\\n     * @dev Emitted when the asset class controller is changed.\\n     * @param assetClass Asset class ID.\\n     * @param newController New controller address.\\n     */\\n    event AssetClassControllerChanged(bytes4 indexed assetClass, address indexed newController);\\n\\n    /**\\n     * @dev Emitted when the asset class vault is changed.\\n     * @param assetClass Asset class ID.\\n     * @param newVault New vault address.\\n     */\\n    event AssetClassVaultChanged(bytes4 indexed assetClass, address indexed newVault);\\n\\n    /**\\n     * @dev Asset class configuration.\\n     * @param vault Asset class vault.\\n     * @param controller Asset class controller.\\n     */\\n    struct ClassConfig {\\n        address vault;\\n        address controller;\\n    }\\n\\n    /**\\n     * @dev Registers new asset class.\\n     * @param assetClass Asset class ID.\\n     * @param config Asset class initial configuration.\\n     */\\n    function registerAssetClass(bytes4 assetClass, ClassConfig calldata config) external;\\n\\n    /**\\n     * @dev Sets asset class vault.\\n     * @param assetClass Asset class ID.\\n     * @param vault Asset class vault address.\\n     */\\n    function setAssetClassVault(bytes4 assetClass, address vault) external;\\n\\n    /**\\n     * @dev Sets asset class controller.\\n     * @param assetClass Asset class ID.\\n     * @param controller Asset class controller address.\\n     */\\n    function setAssetClassController(bytes4 assetClass, address controller) external;\\n\\n    /**\\n     * @dev Returns asset class configuration.\\n     * @param assetClass Asset class ID.\\n     * @return Asset class configuration.\\n     */\\n    function assetClassConfig(bytes4 assetClass) external view returns (ClassConfig memory);\\n\\n    /**\\n     * @dev Checks asset class registration.\\n     * @param assetClass Asset class ID.\\n     */\\n    function isRegisteredAssetClass(bytes4 assetClass) external view returns (bool);\\n\\n    /**\\n     * @dev Reverts if asset class is not registered.\\n     * @param assetClass Asset class ID.\\n     */\\n    function checkRegisteredAssetClass(bytes4 assetClass) external view;\\n}\\n\",\"keccak256\":\"0x791149d58a1753825558861d216ab2e9b0760987c6192b5c329b132a8d834ae1\",\"license\":\"MIT\"},\"contracts/asset/IAssetController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"./Assets.sol\\\";\\n\\ninterface IAssetController is IERC165 {\\n    /**\\n     * @dev Thrown when the asset has invalid class for specific operation.\\n     * @param provided Provided class ID.\\n     * @param required Required class ID.\\n     */\\n    error AssetClassMismatch(bytes4 provided, bytes4 required);\\n\\n    /**\\n     * @dev Emitted when asset is transferred.\\n     * @param asset Asset being transferred.\\n     * @param from Asset sender.\\n     * @param to Asset recipient.\\n     * @param data Auxiliary data.\\n     */\\n    event AssetTransfer(Assets.Asset asset, address indexed from, address indexed to, bytes data);\\n\\n    /**\\n     * @dev Returns controller asset class.\\n     * @return Asset class ID.\\n     */\\n    function assetClass() external pure returns (bytes4);\\n\\n    /**\\n     * @dev Transfers asset.\\n     * Emits a {AssetTransfer} event.\\n     * @param asset Asset being transferred.\\n     * @param from Asset sender.\\n     * @param to Asset recipient.\\n     * @param data Auxiliary data.\\n     */\\n    function transfer(\\n        Assets.Asset memory asset,\\n        address from,\\n        address to,\\n        bytes memory data\\n    ) external;\\n\\n    /**\\n     * @dev Transfers asset from owner to the vault contract.\\n     * @param asset Asset being transferred.\\n     * @param assetOwner Original asset owner address.\\n     * @param vault Asset vault contract address.\\n     */\\n    function transferAssetToVault(\\n        Assets.Asset memory asset,\\n        address assetOwner,\\n        address vault\\n    ) external;\\n\\n    /**\\n     * @dev Transfers asset from the vault contract to the original owner.\\n     * @param asset Asset being transferred.\\n     * @param vault Asset vault contract address.\\n     */\\n    function returnAssetFromVault(Assets.Asset memory asset, address vault) external;\\n\\n    /**\\n     * @dev Decodes asset ID structure and returns collection identifier.\\n     * The collection ID is byte32 value which is calculated based on the asset class.\\n     * For example, ERC721 collection can be identified by address only,\\n     * but for ERC1155 it should be calculated based on address and token ID.\\n     * @return Collection ID.\\n     */\\n    function collectionId(Assets.AssetId memory assetId) external pure returns (bytes32);\\n}\\n\",\"keccak256\":\"0x54937de22824b9758e92253812167e820af4badc567eca38b2152d9d33a6e68d\",\"license\":\"MIT\"},\"contracts/asset/IAssetVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\n\\ninterface IAssetVault is IERC165 {\\n    /**\\n     * @dev Thrown when the asset is not is found among vault inventory.\\n     */\\n    error AssetNotFound();\\n\\n    /**\\n     * @dev Thrown when the function is called on the vault in recovery mode.\\n     */\\n    error VaultIsInRecoveryMode();\\n\\n    /**\\n     * @dev Thrown when the asset return is not allowed, due to the vault state or the caller permissions.\\n     */\\n    error AssetReturnIsNotAllowed();\\n\\n    /**\\n     * @dev Thrown when the asset deposit is not allowed, due to the vault state or the caller permissions.\\n     */\\n    error AssetDepositIsNotAllowed();\\n\\n    /**\\n     * @dev Emitted when the vault is switched to recovery mode by `account`.\\n     */\\n    event RecoveryModeActivated(address account);\\n\\n    /**\\n     * @dev Activates asset recovery mode.\\n     * Emits a {RecoveryModeActivated} event.\\n     */\\n    function switchToRecoveryMode() external;\\n\\n    /**\\n     * @dev Pauses the vault.\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @dev Unpauses the vault.\\n     */\\n    function unpause() external;\\n\\n    /**\\n     * @dev Returns vault asset class.\\n     * @return Asset class ID.\\n     */\\n    function assetClass() external pure returns (bytes4);\\n\\n    /**\\n     * @dev Returns the Metahub address.\\n     */\\n    function metahub() external view returns (address);\\n\\n    /**\\n     * @dev Returns vault recovery mode flag state.\\n     * @return True when the vault is in recovery mode.\\n     */\\n    function isRecovery() external view returns (bool);\\n}\\n\",\"keccak256\":\"0xb40edb1c017bd69088a8e7ade46127ae932d1f497ea6e36e5ed75a269ce6eb3b\",\"license\":\"MIT\"},\"contracts/listing/IListingController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"./Listings.sol\\\";\\nimport \\\"../renting/Rentings.sol\\\";\\n\\ninterface IListingController is IERC165 {\\n    /**\\n     * @dev Thrown when the listing strategy ID does not match the required one.\\n     * @param provided Provided listing strategy ID.\\n     * @param required Required listing strategy ID.\\n     */\\n    error ListingStrategyMismatch(bytes4 provided, bytes4 required);\\n\\n    /**\\n     * @dev Returns implemented strategy ID.\\n     * @return Listing strategy ID.\\n     */\\n    function strategyId() external pure returns (bytes4);\\n\\n    /**\\n     * @dev Calculates rental fee based on renting params and implemented listing strategy.\\n     * @param listingParams Listing strategy params.\\n     * @param rentingParams Renting params.\\n     * @return Rental fee.\\n     */\\n    function calculateRentalFee(Listings.Params calldata listingParams, Rentings.Params calldata rentingParams)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\",\"keccak256\":\"0x4c11cc5107243b27b514587f3ee61fae92dac30580e77a4c68e5668f17edb5f7\",\"license\":\"MIT\"},\"contracts/listing/IListingManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"../asset/Assets.sol\\\";\\nimport \\\"../asset/IAssetController.sol\\\";\\nimport \\\"../listing/IListingController.sol\\\";\\nimport \\\"./Listings.sol\\\";\\n\\ninterface IListingManager {\\n    /**\\n     * @dev Thrown when the message sender doesn't match the asset lister address.\\n     */\\n    error CallerIsNotAssetLister();\\n\\n    /**\\n     * @dev Thrown when the original asset cannot be withdrawn because of active rentals\\n     * or other activity that requires asset to stay in the vault.\\n     */\\n    error AssetIsLocked();\\n\\n    /**\\n     * @dev Emitted when a new asset is listed for renting.\\n     * @param listingId Listing ID.\\n     * @param lister Lister account address.\\n     * @param asset Listing asset.\\n     * @param params Listing strategy parameters.\\n     * @param maxLockPeriod The maximum amount of time the original asset owner can wait before getting the asset back.\\n     */\\n    event AssetListed(\\n        uint256 indexed listingId,\\n        address indexed lister,\\n        Assets.Asset asset,\\n        Listings.Params params,\\n        uint32 maxLockPeriod\\n    );\\n\\n    /**\\n     * @dev Emitted when the asset is no longer available for renting.\\n     * @param listingId Listing ID.\\n     * @param lister Lister account address.\\n     * @param unlocksAt The earliest possible time when the asset can be returned to the owner.\\n     */\\n    event AssetDelisted(uint256 indexed listingId, address indexed lister, uint32 unlocksAt);\\n\\n    /**\\n     * @dev Emitted when the asset is returned to the `lister`.\\n     * @param listingId Listing ID.\\n     * @param lister Lister account address.\\n     * @param asset Returned asset.\\n     */\\n    event AssetWithdrawn(uint256 indexed listingId, address indexed lister, Assets.Asset asset);\\n\\n    /**\\n     * @dev Emitted when the listing is paused.\\n     * @param listingId Listing ID.\\n     */\\n    event ListingPaused(uint256 indexed listingId);\\n\\n    /**\\n     * @dev Emitted when the listing pause is lifted.\\n     * @param listingId Listing ID.\\n     */\\n    event ListingUnpaused(uint256 indexed listingId);\\n\\n    /**\\n     * @dev Performs new asset listing.\\n     * Emits an {AssetListed} event.\\n     * @param asset Asset to be listed.\\n     * @param params Listing strategy parameters.\\n     * @param maxLockPeriod The maximum amount of time the original asset owner can wait before getting the asset back.\\n     * @param immediatePayout Indicates whether the rental fee must be transferred to the lister on every renting.\\n     * If FALSE, the rental fees get accumulated until withdrawn manually.\\n     * @return New listing ID.\\n     */\\n    function listAsset(\\n        Assets.Asset calldata asset,\\n        Listings.Params calldata params,\\n        uint32 maxLockPeriod,\\n        bool immediatePayout\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Marks the asset as being delisted. This operation in irreversible.\\n     * After delisting, the asset can only be withdrawn when it has no active rentals.\\n     * Emits an {AssetDelisted} event.\\n     * @param listingId Listing ID.\\n     */\\n    function delistAsset(uint256 listingId) external;\\n\\n    /**\\n     * @dev Returns the asset back to the lister.\\n     * Emits an {AssetWithdrawn} event.\\n     * @param listingId Listing ID.\\n     */\\n    function withdrawAsset(uint256 listingId) external;\\n\\n    /**\\n     * @dev Puts the listing on pause.\\n     * Emits a {ListingPaused} event.\\n     * @param listingId Listing ID.\\n     */\\n    function pauseListing(uint256 listingId) external;\\n\\n    /**\\n     * @dev Lifts the listing pause.\\n     * Emits a {ListingUnpaused} event.\\n     * @param listingId Listing ID.\\n     */\\n    function unpauseListing(uint256 listingId) external;\\n\\n    /**\\n     * @dev Returns the listing details by the listing ID.\\n     * @param listingId Listing ID.\\n     * @return Listing details.\\n     */\\n    function listingInfo(uint256 listingId) external view returns (Listings.Listing memory);\\n\\n    /**\\n     * @dev Returns the number of currently registered listings.\\n     * @return Listing count.\\n     */\\n    function listingCount() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings.\\n     * @param offset Starting index.\\n     * @param limit Max number of items.\\n     * @return Listing IDs.\\n     * @return Listings.\\n     */\\n    function listings(uint256 offset, uint256 limit)\\n        external\\n        view\\n        returns (uint256[] memory, Listings.Listing[] memory);\\n\\n    /**\\n     * @dev Returns the number of currently registered listings for the particular lister account.\\n     * @param lister Lister address.\\n     * @return Listing count.\\n     */\\n    function userListingCount(address lister) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings for the particular lister account.\\n     * @param lister Lister address.\\n     * @param offset Starting index.\\n     * @param limit Max number of items.\\n     * @return Listing IDs.\\n     * @return Listings.\\n     */\\n    function userListings(\\n        address lister,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Listings.Listing[] memory);\\n\\n    /**\\n     * @dev Returns the number of currently registered listings for the particular original asset address.\\n     * @param original Original asset address.\\n     * @return Listing count.\\n     */\\n    function assetListingCount(address original) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings for the particular original asset address.\\n     * @param original Original asset address.\\n     * @param offset Starting index.\\n     * @param limit Max number of items.\\n     * @return Listing IDs.\\n     * @return Listings.\\n     */\\n    function assetListings(\\n        address original,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Listings.Listing[] memory);\\n}\\n\",\"keccak256\":\"0x7dea68a5bd268376449957acaae514a478df4807ce4b4ef9c9a3c2960b75664b\",\"license\":\"MIT\"},\"contracts/listing/IListingStrategyRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./Listings.sol\\\";\\nimport \\\"./IListingController.sol\\\";\\n\\ninterface IListingStrategyRegistry {\\n    /**\\n     * @dev Thrown when listing controller does not implement the required interface.\\n     */\\n    error InvalidListingControllerInterface();\\n\\n    /**\\n     * @dev Thrown when the listing cannot be processed by the specific controller due to the listing strategy ID\\n     * mismatch.\\n     * @param provided Provided listing strategy ID.\\n     * @param required Required listing strategy ID.\\n     */\\n    error ListingStrategyMismatch(bytes4 provided, bytes4 required);\\n\\n    /**\\n     * @dev Thrown upon attempting to register a listing strategy twice.\\n     * @param strategyId Duplicate listing strategy ID.\\n     */\\n    error ListingStrategyIsAlreadyRegistered(bytes4 strategyId);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with unregistered listing strategy.\\n     * @param strategyId Listing strategy ID.\\n     */\\n    error UnregisteredListingStrategy(bytes4 strategyId);\\n\\n    /**\\n     * @dev Emitted when the new listing strategy is registered.\\n     * @param strategyId Listing strategy ID.\\n     * @param controller Controller address.\\n     */\\n    event ListingStrategyRegistered(bytes4 indexed strategyId, address indexed controller);\\n\\n    /**\\n     * @dev Emitted when the listing strategy controller is changed.\\n     * @param strategyId Listing strategy ID.\\n     * @param newController Controller address.\\n     */\\n    event ListingStrategyControllerChanged(bytes4 indexed strategyId, address indexed newController);\\n\\n    /**\\n     * @dev Listing strategy information.\\n     * @param controller Listing controller address.\\n     */\\n    struct StrategyConfig {\\n        address controller;\\n    }\\n\\n    /**\\n     * @dev Registers new listing strategy.\\n     * @param strategyId Listing strategy ID.\\n     * @param config Listing strategy configuration.\\n     */\\n    function registerListingStrategy(bytes4 strategyId, StrategyConfig calldata config) external;\\n\\n    /**\\n     * @dev Sets listing strategy controller.\\n     * @param strategyId Listing strategy ID.\\n     * @param controller Listing controller address.\\n     */\\n    function setListingController(bytes4 strategyId, address controller) external;\\n\\n    /**\\n     * @dev Returns listing strategy configuration.\\n     * @param strategyId Listing strategy ID.\\n     * @return Listing strategy information.\\n     */\\n    function listingStrategy(bytes4 strategyId) external view returns (StrategyConfig memory);\\n\\n    /**\\n     * @dev Returns listing strategy controller.\\n     * @param strategyId Listing strategy ID.\\n     * @return Listing controller address.\\n     */\\n    function listingController(bytes4 strategyId) external view returns (address);\\n\\n    /**\\n     * @dev Checks listing strategy registration.\\n     * @param strategyId Listing strategy ID.\\n     */\\n    function isRegisteredListingStrategy(bytes4 strategyId) external view returns (bool);\\n\\n    /**\\n     * @dev Reverts if listing strategy is not registered.\\n     * @param strategyId Listing strategy ID.\\n     */\\n    function checkRegisteredListingStrategy(bytes4 strategyId) external view;\\n}\\n\",\"keccak256\":\"0xd97861afe17f1485470b4ca44fe2cbedbe407c859aa7068df0936e63dc8de661\",\"license\":\"MIT\"},\"contracts/listing/Listings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\n\\nimport \\\"../asset/Assets.sol\\\";\\nimport \\\"./IListingController.sol\\\";\\nimport \\\"./IListingStrategyRegistry.sol\\\";\\n\\nlibrary Listings {\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\\n    using Listings for Registry;\\n    using Listings for Listing;\\n    using Assets for Assets.Asset;\\n\\n    /**\\n     * @dev Thrown when the `listingId` is invalid or the asset has been delisted.\\n     */\\n    error NotListed(uint256 listingId);\\n\\n    /**\\n     * @dev Thrown when the `listingId` has never been registered.\\n     */\\n    error ListingIsNotRegistered(uint256 listingId);\\n\\n    /**\\n     * @dev Thrown when the operation is not allowed due to the listing being paused.\\n     */\\n    error ListingIsPaused();\\n\\n    /**\\n     * @dev Thrown when the operation is not allowed due to the listing not being paused.\\n     */\\n    error ListingIsNotPaused();\\n\\n    /**\\n     * @dev Thrown when attempting to lock the listed asset for the period longer than the lister allowed.\\n     */\\n    error InvalidLockPeriod(uint32 period);\\n\\n    /**\\n     * @dev Thrown when the listing strategy is not registered or deprecated.\\n     * @param strategyId Unsupported listing strategy ID.\\n     */\\n    error UnsupportedListingStrategy(bytes4 strategyId);\\n\\n    /*\\n     * @dev Listing strategy identifiers to be used across the system:\\n     */\\n    bytes4 public constant FIXED_PRICE = bytes4(keccak256(\\\"FIXED_PRICE\\\"));\\n\\n    /**\\n     * @dev Listing params.\\n     * The layout of `data` might vary for different listing strategies.\\n     * For example, in case of FIXED_PRICE strategy, the `data` might contain only base rate,\\n     * and for more advanced auction strategies it might include period, min bid step etc.\\n     * @param strategy Listing strategy ID\\n     * @param data Listing strategy data.\\n     */\\n    struct Params {\\n        bytes4 strategy;\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Listing structure.\\n     * @param asset Listed asset structure.\\n     * @param params Listing strategy parameters.\\n     * @param lister Lister account address.\\n     * @param maxLockPeriod The maximum amount of time the asset owner can wait before getting the asset back.\\n     * @param lockedTill The earliest possible time when the asset can be returned to the owner.\\n     * @param immediatePayout Indicates whether the rental fee must be transferred to the lister on every renting.\\n     * If FALSE, the rental fees get accumulated until withdrawn manually.\\n     * @param delisted Indicates whether the asset is delisted.\\n     * @param paused Indicates whether the listing is paused.\\n     */\\n    struct Listing {\\n        Assets.Asset asset;\\n        Params params;\\n        address lister;\\n        uint32 maxLockPeriod;\\n        uint32 lockedTill;\\n        bool immediatePayout;\\n        bool delisted;\\n        bool paused;\\n    }\\n\\n    /**\\n     * @dev Puts the listing on pause.\\n     */\\n    function pause(Listing storage self) internal {\\n        if (self.paused) revert ListingIsPaused();\\n\\n        self.paused = true;\\n    }\\n\\n    /**\\n     * @dev Lifts the listing pause.\\n     */\\n    function unpause(Listing storage self) internal {\\n        if (!self.paused) revert ListingIsNotPaused();\\n\\n        self.paused = false;\\n    }\\n\\n    /**\\n     * Determines whether the listing is active.\\n     */\\n    function listed(Listing storage self) internal view returns (bool) {\\n        return self.lister != address(0) && !self.delisted;\\n    }\\n\\n    /**\\n     * @dev Reverts if the listing is paused.\\n     */\\n    function checkNotPaused(Listing storage self) internal view {\\n        if (self.paused) revert ListingIsPaused();\\n    }\\n\\n    /*\\n     * @dev Validates lock period.\\n     */\\n    function isValidLockPeriod(Listing storage self, uint32 lockPeriod) internal view returns (bool) {\\n        return (lockPeriod > 0 && lockPeriod <= self.maxLockPeriod);\\n    }\\n\\n    /**\\n     * @dev Reverts if the lock period is not valid.\\n     */\\n    function checkValidLockPeriod(Listing storage self, uint32 lockPeriod) internal view {\\n        if (!self.isValidLockPeriod(lockPeriod)) revert InvalidLockPeriod(lockPeriod);\\n    }\\n\\n    /**\\n     * @dev Extends listing lock time.\\n     * Does not modify the state if current lock time is larger.\\n     */\\n    function addLock(Listing storage self, uint32 unlockTimestamp) internal {\\n        // Listing is already locked till later time, no need to extend locking period.\\n        if (self.lockedTill >= unlockTimestamp) return;\\n        // Extend listing lock.\\n        self.lockedTill = unlockTimestamp;\\n    }\\n\\n    /**\\n     * @dev Listing related data associated with the specific account.\\n     * @param listingIndex The set of listing IDs.\\n     */\\n    struct ListerInfo {\\n        EnumerableSetUpgradeable.UintSet listingIndex;\\n    }\\n    /**\\n     * @dev Listing related data associated with the specific account.\\n     * @param listingIndex The set of listing IDs.\\n     */\\n    struct AssetInfo {\\n        EnumerableSetUpgradeable.UintSet listingIndex;\\n    }\\n\\n    /**\\n     * @dev Listing registry.\\n     * @param idTracker Listing ID tracker (incremental counter).\\n     * @param strategyRegistry Listing strategy registry contract.\\n     * @param listingIndex The global set of registered listing IDs.\\n     * @param listings Mapping from listing ID to the listing info.\\n     * @param listers Mapping from lister address to the lister info.\\n     */\\n    struct Registry {\\n        CountersUpgradeable.Counter idTracker;\\n        IListingStrategyRegistry strategyRegistry;\\n        EnumerableSetUpgradeable.UintSet listingIndex;\\n        mapping(uint256 => Listing) listings;\\n        mapping(address => ListerInfo) listers;\\n        mapping(address => AssetInfo) assets;\\n    }\\n\\n    /**\\n     * @dev Registers new listing.\\n     * @return listingId New listing ID.\\n     */\\n    function register(Registry storage self, Listing memory listing) external returns (uint256 listingId) {\\n        // Generate new listing ID.\\n        self.idTracker.increment();\\n        listingId = self.idTracker.current();\\n        // Store new listing record.\\n        self.listings[listingId] = listing;\\n        // Add new listing ID to the global index.\\n        self.listingIndex.add(listingId);\\n        // Add user listing data.\\n        self.listers[listing.lister].listingIndex.add(listingId);\\n        // Add asset listing data.\\n        self.assets[listing.asset.token()].listingIndex.add(listingId);\\n    }\\n\\n    /**\\n     * @dev Removes listing data.\\n     * @param listingId The ID of the listing to be deleted.\\n     */\\n    function remove(Registry storage self, uint256 listingId) external {\\n        address lister = self.listings[listingId].lister;\\n        address original = self.listings[listingId].asset.token();\\n\\n        // Remove the listing ID from the global index.\\n        self.listingIndex.remove(listingId);\\n        // Remove user listing data.\\n        self.listers[lister].listingIndex.remove(listingId);\\n        // Delete asset.\\n        self.assets[original].listingIndex.remove(listingId);\\n        // Delete listing.\\n        delete self.listings[listingId];\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings.\\n     */\\n    function allListings(\\n        Registry storage self,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Listing[] memory) {\\n        return self.paginateIndexedListings(self.listingIndex, offset, limit);\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings for the particular lister account.\\n     */\\n    function userListings(\\n        Registry storage self,\\n        address lister,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Listing[] memory) {\\n        return self.paginateIndexedListings(self.listers[lister].listingIndex, offset, limit);\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings for the original asset.\\n     */\\n    function assetListings(\\n        Registry storage self,\\n        address original,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Listing[] memory) {\\n        return self.paginateIndexedListings(self.assets[original].listingIndex, offset, limit);\\n    }\\n\\n    /**\\n     * @dev Reverts if listing has not been registered.\\n     * @param listingId Listing ID.\\n     */\\n    function checkRegisteredListing(Registry storage self, uint256 listingId) external view {\\n        if (!self.isRegisteredListing(listingId)) revert ListingIsNotRegistered(listingId);\\n    }\\n\\n    /**\\n     * @dev Checks listing registration by ID.\\n     * @param listingId Listing ID.\\n     */\\n    function isRegisteredListing(Registry storage self, uint256 listingId) internal view returns (bool) {\\n        return self.listings[listingId].lister != address(0);\\n    }\\n\\n    /**\\n     * @dev Reverts if listing strategy is not supported.\\n     * @param strategyId Listing strategy ID.\\n     */\\n    function checkSupportedListingStrategy(Registry storage self, bytes4 strategyId) internal view {\\n        if (!self.strategyRegistry.isRegisteredListingStrategy(strategyId))\\n            revert UnsupportedListingStrategy(strategyId);\\n    }\\n\\n    /**\\n     * @dev Returns listing controller for strategy.\\n     * @param strategyId Listing strategy ID.\\n     */\\n    function listingController(Registry storage self, bytes4 strategyId) internal view returns (IListingController) {\\n        return IListingController(self.strategyRegistry.listingController(strategyId));\\n    }\\n\\n    /**\\n     * @dev Reverts if listing is not registered or has been already delisted.\\n     * @param listingId Listing ID.\\n     */\\n    function checkListed(Registry storage self, uint256 listingId) internal view {\\n        if (!self.listings[listingId].listed()) revert NotListed(listingId);\\n    }\\n\\n    /**\\n     * @dev Returns the number of currently registered listings.\\n     */\\n    function listingCount(Registry storage self) internal view returns (uint256) {\\n        return self.listingIndex.length();\\n    }\\n\\n    /**\\n     * @dev Returns the number of currently registered listings for a particular lister account.\\n     */\\n    function userListingCount(Registry storage self, address lister) internal view returns (uint256) {\\n        return self.listers[lister].listingIndex.length();\\n    }\\n\\n    /**\\n     * @dev Returns the number of currently registered listings for a particular original asset.\\n     */\\n    function assetListingCount(Registry storage self, address original) internal view returns (uint256) {\\n        return self.assets[original].listingIndex.length();\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listing using provided index reference.\\n     */\\n    function paginateIndexedListings(\\n        Registry storage self,\\n        EnumerableSetUpgradeable.UintSet storage listingIndex,\\n        uint256 offset,\\n        uint256 limit\\n    ) internal view returns (uint256[] memory, Listing[] memory) {\\n        uint256 indexSize = listingIndex.length();\\n        if (offset >= indexSize) return (new uint256[](0), new Listing[](0));\\n\\n        if (limit > indexSize - offset) {\\n            limit = indexSize - offset;\\n        }\\n\\n        Listing[] memory listings = new Listing[](limit);\\n        uint256[] memory listingIds = new uint256[](limit);\\n        for (uint256 i = 0; i < limit; i++) {\\n            listingIds[i] = listingIndex.at(offset + i);\\n            listings[i] = self.listings[listingIds[i]];\\n        }\\n\\n        return (listingIds, listings);\\n    }\\n}\\n\",\"keccak256\":\"0x322ee8d21f215d2472af49b40067a82400ae54091b836996c0686cf9d72ad174\",\"license\":\"MIT\"},\"contracts/metahub/IMetahub.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable no-empty-blocks\\npragma solidity 0.8.13;\\n\\nimport \\\"../accounting/IPaymentManager.sol\\\";\\nimport \\\"../warper/IWarperManager.sol\\\";\\nimport \\\"../listing/IListingManager.sol\\\";\\nimport \\\"../renting/IRentingManager.sol\\\";\\nimport \\\"./IProtocolConfigManager.sol\\\";\\n\\ninterface IMetahub is IProtocolConfigManager, IPaymentManager, IWarperManager, IListingManager, IRentingManager {}\\n\",\"keccak256\":\"0xd484d44fde04328ad02bc49d76af63315cc853982b781280603f8005f54e9e32\",\"license\":\"MIT\"},\"contracts/metahub/IProtocolConfigManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./Protocol.sol\\\";\\n\\ninterface IProtocolConfigManager {\\n    /**\\n     * @dev Emitted when a protocol rental fee is changed.\\n     * @param rentalFeePercent New protocol rental fee percentage.\\n     */\\n    event ProtocolRentalFeeChanged(uint16 rentalFeePercent);\\n\\n    /**\\n     * @dev Updates the protocol rental fee percentage.\\n     * @param rentalFeePercent New protocol rental fee percentage.\\n     */\\n    function setProtocolRentalFeePercent(uint16 rentalFeePercent) external;\\n\\n    /**\\n     * @dev Returns the protocol rental fee percentage.\\n     * @return protocol fee percent.\\n     */\\n    function protocolRentalFeePercent() external view returns (uint16);\\n\\n    /**\\n     * @dev Returns the base token that's used for stable price denomination.\\n     * @return The base token address.\\n     */\\n    function baseToken() external view returns (address);\\n}\\n\",\"keccak256\":\"0x703a6341f6e2ff48191c236cef34538cd53c07ce6cad01ed22aa795a2ab75d42\",\"license\":\"MIT\"},\"contracts/metahub/Protocol.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nlibrary Protocol {\\n    /**\\n     * @dev Thrown when the provided token does not match with the configured base token.\\n     */\\n    error BaseTokenMismatch();\\n\\n    /**\\n     * @dev Protocol configuration.\\n     * @param baseToken ERC20 contract. Used as the price denominator.\\n     * @param rentalFeePercent The fixed part of the total rental fee paid to protocol.\\n     */\\n    struct Config {\\n        IERC20Upgradeable baseToken;\\n        uint16 rentalFeePercent;\\n    }\\n\\n    /**\\n     * @dev Reverts if the `token` does not match the base one.\\n     */\\n    function checkBaseToken(Config storage self, address token) internal view {\\n        if (token != address(self.baseToken)) revert BaseTokenMismatch();\\n    }\\n}\\n\",\"keccak256\":\"0xc1af6f1b39d9f846aa6cc58f01c24957439b43be00ec7a2c0d3b720f9917f278\",\"license\":\"MIT\"},\"contracts/renting/IRentingManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./Rentings.sol\\\";\\n\\ninterface IRentingManager {\\n    /**\\n     * @dev Thrown when the message sender doesn't match the renter address.\\n     */\\n    error CallerIsNotRenter();\\n\\n    /**\\n     * @dev Emitted when the warped asset is rented.\\n     * @param rentalId Rental agreement ID.\\n     * @param renter The renter account address.\\n     * @param listingId The corresponding ID of the original asset listing.\\n     * @param warpedAsset Rented warped asset.\\n     * @param startTime The rental agreement staring time.\\n     * @param endTime The rental agreement ending time.\\n     */\\n    event AssetRented(\\n        uint256 indexed rentalId,\\n        address indexed renter,\\n        uint256 indexed listingId,\\n        Assets.Asset warpedAsset,\\n        uint32 startTime,\\n        uint32 endTime\\n    );\\n\\n    /**\\n     * @dev Returns token amount from specific collection rented by particular account.\\n     * @param warpedCollectionId Warped collection ID.\\n     * @param renter The renter account address.\\n     * @return Rented value.\\n     */\\n    function collectionRentedValue(bytes32 warpedCollectionId, address renter) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the rental status of a given warped asset.\\n     * @param warpedAssetId Warped asset ID.\\n     * @return The asset rental status.\\n     */\\n    function assetRentalStatus(Assets.AssetId calldata warpedAssetId) external view returns (Rentings.RentalStatus);\\n\\n    /**\\n     * @dev Evaluates renting params and returns rental fee breakdown.\\n     * @param rentingParams Renting parameters.\\n     * @return Rental fee breakdown.\\n     */\\n    function estimateRent(Rentings.Params calldata rentingParams) external view returns (Rentings.RentalFees memory);\\n\\n    /**\\n     * @dev Performs renting operation.\\n     * @param rentingParams Renting parameters.\\n     * @param maxPaymentAmount Maximal payment amount the renter is willing to pay.\\n     * @return New rental ID.\\n     */\\n    function rent(Rentings.Params calldata rentingParams, uint256 maxPaymentAmount) external returns (uint256);\\n\\n    /**\\n     * @dev Returns the rental agreement details.\\n     * @param rentalId Rental agreement ID.\\n     * @return Rental agreement details.\\n     */\\n    function rentalAgreementInfo(uint256 rentalId) external view returns (Rentings.Agreement memory);\\n\\n    /**\\n     * @dev Returns the number of currently registered rental agreements for particular renter account.\\n     * @param renter Renter address.\\n     * @return Rental agreement count.\\n     */\\n    function userRentalCount(address renter) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered rental agreements for particular renter account.\\n     * @param renter Renter address.\\n     * @param offset Starting index.\\n     * @param limit Max number of items.\\n     * @return Rental agreement IDs.\\n     * @return Rental agreements.\\n     */\\n    function userRentalAgreements(\\n        address renter,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Rentings.Agreement[] memory);\\n}\\n\",\"keccak256\":\"0x0fcba4f7561d476ad59b35f69795e8b331f9c228195c92bf7abcce3ee39b1759\",\"license\":\"MIT\"},\"contracts/renting/Rentings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"../asset/Assets.sol\\\";\\nimport \\\"../metahub/Protocol.sol\\\";\\nimport \\\"../listing/Listings.sol\\\";\\nimport \\\"../warper/Warpers.sol\\\";\\nimport \\\"../universe/IUniverseRegistry.sol\\\";\\n\\nlibrary Rentings {\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\\n    using Rentings for RenterInfo;\\n    using Rentings for Agreement;\\n    using Rentings for Registry;\\n    using Assets for Assets.AssetId;\\n    using Protocol for Protocol.Config;\\n    using Listings for Listings.Registry;\\n    using Listings for Listings.Listing;\\n    using Warpers for Warpers.Registry;\\n    using Warpers for Warpers.Warper;\\n\\n    /**\\n     * @dev Thrown when a rental agreement is being registered for a specific warper ID,\\n     * while the previous rental agreement for this warper is still effective.\\n     */\\n    error RentalAgreementConflict(uint256 conflictingRentalId);\\n\\n    /**\\n     * @dev Thrown when attempting to delete effective rental agreement data (before expiration).\\n     */\\n    error CannotDeleteEffectiveRentalAgreement(uint256 rentalId);\\n\\n    /**\\n     * @dev Warper rental status.\\n     * NONE - means the warper had never been minted.\\n     * AVAILABLE - can be rented.\\n     * RENTED - currently rented.\\n     */\\n    enum RentalStatus {\\n        NONE,\\n        AVAILABLE,\\n        RENTED\\n    }\\n\\n    /**\\n     * @dev Defines the maximal allowed number of cycles when looking for expired rental agreements.\\n     */\\n    uint256 private constant _GC_CYCLES = 20;\\n\\n    /**\\n     * @dev Rental fee breakdown.\\n     */\\n    struct RentalFees {\\n        uint256 total;\\n        uint256 protocolFee;\\n        uint256 listerBaseFee;\\n        uint256 listerPremium;\\n        uint256 universeBaseFee;\\n        uint256 universePremium;\\n    }\\n\\n    /**\\n     * @dev Renting parameters structure.\\n     * It is used to encode all the necessary information to estimate and/or fulfill a particular renting request.\\n     * @param listingId Listing ID. Also allows to identify the asset being rented.\\n     * @param warper Warper address.\\n     * @param renter Renter address.\\n     * @param rentalPeriod Desired period of asset renting.\\n     * @param paymentToken The token address which renter offers as a mean of payment.\\n     */\\n    struct Params {\\n        uint256 listingId;\\n        address warper;\\n        address renter;\\n        uint32 rentalPeriod;\\n        address paymentToken;\\n    }\\n\\n    /**\\n     * @dev Rental agreement information.\\n     * @param warpedAsset Rented asset.\\n     * @param collectionId Warped collection ID.\\n     * @param listingId The corresponding ID of the original asset listing.\\n     * @param renter The renter account address.\\n     * @param startTime The rental agreement staring time. This is the timestamp after which the `renter`\\n     * considered to be an warped asset owner.\\n     * @param endTime The rental agreement ending time. After this timestamp, the rental agreement is terminated\\n     * and the `renter` is no longer the owner of the warped asset.\\n     */\\n    struct Agreement {\\n        Assets.Asset warpedAsset;\\n        bytes32 collectionId;\\n        uint256 listingId;\\n        address renter;\\n        uint32 startTime;\\n        uint32 endTime;\\n    }\\n\\n    function isEffective(Agreement storage self) internal view returns (bool) {\\n        return self.endTime > uint32(block.timestamp);\\n    }\\n\\n    function duration(Agreement memory self) internal pure returns (uint32) {\\n        return self.endTime - self.startTime;\\n    }\\n\\n    /**\\n     * @dev Describes user specific renting information.\\n     * @param rentalIndex Renter's set of rental agreement IDs.\\n     * @param collectionRentalIndex Mapping from collection ID to the set of rental IDs.\\n     */\\n    struct RenterInfo {\\n        EnumerableSetUpgradeable.UintSet rentalIndex;\\n        mapping(bytes32 => EnumerableSetUpgradeable.UintSet) collectionRentalIndex;\\n    }\\n\\n    /**\\n     * @dev Describes asset specific renting information.\\n     * @param latestRentalId Holds the most recent rental agreement ID.\\n     */\\n    struct AssetInfo {\\n        uint256 latestRentalId; // NOTE: This must never be deleted during cleanup.\\n    }\\n\\n    /**\\n     * @dev Renting registry.\\n     * @param idTracker Rental agreement ID tracker (incremental counter).\\n     * @param agreements Mapping from rental ID to the rental agreement details.\\n     * @param renters Mapping from renter address to the user specific renting info.\\n     * @param assets Mapping from asset ID (byte32) to the asset specific renting info.\\n     */\\n    struct Registry {\\n        CountersUpgradeable.Counter idTracker;\\n        mapping(uint256 => Agreement) agreements;\\n        mapping(address => RenterInfo) renters;\\n        mapping(bytes32 => AssetInfo) assets;\\n    }\\n\\n    /**\\n     * @dev Returns the number of currently registered rental agreements for particular renter account.\\n     */\\n    function userRentalCount(Registry storage self, address renter) internal view returns (uint256) {\\n        return self.renters[renter].rentalIndex.length();\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered rental agreements for particular renter account.\\n     */\\n    function userRentalAgreements(\\n        Registry storage self,\\n        address renter,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Rentings.Agreement[] memory) {\\n        EnumerableSetUpgradeable.UintSet storage userRentalIndex = self.renters[renter].rentalIndex;\\n        uint256 indexSize = userRentalIndex.length();\\n        if (offset >= indexSize) return (new uint256[](0), new Rentings.Agreement[](0));\\n\\n        if (limit > indexSize - offset) {\\n            limit = indexSize - offset;\\n        }\\n\\n        Rentings.Agreement[] memory agreements = new Rentings.Agreement[](limit);\\n        uint256[] memory rentalIds = new uint256[](limit);\\n        for (uint256 i = 0; i < limit; i++) {\\n            rentalIds[i] = userRentalIndex.at(offset + i);\\n            agreements[i] = self.agreements[rentalIds[i]];\\n        }\\n\\n        return (rentalIds, agreements);\\n    }\\n\\n    /**\\n     * @dev Finds expired user rental agreements associated with `collectionId` and deletes them.\\n     * Deletes only first N entries defined by `toBeRemoved` param.\\n     * The total number of cycles is capped by GC_CYCLES constant.\\n     */\\n    function deleteExpiredUserRentalAgreements(\\n        Registry storage self,\\n        address renter,\\n        bytes32 collectionId,\\n        uint256 toBeRemoved\\n    ) external {\\n        EnumerableSetUpgradeable.UintSet storage rentalIndex = self.renters[renter].collectionRentalIndex[collectionId];\\n        uint256 rentalCount = rentalIndex.length();\\n        if (rentalCount == 0 || toBeRemoved == 0) return;\\n\\n        uint256 maxCycles = rentalCount < _GC_CYCLES ? rentalCount : _GC_CYCLES;\\n        uint256 removed = 0;\\n\\n        for (uint256 i = 0; i < maxCycles; i++) {\\n            uint256 rentalId = rentalIndex.at(i);\\n\\n            if (!self.agreements[rentalId].isEffective()) {\\n                // Warning: we are iterating an array that we are also modifying!\\n                _removeRentalAgreement(self, rentalId);\\n                removed += 1;\\n                maxCycles -= 1; // This is so we account for reduced `rentalCount`.\\n\\n                // Stop iterating if we have cleaned up enough desired items.\\n                if (removed == toBeRemoved) break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs new rental agreement registration.\\n     */\\n    function register(Registry storage self, Agreement memory agreement) external returns (uint256 rentalId) {\\n        // Make sure the there is no active rentals for the warper ID.\\n        bytes32 assetId = agreement.warpedAsset.id.hash();\\n        uint256 latestRentalId = self.assets[assetId].latestRentalId;\\n        if (latestRentalId != 0 && self.agreements[latestRentalId].isEffective()) {\\n            revert RentalAgreementConflict(latestRentalId);\\n        }\\n\\n        // Generate new rental ID.\\n        self.idTracker.increment();\\n        rentalId = self.idTracker.current();\\n\\n        // Save new rental agreement.\\n        self.agreements[rentalId] = agreement;\\n\\n        // Update warper latest rental ID.\\n        self.assets[assetId].latestRentalId = rentalId;\\n\\n        // Update user rental data.\\n        self.renters[agreement.renter].rentalIndex.add(rentalId);\\n        self.renters[agreement.renter].collectionRentalIndex[agreement.collectionId].add(rentalId);\\n    }\\n\\n    /**\\n     * @dev Safely removes expired rental data from the registry.\\n     */\\n    function removeExpiredRentalAgreement(Registry storage self, uint256 rentalId) external {\\n        if (self.agreements[rentalId].isEffective()) revert CannotDeleteEffectiveRentalAgreement(rentalId);\\n        _removeRentalAgreement(self, rentalId);\\n    }\\n\\n    /**\\n     * @dev Removes rental data from the registry.\\n     */\\n    function _removeRentalAgreement(Registry storage self, uint256 rentalId) private {\\n        address renter = self.agreements[rentalId].renter;\\n        bytes32 collectionId = self.agreements[rentalId].collectionId;\\n\\n        // Remove user rental data.\\n        self.renters[renter].rentalIndex.remove(rentalId);\\n        self.renters[renter].collectionRentalIndex[collectionId].remove(rentalId);\\n\\n        // Delete rental agreement.\\n        delete self.agreements[rentalId];\\n    }\\n\\n    /**\\n     * @dev Finds all effective rental agreements from specific collection.\\n     * Returns the total value rented by `renter`.\\n     */\\n    function collectionRentedValue(\\n        Registry storage self,\\n        address renter,\\n        bytes32 collectionId\\n    ) external view returns (uint256 value) {\\n        EnumerableSetUpgradeable.UintSet storage rentalIndex = self.renters[renter].collectionRentalIndex[collectionId];\\n        uint256 length = rentalIndex.length();\\n        for (uint256 i = 0; i < length; i++) {\\n            Agreement storage agreement = self.agreements[rentalIndex.at(i)];\\n            if (agreement.isEffective()) {\\n                value += agreement.warpedAsset.value;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns asset rental status based on latest rental agreement.\\n     */\\n    function assetRentalStatus(Registry storage self, Assets.AssetId memory assetId)\\n        external\\n        view\\n        returns (RentalStatus)\\n    {\\n        uint256 latestRentalId = self.assets[assetId.hash()].latestRentalId;\\n        if (latestRentalId == 0) return RentalStatus.NONE;\\n\\n        return self.agreements[latestRentalId].isEffective() ? RentalStatus.RENTED : RentalStatus.AVAILABLE;\\n    }\\n\\n    /**\\n     * @dev Main renting request validation function.\\n     */\\n    function validateRentingParams(\\n        Params calldata params,\\n        Protocol.Config storage protocolConfig,\\n        Listings.Registry storage listingRegistry,\\n        Warpers.Registry storage warperRegistry\\n    ) external view {\\n        // Validate from the protocol perspective.\\n        protocolConfig.checkBaseToken(params.paymentToken);\\n\\n        // Validate from the listing perspective.\\n        listingRegistry.checkListed(params.listingId);\\n        Listings.Listing storage listing = listingRegistry.listings[params.listingId];\\n        listing.checkNotPaused();\\n        listing.checkValidLockPeriod(params.rentalPeriod);\\n\\n        // Validate from the warper perspective.\\n        warperRegistry.checkRegisteredWarper(params.warper);\\n        Warpers.Warper storage warper = warperRegistry.warpers[params.warper];\\n        warper.checkCompatibleAsset(listing.asset);\\n        warper.checkNotPaused();\\n        warper.controller.validateRentingParams(listing.asset, params);\\n    }\\n\\n    /**\\n     * @dev Performs rental fee calculation and returns the fee breakdown.\\n     */\\n    function calculateRentalFees(\\n        Params calldata rentingParams,\\n        Protocol.Config storage protocolConfig,\\n        Listings.Registry storage listingRegistry,\\n        Warpers.Registry storage warperRegistry,\\n        IUniverseRegistry universeRegistry\\n    ) external view returns (RentalFees memory fees) {\\n        // Calculate lister base fee.\\n        Listings.Listing storage listing = listingRegistry.listings[rentingParams.listingId];\\n        Listings.Params memory listingParams = listing.params;\\n        // Resolve listing controller to calculate lister fee based on selected listing strategy.\\n        IListingController listingController = listingRegistry.listingController(listingParams.strategy);\\n        fees.listerBaseFee = listingController.calculateRentalFee(listingParams, rentingParams);\\n\\n        // Calculate universe base fee.\\n        Warpers.Warper storage warper = warperRegistry.warpers[rentingParams.warper];\\n        uint16 universeRentalFeePercent = universeRegistry.universeRentalFeePercent(warper.universeId);\\n        fees.universeBaseFee = (fees.listerBaseFee * universeRentalFeePercent) / 10_000;\\n\\n        // Calculate protocol fee.\\n        fees.protocolFee = (fees.listerBaseFee * protocolConfig.rentalFeePercent) / 10_000;\\n\\n        // Calculate warper premiums.\\n        (uint256 universePremium, uint256 listerPremium) = warper.controller.calculatePremiums(\\n            listing.asset,\\n            rentingParams,\\n            fees.universeBaseFee,\\n            fees.listerBaseFee\\n        );\\n        fees.listerPremium = listerPremium;\\n        fees.universePremium = universePremium;\\n\\n        // Calculate TOTAL rental fee.\\n        fees.total += fees.listerBaseFee + listerPremium;\\n        fees.total += fees.universeBaseFee + universePremium;\\n        fees.total += fees.protocolFee;\\n    }\\n}\\n\",\"keccak256\":\"0x7e9dd37e7eb41e22a2fbe4d0fc0edd63e7d2fc2bd37f22160470c639d48d7296\",\"license\":\"MIT\"},\"contracts/universe/IUniverseRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IUniverseRegistry {\\n    /**\\n     * @dev Thrown when a check is made where the given account must also be the universe owner.\\n     */\\n    error AccountIsNotUniverseOwner(address account);\\n\\n    /**\\n     * @dev Thrown when a the supplied universe name is empty.\\n     */\\n    error EmptyUniverseName();\\n\\n    /**\\n     * @dev Thrown when trying to read universe data for a universe is not registered.\\n     */\\n    error QueryForNonexistentUniverse(uint256 universeId);\\n\\n    /**\\n     * @dev Emitted when a universe is created.\\n     * @param universeId Universe ID.\\n     * @param name Universe name.\\n     */\\n    event UniverseCreated(uint256 indexed universeId, string name);\\n\\n    /**\\n     * @dev Emitted when a universe name is changed.\\n     * @param universeId Universe ID.\\n     * @param name The newly set name.\\n     */\\n    event UniverseNameChanged(uint256 indexed universeId, string name);\\n\\n    /**\\n     * @dev Emitted when universe rental fee is changed.\\n     * @param universeId Universe ID.\\n     * @param rentalFeePercent The newly rental fee.\\n     */\\n    event UniverseRentalFeeChanged(uint256 indexed universeId, uint16 rentalFeePercent);\\n\\n    /**\\n     * @dev Updates the universe token base URI.\\n     * @param baseURI New base URI. Must include a trailing slash (\\\"/\\\").\\n     */\\n    function setUniverseTokenBaseURI(string calldata baseURI) external;\\n\\n    /**\\n     * @dev The universe properties & initial configuration params.\\n     * @param name The universe name.\\n     * @param rentalFeePercent The base percentage of the rental fee which the universe charges for using its warpers.\\n     */\\n    struct UniverseParams {\\n        string name;\\n        uint16 rentalFeePercent;\\n    }\\n\\n    /**\\n     * @dev Creates new Universe. This includes minting new universe NFT,\\n     * where the caller of this method becomes the universe owner.\\n     * @param params The universe properties & initial configuration params.\\n     * @return Universe ID (universe token ID).\\n     */\\n    function createUniverse(UniverseParams calldata params) external returns (uint256);\\n\\n    /**\\n     * @dev Update the universe name.\\n     * @param universeId The unique identifier for the universe.\\n     * @param universeName The universe name to set.\\n     */\\n    function setUniverseName(uint256 universeId, string memory universeName) external;\\n\\n    /**\\n     * @dev Update the universe rental fee percent.\\n     * @param universeId The unique identifier for the universe.\\n     * @param rentalFeePercent The universe rental fee percent.\\n     */\\n    function setUniverseRentalFeePercent(uint256 universeId, uint16 rentalFeePercent) external;\\n\\n    /**\\n     * @dev Returns Universe owner address.\\n     * @param universeId Universe ID.\\n     * @return Universe owner.\\n     */\\n    function universeOwner(uint256 universeId) external view returns (address);\\n\\n    /**\\n     * @dev Returns Universe rental fee percent.\\n     * @param universeId Universe ID.\\n     * @return universe fee percent.\\n     */\\n    function universeRentalFeePercent(uint256 universeId) external view returns (uint16);\\n\\n    /**\\n     * @dev Returns name.\\n     * @param universeId Universe ID.\\n     * @return universe name.\\n     */\\n    function universeName(uint256 universeId) external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Universe token address.\\n     */\\n    function universeToken() external view returns (address);\\n\\n    /**\\n     * @dev Returns the Universe token base URI.\\n     */\\n    function universeTokenBaseURI() external view returns (string memory);\\n\\n    /**\\n     * @dev Aggregate and return Universe data.\\n     * @param universeId Universe-specific ID.\\n     * @return name The name of the universe.\\n     * @param rentalFeePercent The base percentage of the rental fee which the universe charges for using its warpers.\\n     */\\n    function universe(uint256 universeId) external view returns (string memory name, uint16 rentalFeePercent);\\n\\n    /**\\n     * @dev Reverts if the universe owner is not the provided account address.\\n     * @param universeId Universe ID.\\n     * @param account The address of the expected owner.\\n     */\\n    function checkUniverseOwner(uint256 universeId, address account) external view;\\n\\n    /**\\n     * @dev Returns `true` if the universe owner is the supplied account address.\\n     * @param universeId Universe ID.\\n     * @param account The address of the expected owner.\\n     */\\n    function isUniverseOwner(uint256 universeId, address account) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x1f45f0c2617fcd93577ca148c6bdbff8b493219a54646e84709154b73c0f16c2\",\"license\":\"MIT\"},\"contracts/warper/ERC721/ERC721Warper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721Receiver.sol\\\";\\nimport \\\"../../metahub/IMetahub.sol\\\";\\nimport \\\"../../renting/Rentings.sol\\\";\\nimport \\\"../Warper.sol\\\";\\nimport \\\"./IERC721Warper.sol\\\";\\nimport \\\"./IERC721WarperController.sol\\\";\\n\\n/**\\n * @title Warper for the ERC721 token contract\\n */\\ncontract ERC721Warper is IERC721Warper, Warper {\\n    using ERC165Checker for address;\\n    using Address for address;\\n\\n    /**\\n     * @dev Mapping from token ID to owner address\\n     */\\n    mapping(uint256 => address) private _owners;\\n\\n    /**\\n     * @inheritdoc IWarper\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    function __assetClass() external pure returns (bytes4) {\\n        return Assets.ERC721;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     * @dev Method is disabled, kept only for interface compatibility purposes.\\n     */\\n    function setApprovalForAll(address, bool) public virtual override {\\n        revert MethodNotAllowed();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     * @dev Method is disabled, kept only for interface compatibility purposes.\\n     */\\n    function approve(address, uint256) public virtual override {\\n        revert MethodNotAllowed();\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - needs to pass validation of `_beforeTokenTransfer()`.\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received},\\n     * which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function mint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public {\\n        if (to == address(0)) revert MintToTheZeroAddress();\\n        if (_exists(tokenId)) revert TokenIsAlreadyMinted(tokenId);\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        if (!_checkOnERC721Received(address(0), to, tokenId, data)) {\\n            revert TransferToNonERC721ReceiverImplementer(to);\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     *\\n     * @dev Need to fulfill all the requirements of `_transfer()`\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     *\\n     * @dev Need to fulfill all the requirements of `_transfer()`\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     *\\n     * @dev Need to fulfill all the requirements of `_transfer()`\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public virtual override {\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(Warper, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721Warper).interfaceId ||\\n            interfaceId == type(IERC721).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     * @dev The rental count calculations get offloaded to the Metahub\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        IERC721WarperController warperController = _warperController();\\n        return warperController.rentalBalance(_metahub(), address(this), owner);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     * @dev The ownership is dependant on the rental status - metahub is\\n     *      responsible for tracking the state:\\n     *          - NONE: revert with an error\\n     *          - AVAILABLE: means, that the token is not currently rented. Metahub is the owner.\\n     *          - RENTED: Use the Warpers internal ownership constructs\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        // Special rent-sate handling\\n        {\\n            IERC721WarperController warperController = _warperController();\\n            Rentings.RentalStatus rentalStatus = warperController.rentalStatus(_metahub(), address(this), tokenId);\\n\\n            if (rentalStatus == Rentings.RentalStatus.NONE) revert OwnerQueryForNonexistentToken(tokenId);\\n            if (rentalStatus == Rentings.RentalStatus.AVAILABLE) return _metahub();\\n        }\\n\\n        // `rentalStatus` is now RENTED\\n        // Fallback to using the internal owner tracker\\n        address owner = _owners[tokenId];\\n        if (owner == address(0)) revert OwnerQueryForNonexistentToken(tokenId);\\n\\n        return owner;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     * @dev Method is disabled, kept only for interface compatibility purposes.\\n     */\\n    function getApproved(uint256) public view virtual override returns (address) {\\n        revert MethodNotAllowed();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     * @dev Method is disabled, kept only for interface compatibility purposes.\\n     */\\n    function isApprovedForAll(address, address) public view virtual override returns (bool) {\\n        revert MethodNotAllowed();\\n    }\\n\\n    /**\\n     * @dev Validates the original NFT.\\n     */\\n    function _validateOriginal(address original) internal virtual override {\\n        if (!original.supportsInterface(type(IERC721Metadata).interfaceId)) {\\n            revert InvalidOriginalTokenInterface(original, type(IERC721Metadata).interfaceId);\\n        }\\n        super._validateOriginal(original);\\n    }\\n\\n    /**\\n     * @dev ONLY THE METAHUB CAN CALL THIS METHOD.\\n     *      This validates every single transfer that the warper can perform.\\n     *      Metahub can be the only source of transfers, so it can properly synchronise\\n     *      the rental agreement ownership.\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual onlyMetahub {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - Needs to fulfill all the requirements of `_transfer()`\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received},\\n     * which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        if (!_checkOnERC721Received(from, to, tokenId, data)) {\\n            revert TransferToNonERC721ReceiverImplementer(to);\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - needs to pass validation of `_beforeTokenTransfer()`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        if (!_exists(tokenId)) revert OperatorQueryForNonexistentToken(tokenId);\\n        if (to == address(0)) revert TransferToTheZeroAddress();\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Get the associated warper controller.\\n     */\\n    function _warperController() internal view returns (IERC721WarperController) {\\n        return IERC721WarperController(IWarperManager(_metahub()).warperController(address(this)));\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (!to.isContract()) return true;\\n\\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 result) {\\n            return result == IERC721Receiver.onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer(to);\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb12a3fd52759811f1528b334bf570fc71571d4a6e5c534991f80755234785e27\",\"license\":\"MIT\"},\"contracts/warper/ERC721/IERC721Warper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721.sol\\\";\\nimport \\\"../IWarper.sol\\\";\\n\\ninterface IERC721Warper is IWarper, IERC721 {\\n    //TODO: Docs\\n    error BalanceQueryForZeroAddress();\\n    error OwnerQueryForNonexistentToken(uint256 tokenId);\\n    error OperatorQueryForNonexistentToken(uint256 tokenId);\\n    error TransferToNonERC721ReceiverImplementer(address to);\\n    error MintToTheZeroAddress();\\n    error TokenIsAlreadyMinted(uint256 tokenId);\\n    error TransferToTheZeroAddress();\\n    error MethodNotAllowed();\\n\\n    function mint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xb911fc492bb8f3bdd1e2fe6794a0712f8ac8bf3e2a78373b77eaa4f707d2d021\",\"license\":\"MIT\"},\"contracts/warper/ERC721/IERC721WarperController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"../IWarperController.sol\\\";\\nimport \\\"../../asset/Assets.sol\\\";\\n\\ninterface IERC721WarperController is IWarperController {\\n    /**\\n     * @dev Get the active rental balance for a given warper and a renter.\\n     *      Used in Warper->Metahub communication.\\n     * @param metahub Address of the metahub.\\n     * @param warper Address of the warper.\\n     * @param renter Address of the renter whose active rental counts we need to fetch.\\n     */\\n    function rentalBalance(\\n        address metahub,\\n        address warper,\\n        address renter\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Get the rental status of a specific token.\\n     *      Used in Warper->Metahub communication.\\n     * @param metahub Address of the metahub.\\n     * @param warper Address of the warper.\\n     * @param tokenId The token ID to be checked for status.\\n     */\\n    function rentalStatus(\\n        address metahub,\\n        address warper,\\n        uint256 tokenId\\n    ) external view returns (Rentings.RentalStatus);\\n}\\n\",\"keccak256\":\"0xc8a2d19ea57eb128167dc29b8b48cc750e573a0cf4d8f82499ebc201f48f0ea3\",\"license\":\"MIT\"},\"contracts/warper/ERC721/presets/ERC721PresetConfigurable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable private-vars-leading-underscore\\npragma solidity 0.8.13;\\n\\nimport \\\"../ERC721Warper.sol\\\";\\nimport \\\"../../IWarperPreset.sol\\\";\\nimport \\\"../../mechanics/availability-period/ConfigurableAvailabilityPeriodExtension.sol\\\";\\nimport \\\"../../mechanics/rental-period/ConfigurableRentalPeriodExtension.sol\\\";\\n\\ncontract ERC721PresetConfigurable is\\n    IWarperPreset,\\n    ERC721Warper,\\n    ConfigurableAvailabilityPeriodExtension,\\n    ConfigurableRentalPeriodExtension\\n{\\n    /**\\n     * @inheritdoc IWarperPreset\\n     */\\n    function __initialize(bytes calldata config) external virtual initializer {\\n        // Decode config\\n        (address original, address metahub) = abi.decode(config, (address, address));\\n        _Warper_init(original, metahub);\\n        _ConfigurableAvailabilityPeriodExtension_init();\\n        _ConfigurableRentalPeriodExtension_init();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override(ERC721Warper, ConfigurableAvailabilityPeriodExtension, ConfigurableRentalPeriodExtension, IERC165)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IWarperPreset).interfaceId ||\\n            ERC721Warper.supportsInterface(interfaceId) ||\\n            ConfigurableAvailabilityPeriodExtension.supportsInterface(interfaceId) ||\\n            ConfigurableRentalPeriodExtension.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc ERC721Warper\\n     */\\n    function _validateOriginal(address original) internal virtual override(ERC721Warper, Warper) {\\n        return ERC721Warper._validateOriginal(original);\\n    }\\n}\\n\",\"keccak256\":\"0x2b049afffde67f7510172e12c761d97e35c345211de4b782f3ee3f3a83b86aeb\",\"license\":\"MIT\"},\"contracts/warper/IWarper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable private-vars-leading-underscore\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\n\\ninterface IWarper is IERC165 {\\n    /**\\n     * @dev Returns the original asset address.\\n     */\\n    function __original() external view returns (address);\\n\\n    /**\\n     * @dev Returns the Metahub address.\\n     */\\n    function __metahub() external view returns (address);\\n\\n    /**\\n     * @dev Returns the warper asset class ID.\\n     */\\n    function __assetClass() external view returns (bytes4);\\n\\n    /**\\n     * @dev Validates if a warper supports multiple interfaces at once.\\n     * @return an array of `bool` flags in order as the `interfaceIds` were passed.\\n     */\\n    function __supportedInterfaces(bytes4[] memory interfaceIds) external view returns (bool[] memory);\\n}\\n\",\"keccak256\":\"0xc42dfdd79bef10aa493c477d481b2f3a6d38f553fbffdd808c43d52a8dda28d7\",\"license\":\"MIT\"},\"contracts/warper/IWarperController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"../asset/Assets.sol\\\";\\nimport \\\"../renting/Rentings.sol\\\";\\nimport \\\"../asset/IAssetController.sol\\\";\\nimport \\\"./IWarper.sol\\\";\\n\\ninterface IWarperController is IAssetController {\\n    /**\\n     * @dev Thrown if warper interface is not compatible with the controller.\\n     */\\n    error IncompatibleWarperInterface();\\n\\n    /**\\n     * @dev Thrown upon attempting to use the warper with an asset different from the one expected by the warper.\\n     */\\n    error InvalidAssetForWarper(address warper, address asset);\\n\\n    /**\\n     * @dev Thrown upon attempting to rent a warped asset which is already rented.\\n     */\\n    error AlreadyRented();\\n\\n    /**\\n     * @dev Takes an existing asset and then mints a warper token representing it.\\n     *      Used in Metahub->Warper communication.\\n     * @param asset The asset that must be warped.\\n     * @param warper Warper contract to used for warping.\\n     * @param to The account which will receive the warped asset.\\n     * @return collectionId Warped collection ID.\\n     * @return warpedAsset Warper asset structure.\\n     */\\n    function warp(\\n        Assets.Asset calldata asset,\\n        address warper,\\n        address to\\n    ) external returns (bytes32 collectionId, Assets.Asset memory warpedAsset);\\n\\n    /**\\n     * @dev Validates that the warper interface is supported by the current WarperController.\\n     * @param warper Warper whose interface we must validate.\\n     * @return bool - `true` if warper is supported.\\n     */\\n    function isCompatibleWarper(address warper) external view returns (bool);\\n\\n    /**\\n     * @dev Reverts if provided warper is not compatible with the controller.\\n     */\\n    function checkCompatibleWarper(address warper) external view;\\n\\n    /**\\n     * @dev Validates renting params taking into account various warper mechanics.\\n     * Throws an error if the specified asset cannot be rented with particular renting parameters.\\n     * @param asset Asset being rented.\\n     * @param rentingParams Renting parameters.\\n     */\\n    function validateRentingParams(Assets.Asset calldata asset, Rentings.Params calldata rentingParams) external view;\\n\\n    /**\\n     * @dev Calculates the universe and/or lister premiums.\\n     * Those are extra amounts that should be added the the resulting rental fee paid by renter.\\n     * @param asset Asset being rented.\\n     * @param rentingParams Renting parameters.\\n     * @param universeFee The current value of the universe fee component.\\n     * @param listerFee The current value of the lister fee component.\\n     * @return universePremium The universe premium amount.\\n     * @return listerPremium The lister premium amount.\\n     */\\n    function calculatePremiums(\\n        Assets.Asset calldata asset,\\n        Rentings.Params calldata rentingParams,\\n        uint256 universeFee,\\n        uint256 listerFee\\n    ) external view returns (uint256 universePremium, uint256 listerPremium);\\n}\\n\",\"keccak256\":\"0x7751c32ba6ffda927fea94a97515fc2b7b4a9e9ba67e55b70f9bd1cce775c981\",\"license\":\"MIT\"},\"contracts/warper/IWarperManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"../asset/IAssetController.sol\\\";\\nimport \\\"./Warpers.sol\\\";\\n\\ninterface IWarperManager {\\n    /**\\n     * @dev Thrown if provided warper address does not implement warper interface.\\n     */\\n    error InvalidWarperInterface();\\n\\n    /**\\n     * @dev Thrown when the warper returned metahub address differs from the one it is being registered in.\\n     * @param provided Metahub address returned by warper.\\n     * @param required Required metahub address.\\n     */\\n    error WarperHasIncorrectMetahubReference(address provided, address required);\\n\\n    /**\\n     * @dev Emitted when a new warper is registered.\\n     * @param universeId Universe ID.\\n     * @param warper Warper address.\\n     * @param original Original asset address.\\n     * @param assetClass Asset class ID (identical for the `original` and `warper`).\\n     */\\n    event WarperRegistered(\\n        uint256 indexed universeId,\\n        address indexed warper,\\n        address indexed original,\\n        bytes4 assetClass\\n    );\\n\\n    /**\\n     * @dev Emitted when the warper is no longer registered.\\n     * @param warper Warper address.\\n     */\\n    event WarperDeregistered(address indexed warper);\\n\\n    /**\\n     * @dev Emitted when the warper is paused.\\n     * @param warper Address.\\n     */\\n    event WarperPaused(address indexed warper);\\n\\n    /**\\n     * @dev Emitted when the warper pause is lifted.\\n     * @param warper Address.\\n     */\\n    event WarperUnpaused(address indexed warper);\\n\\n    /**\\n     * @dev Warper registration params.\\n     * @param name The warper name.\\n     * @param universeId The universe ID.\\n     * @param paused Indicates whether the warper should stay paused after registration.\\n     */\\n    struct WarperRegistrationParams {\\n        string name;\\n        uint256 universeId;\\n        bool paused;\\n    }\\n\\n    /**\\n     * @dev Registers a new warper.\\n     * The warper must be deployed and configured prior to registration,\\n     * since it becomes available for renting immediately.\\n     * @param warper Warper address.\\n     * @param params Warper registration params.\\n     */\\n    function registerWarper(address warper, WarperRegistrationParams calldata params) external;\\n\\n    /**\\n     * @dev Deletes warper registration information.\\n     * All current rental agreements with the warper will stay intact, but the new rentals won't be possible.\\n     * @param warper Warper address.\\n     */\\n    function deregisterWarper(address warper) external;\\n\\n    /**\\n     * @dev Returns the number of warpers belonging to the particular universe.\\n     * @param universeId The universe ID.\\n     * @return Warper count.\\n     */\\n    function universeWarperCount(uint256 universeId) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the list of warpers belonging to the particular universe.\\n     * @param universeId The universe ID.\\n     * @param offset Starting index.\\n     * @param limit Max number of items.\\n     * @return List of warper addresses.\\n     * @return List of warpers.\\n     */\\n    function universeWarpers(\\n        uint256 universeId,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory, Warpers.Warper[] memory);\\n\\n    /**\\n     * @dev Returns the number of warpers associated with the particular original asset.\\n     * @param original Original asset address.\\n     * @return Warper count.\\n     */\\n    function assetWarperCount(address original) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the list of warpers associated with the particular original asset.\\n     * @param original Original asset address.\\n     * @param offset Starting index.\\n     * @param limit Max number of items.\\n     * @return List of warper addresses.\\n     * @return List of warpers.\\n     */\\n    function assetWarpers(\\n        address original,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory, Warpers.Warper[] memory);\\n\\n    /**\\n     * @dev Returns the number of currently supported assets.\\n     * @return Asset count.\\n     */\\n    function supportedAssetCount() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the list of all supported asset addresses.\\n     * @param offset Starting index.\\n     * @param limit Max number of items.\\n     * @return List of original asset addresses.\\n     * @return List of asset config structures.\\n     */\\n    function supportedAssets(uint256 offset, uint256 limit)\\n        external\\n        view\\n        returns (address[] memory, Assets.AssetConfig[] memory);\\n\\n    /**\\n     * @dev Returns warper preset factory address.\\n     */\\n    function warperPresetFactory() external view returns (address);\\n\\n    /**\\n     * @dev Checks whether `account` is the `warper` admin.\\n     * @param warper Warper address.\\n     * @param account Account address.\\n     * @return True if the `account` is the admin of the `warper` and false otherwise.\\n     */\\n    function isWarperAdmin(address warper, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns registered warper details.\\n     * @param warper Warper address.\\n     * @return Warper details.\\n     */\\n    function warperInfo(address warper) external view returns (Warpers.Warper memory);\\n\\n    /**\\n     * @dev Returns warper controller address.\\n     * @param warper Warper address.\\n     * @return Current controller.\\n     */\\n    function warperController(address warper) external view returns (address);\\n\\n    /**\\n     * @dev Puts the warper on pause.\\n     * Emits a {WarperPaused} event.\\n     * @param warper Address.\\n     */\\n    function pauseWarper(address warper) external;\\n\\n    /**\\n     * @dev Lifts the warper pause.\\n     * Emits a {WarperUnpaused} event.\\n     * @param warper Address.\\n     */\\n    function unpauseWarper(address warper) external;\\n}\\n\",\"keccak256\":\"0x16591ee0e3d0560cdadbdf66cce9330af1b9adae993ecd2d8b24cc02136fe8e4\",\"license\":\"MIT\"},\"contracts/warper/IWarperPreset.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable private-vars-leading-underscore\\npragma solidity 0.8.13;\\n\\nimport \\\"./IWarper.sol\\\";\\n\\ninterface IWarperPreset is IWarper {\\n    /**\\n     * @dev Warper generic initialization method.\\n     * @param config Warper configuration parameters.\\n     */\\n    function __initialize(bytes calldata config) external;\\n}\\n\",\"keccak256\":\"0x2d0eb4905cf266573a66a38958b288c245c9e7fb014b6c7c95733fa8826d939a\",\"license\":\"MIT\"},\"contracts/warper/IWarperPresetFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IWarperPresetFactory {\\n    // TODO Docs\\n    error InvalidWarperPresetInterface();\\n    error DuplicateWarperPresetId(bytes32 presetId);\\n    error DisabledWarperPreset(bytes32 presetId);\\n    error EnabledWarperPreset(bytes32 presetId);\\n    error WarperPresetNotRegistered(bytes32 presetId);\\n\\n    /**\\n     * @dev Thrown when the provided preset initialization data is empty.\\n     */\\n    error EmptyPresetData();\\n\\n    struct WarperPreset {\\n        bytes32 id;\\n        address implementation;\\n        bool enabled;\\n    }\\n\\n    /**\\n     * @dev Emitted when new warper preset is added.\\n     */\\n    event WarperPresetAdded(bytes32 indexed presetId, address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when a warper preset is disabled.\\n     */\\n    event WarperPresetDisabled(bytes32 indexed presetId);\\n\\n    /**\\n     * @dev Emitted when a warper preset is enabled.\\n     */\\n    event WarperPresetEnabled(bytes32 indexed presetId);\\n\\n    /**\\n     * @dev Emitted when a warper preset is enabled.\\n     */\\n    event WarperPresetRemoved(bytes32 indexed presetId);\\n\\n    /**\\n     * @dev Emitted when a warper preset is deployed.\\n     */\\n    event WarperPresetDeployed(bytes32 indexed presetId, address indexed warper);\\n\\n    /**\\n     * @dev Stores the association between `presetId` and `implementation` address.\\n     * NOTE: Warper `implementation` must be deployed beforehand.\\n     * @param presetId Warper preset id.\\n     * @param implementation Warper implementation address.\\n     */\\n    function addPreset(bytes32 presetId, address implementation) external;\\n\\n    /**\\n     * @dev Removes the association between `presetId` and its implementation.\\n     * @param presetId Warper preset id.\\n     */\\n    function removePreset(bytes32 presetId) external;\\n\\n    /**\\n     * @dev Enables warper preset, which makes it deployable.\\n     * @param presetId Warper preset id.\\n     */\\n    function enablePreset(bytes32 presetId) external;\\n\\n    /**\\n     * @dev Disable warper preset, which makes non-deployable.\\n     * @param presetId Warper preset id.\\n     */\\n    function disablePreset(bytes32 presetId) external;\\n\\n    /**\\n     * @dev Deploys a new warper from the preset identified by `presetId`.\\n     * @param presetId Warper preset id.\\n     * @param initData Warper initialization payload.\\n     * @return Deployed warper address.\\n     */\\n    function deployPreset(bytes32 presetId, bytes calldata initData) external returns (address);\\n\\n    /**\\n     * @dev Checks whether warper preset is enabled and available for deployment.\\n     * @param presetId Warper preset id.\\n     */\\n    function presetEnabled(bytes32 presetId) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the list of all registered warper presets.\\n     */\\n    function presets() external view returns (WarperPreset[] memory);\\n\\n    /**\\n     * @dev Returns the warper preset details.\\n     * @param presetId Warper preset id.\\n     */\\n    function preset(bytes32 presetId) external view returns (WarperPreset memory);\\n}\\n\",\"keccak256\":\"0x8f8b1275a6cbfdded6003f10f33b6a6e03ae6f4aaa225e0c10fa6d7148c32eb4\",\"license\":\"MIT\"},\"contracts/warper/Warper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable private-vars-leading-underscore, func-name-mixedcase\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Multicall.sol\\\";\\nimport \\\"./IWarper.sol\\\";\\nimport \\\"./utils/CallForwarder.sol\\\";\\nimport \\\"./utils/WarperContext.sol\\\";\\n\\nabstract contract Warper is IWarper, WarperContext, CallForwarder, Multicall {\\n    using ERC165Checker for address;\\n\\n    /**\\n     * @dev Thrown when the original asset contract does not implement the interface, expected by Warper.\\n     */\\n    error InvalidOriginalTokenInterface(address original, bytes4 requiredInterfaceId);\\n\\n    /**\\n     * @dev Forwards the current call to the original asset contract. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Forwards the current call to the original asset contract`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Warper initializer.\\n     *\\n     */\\n    function _Warper_init(address original, address metahub) internal onlyInitializing {\\n        _validateOriginal(original);\\n        _setOriginal(original);\\n        _setMetahub(metahub);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IWarper).interfaceId ||\\n            interfaceId == type(IERC165).interfaceId ||\\n            _original().supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IWarper\\n     */\\n    function __supportedInterfaces(bytes4[] memory interfaceIds) external view returns (bool[] memory) {\\n        return address(this).getSupportedInterfaces(interfaceIds);\\n    }\\n\\n    /**\\n     * @dev Returns the original NFT address.\\n     */\\n    function __original() external view returns (address) {\\n        return _original();\\n    }\\n\\n    /**\\n     * @inheritdoc IWarper\\n     */\\n    function __metahub() external view returns (address) {\\n        return _metahub();\\n    }\\n\\n    /**\\n     * @dev Forwards the current call to the original asset contract`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _forward(_original());\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the original. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @dev Validates the original NFT.\\n     *\\n     * If overridden should call `super._validateOriginal()`.\\n     */\\n    function _validateOriginal(address original) internal virtual {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n}\\n\",\"keccak256\":\"0xba6d58e1943a1535e40321c2b1958cd7ba5415fd0b0bcea151daa0b5bb96f9fc\",\"license\":\"MIT\"},\"contracts/warper/Warpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\n\\nimport \\\"./IWarperController.sol\\\";\\nimport \\\"./IWarperPresetFactory.sol\\\";\\nimport \\\"../asset/Assets.sol\\\";\\n\\nlibrary Warpers {\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n    using Warpers for Registry;\\n    using Assets for Assets.Asset;\\n\\n    /**\\n     * @dev Thrown when performing action or accessing data of an unknown warper.\\n     * @param warper Warper address.\\n     */\\n    error WarperIsNotRegistered(address warper);\\n\\n    /**\\n     * @dev Thrown upon attempting to register a warper twice.\\n     * @param warper Duplicate warper address.\\n     */\\n    error WarperIsAlreadyRegistered(address warper);\\n\\n    /**\\n     * @dev Thrown when the operation is not allowed due to the warper being paused.\\n     */\\n    error WarperIsPaused();\\n\\n    /**\\n     * @dev Thrown when the operation is not allowed due to the warper not being paused.\\n     */\\n    error WarperIsNotPaused();\\n\\n    /**\\n     * @dev Thrown when there are no registered warpers for a particular asset.\\n     * @param asset Asset address.\\n     */\\n    error UnsupportedAsset(address asset);\\n\\n    /**\\n     * @dev Thrown upon attempting to use the warper which is not registered for the provided asset.\\n     */\\n    error IncompatibleAsset(address asset);\\n\\n    /**\\n     * @dev Registered warper data.\\n     * @param assetClass The identifying asset class.\\n     * @param original Original asset contract address.\\n     * @param paused Indicates whether the warper is paused.\\n     * @param controller Warper controller.\\n     * @param name Warper name.\\n     * @param universeId Warper universe ID.\\n     */\\n    struct Warper {\\n        bytes4 assetClass;\\n        address original;\\n        bool paused;\\n        IWarperController controller;\\n        string name;\\n        uint256 universeId;\\n    }\\n\\n    /**\\n     * @dev Reverts if the warper original does not match the `asset`;\\n     */\\n    function checkCompatibleAsset(Warper storage self, Assets.Asset memory asset) internal view {\\n        address original = asset.token();\\n        if (self.original != original) revert IncompatibleAsset(original);\\n    }\\n\\n    /**\\n     * @dev Puts the warper on pause.\\n     */\\n    function pause(Warper storage self) internal {\\n        if (self.paused) revert WarperIsPaused();\\n\\n        self.paused = true;\\n    }\\n\\n    /**\\n     * @dev Lifts the warper pause.\\n     */\\n    function unpause(Warper storage self) internal {\\n        if (!self.paused) revert WarperIsNotPaused();\\n\\n        self.paused = false;\\n    }\\n\\n    /**\\n     * @dev Reverts if the warper is paused.\\n     */\\n    function checkNotPaused(Warper storage self) internal view {\\n        if (self.paused) revert WarperIsPaused();\\n    }\\n\\n    /**\\n     * @dev Warper registry.\\n     * @param presetFactory Warper preset factory contract.\\n     * @param warperIndex Set of registered warper addresses.\\n     * @param universeWarperIndex Mapping from a universe ID to the set of warper addresses registered by the universe.\\n     * @param assetWarperIndex Mapping from an original asset address to the set of warper addresses,\\n     * registered for the asset.\\n     * @param warpers Mapping from a warper address to the warper details.\\n     */\\n    struct Registry {\\n        IWarperPresetFactory presetFactory;\\n        EnumerableSetUpgradeable.AddressSet warperIndex;\\n        mapping(uint256 => EnumerableSetUpgradeable.AddressSet) universeWarperIndex;\\n        mapping(address => EnumerableSetUpgradeable.AddressSet) assetWarperIndex;\\n        mapping(address => Warpers.Warper) warpers;\\n    }\\n\\n    /**\\n     * @dev Performs warper registration.\\n     */\\n    function register(\\n        Registry storage self,\\n        address warperAddress,\\n        Warper memory warper\\n    ) external {\\n        if (!self.warperIndex.add(warperAddress)) revert WarperIsAlreadyRegistered(warperAddress);\\n\\n        // Ensure warper compatibility with the current generation of asset controller.\\n        warper.controller.checkCompatibleWarper(warperAddress);\\n\\n        // Create warper main registration record.\\n        self.warpers[warperAddress] = warper;\\n        // Associate the warper with the universe.\\n        self.universeWarperIndex[warper.universeId].add(warperAddress);\\n        // Associate the warper with the original asset.\\n        self.assetWarperIndex[warper.original].add(warperAddress);\\n    }\\n\\n    /**\\n     * @dev Removes warper data from the registry.\\n     */\\n    function remove(Registry storage self, address warperAddress) external {\\n        Warper storage warper = self.warpers[warperAddress];\\n        // Clean up universe index.\\n        self.universeWarperIndex[warper.universeId].remove(warperAddress);\\n        // Clean up asset index.\\n        self.assetWarperIndex[warper.original].remove(warperAddress);\\n        // Clean up main index.\\n        self.warperIndex.remove(warperAddress);\\n        // Delete warper data.\\n        delete self.warpers[warperAddress];\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of warpers belonging to the particular universe.\\n     */\\n    function universeWarpers(\\n        Registry storage self,\\n        uint256 universeId,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory, Warpers.Warper[] memory) {\\n        return self.paginateIndexedWarpers(self.universeWarperIndex[universeId], offset, limit);\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of warpers associated with the particular original asset.\\n     */\\n    function assetWarpers(\\n        Registry storage self,\\n        address original,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory, Warpers.Warper[] memory) {\\n        return self.paginateIndexedWarpers(self.assetWarperIndex[original], offset, limit);\\n    }\\n\\n    /**\\n     * @dev Checks warper registration by address.\\n     */\\n    function isRegisteredWarper(Registry storage self, address warper) internal view returns (bool) {\\n        return self.warperIndex.contains(warper);\\n    }\\n\\n    /**\\n     * @dev Reverts if warper is not registered.\\n     */\\n    function checkRegisteredWarper(Registry storage self, address warper) internal view {\\n        if (!self.isRegisteredWarper(warper)) revert WarperIsNotRegistered(warper);\\n    }\\n\\n    /**\\n     * @dev Reverts if asset is not supported.\\n     * @param asset Asset address.\\n     */\\n    function checkSupportedAsset(Registry storage self, address asset) internal view {\\n        if (!self.isSupportedAsset(asset)) revert UnsupportedAsset(asset);\\n    }\\n\\n    /**\\n     * @dev Checks asset support by address.\\n     * The supported asset should have at least one warper.\\n     * @param asset Asset address.\\n     */\\n    function isSupportedAsset(Registry storage self, address asset) internal view returns (bool) {\\n        return self.assetWarperIndex[asset].length() > 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of warpers belonging to the particular universe.\\n     */\\n    function universeWarperCount(Registry storage self, uint256 universeId) internal view returns (uint256) {\\n        return self.universeWarperIndex[universeId].length();\\n    }\\n\\n    /**\\n     * @dev Returns the number of warpers associated with the particular original asset.\\n     */\\n    function assetWarperCount(Registry storage self, address original) internal view returns (uint256) {\\n        return self.assetWarperIndex[original].length();\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of registered warpers using provided index reference.\\n     */\\n    function paginateIndexedWarpers(\\n        Registry storage self,\\n        EnumerableSetUpgradeable.AddressSet storage warperIndex,\\n        uint256 offset,\\n        uint256 limit\\n    ) internal view returns (address[] memory, Warper[] memory) {\\n        uint256 indexSize = warperIndex.length();\\n        if (offset >= indexSize) return (new address[](0), new Warper[](0));\\n\\n        if (limit > indexSize - offset) {\\n            limit = indexSize - offset;\\n        }\\n\\n        Warper[] memory warpers = new Warper[](limit);\\n        address[] memory warperAddresses = new address[](limit);\\n        for (uint256 i = 0; i < limit; i++) {\\n            warperAddresses[i] = warperIndex.at(offset + i);\\n            warpers[i] = self.warpers[warperAddresses[i]];\\n        }\\n\\n        return (warperAddresses, warpers);\\n    }\\n}\\n\",\"keccak256\":\"0x4de46668ccaad006d55f532df7da048621472ce3db10ed7b57a9fc97f980b200\",\"license\":\"MIT\"},\"contracts/warper/mechanics/availability-period/ConfigurableAvailabilityPeriodExtension.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable private-vars-leading-underscore, func-name-mixedcase, ordering\\npragma solidity 0.8.13;\\n\\nimport \\\"../../Warper.sol\\\";\\nimport \\\"./IConfigurableAvailabilityPeriodExtension.sol\\\";\\n\\nabstract contract ConfigurableAvailabilityPeriodExtension is IConfigurableAvailabilityPeriodExtension, Warper {\\n    /**\\n     * @dev Warper availability period.\\n     */\\n    bytes32 private constant _AVAILABILITY_PERIOD_SLOT =\\n        bytes32(uint256(keccak256(\\\"iq.warper.params.availabilityPeriod\\\")) - 1);\\n\\n    uint256 private constant _MAX_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000;\\n    uint256 private constant _MIN_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFF;\\n    uint256 private constant _MAX_PERIOD_BITSHIFT = 0;\\n    uint256 private constant _MIN_PERIOD_BITSHIFT = 32;\\n\\n    /**\\n     * Extension initializer.\\n     */\\n    function _ConfigurableAvailabilityPeriodExtension_init() internal onlyInitializing {\\n        _setAvailabilityPeriods(0, type(uint32).max);\\n    }\\n\\n    /**\\n     * @inheritdoc IConfigurableAvailabilityPeriodExtension\\n     */\\n    function __setAvailabilityPeriodStart(uint32 availabilityPeriodStart) external virtual onlyWarperAdmin {\\n        (, uint32 availabilityPeriodEnd) = _availabilityPeriods();\\n        if (availabilityPeriodStart >= availabilityPeriodEnd) revert InvalidAvailabilityPeriodStart();\\n\\n        _setAvailabilityPeriods(availabilityPeriodStart, availabilityPeriodEnd);\\n    }\\n\\n    /**\\n     * @inheritdoc IConfigurableAvailabilityPeriodExtension\\n     */\\n    function __setAvailabilityPeriodEnd(uint32 availabilityPeriodEnd) external virtual onlyWarperAdmin {\\n        (uint32 availabilityPeriodStart, ) = _availabilityPeriods();\\n        if (availabilityPeriodStart >= availabilityPeriodEnd) revert InvalidAvailabilityPeriodEnd();\\n\\n        _setAvailabilityPeriods(availabilityPeriodStart, availabilityPeriodEnd);\\n    }\\n\\n    /**\\n     * @inheritdoc IAvailabilityPeriodMechanics\\n     */\\n    function __availabilityPeriodStart() external view virtual returns (uint32) {\\n        (uint32 availabilityPeriodStart, ) = _availabilityPeriods();\\n        return availabilityPeriodStart;\\n    }\\n\\n    /**\\n     * @inheritdoc IAvailabilityPeriodMechanics\\n     */\\n    function __availabilityPeriodEnd() external view virtual returns (uint32) {\\n        (, uint32 availabilityPeriodEnd) = _availabilityPeriods();\\n        return availabilityPeriodEnd;\\n    }\\n\\n    /**\\n     * @inheritdoc IAvailabilityPeriodMechanics\\n     */\\n    function __availabilityPeriodRange()\\n        external\\n        view\\n        virtual\\n        returns (uint32 availabilityPeriodStart, uint32 availabilityPeriodEnd)\\n    {\\n        (availabilityPeriodStart, availabilityPeriodEnd) = _availabilityPeriods();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(Warper) returns (bool) {\\n        return\\n            interfaceId == type(IConfigurableAvailabilityPeriodExtension).interfaceId ||\\n            interfaceId == type(IAvailabilityPeriodMechanics).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Stores warper availability period.\\n     */\\n    function _setAvailabilityPeriods(uint32 availabilityPeriodStart, uint32 availabilityPeriodEnd) internal {\\n        uint256 data = (0 & _MAX_PERIOD_MASK) | (uint256(availabilityPeriodEnd) << _MAX_PERIOD_BITSHIFT);\\n        data = (data & _MIN_PERIOD_MASK) | (uint256(availabilityPeriodStart) << _MIN_PERIOD_BITSHIFT);\\n\\n        StorageSlot.getUint256Slot(_AVAILABILITY_PERIOD_SLOT).value = data;\\n    }\\n\\n    /**\\n     * @dev Returns warper availability period.\\n     */\\n    function _availabilityPeriods()\\n        internal\\n        view\\n        returns (uint32 availabilityPeriodStart, uint32 availabilityPeriodEnd)\\n    {\\n        uint256 data = StorageSlot.getUint256Slot(_AVAILABILITY_PERIOD_SLOT).value;\\n        availabilityPeriodStart = uint32((data & ~_MIN_PERIOD_MASK) >> _MIN_PERIOD_BITSHIFT);\\n        availabilityPeriodEnd = uint32((data & ~_MAX_PERIOD_MASK) >> _MAX_PERIOD_BITSHIFT);\\n    }\\n}\\n\",\"keccak256\":\"0x6f8d06b97418a386543b9e69dbd75eae77a8f9bf5ecb4de7537c5d1b9d9d6a86\",\"license\":\"MIT\"},\"contracts/warper/mechanics/availability-period/IAvailabilityPeriodMechanics.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable private-vars-leading-underscore\\npragma solidity 0.8.13;\\n\\ninterface IAvailabilityPeriodMechanics {\\n    /**\\n     * @dev Thrown when the current time is not withing the warper availability period.\\n     */\\n    error WarperIsNotAvailableForRenting(\\n        uint256 currentTime,\\n        uint32 availabilityPeriodStart,\\n        uint32 availabilityPeriodEnd\\n    );\\n\\n    /**\\n     * @dev Returns warper availability period starting time.\\n     * @return Unix timestamp after which the warper is rentable.\\n     */\\n    function __availabilityPeriodStart() external view returns (uint32);\\n\\n    /**\\n     * @dev Returns warper availability period ending time.\\n     * @return Unix timestamp after which the warper is NOT rentable.\\n     */\\n    function __availabilityPeriodEnd() external view returns (uint32);\\n\\n    /**\\n     * @dev Returns warper availability period.\\n     * @return availabilityPeriodStart Unix timestamp after which the warper is rentable.\\n     * @return availabilityPeriodEnd Unix timestamp after which the warper is NOT rentable.\\n     */\\n    function __availabilityPeriodRange()\\n        external\\n        view\\n        returns (uint32 availabilityPeriodStart, uint32 availabilityPeriodEnd);\\n}\\n\",\"keccak256\":\"0x52f8a5369f4f177b0e998934e920d32b67aa5115625550d26630cff9f5d93c1c\",\"license\":\"MIT\"},\"contracts/warper/mechanics/availability-period/IConfigurableAvailabilityPeriodExtension.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable private-vars-leading-underscore\\npragma solidity 0.8.13;\\n\\nimport \\\"./IAvailabilityPeriodMechanics.sol\\\";\\n\\ninterface IConfigurableAvailabilityPeriodExtension is IAvailabilityPeriodMechanics {\\n    /**\\n     * @dev Thrown when the availability period start time is not strictly lesser than the end time\\n     */\\n    error InvalidAvailabilityPeriodStart();\\n\\n    /**\\n     * @dev Thrown when the availability period end time is not greater or equal than the start time\\n     */\\n    error InvalidAvailabilityPeriodEnd();\\n\\n    /**\\n     * @dev Sets warper availability period starting time.\\n     * @param availabilityPeriodStart Unix timestamp after which the warper is rentable.\\n     */\\n    function __setAvailabilityPeriodStart(uint32 availabilityPeriodStart) external;\\n\\n    /**\\n     * @dev Sets warper availability period ending time.\\n     * @param availabilityPeriodEnd Unix timestamp after which the warper is NOT rentable.\\n     */\\n    function __setAvailabilityPeriodEnd(uint32 availabilityPeriodEnd) external;\\n}\\n\",\"keccak256\":\"0x401af13bf1f97197808e57d88185f38eaaacb029b9c272f95722035c70b94528\",\"license\":\"MIT\"},\"contracts/warper/mechanics/rental-period/ConfigurableRentalPeriodExtension.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable private-vars-leading-underscore, func-name-mixedcase, ordering\\npragma solidity 0.8.13;\\n\\nimport \\\"../../Warper.sol\\\";\\nimport \\\"./IConfigurableRentalPeriodExtension.sol\\\";\\n\\nabstract contract ConfigurableRentalPeriodExtension is IConfigurableRentalPeriodExtension, Warper {\\n    /**\\n     * @dev Warper rental period.\\n     * @dev It contains both - the min and max values (uint32) - in a concatenated form.\\n     */\\n    bytes32 private constant _RENTAL_PERIOD_SLOT = bytes32(uint256(keccak256(\\\"iq.warper.params.rentalPeriod\\\")) - 1);\\n\\n    uint256 private constant _MAX_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000;\\n    uint256 private constant _MIN_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFF;\\n    uint256 private constant _MAX_PERIOD_BITSHIFT = 0;\\n    uint256 private constant _MIN_PERIOD_BITSHIFT = 32;\\n\\n    /**\\n     * @dev Extension initializer.\\n     */\\n    function _ConfigurableRentalPeriodExtension_init() internal onlyInitializing {\\n        // Store default values.\\n        _setRentalPeriods(0, type(uint32).max);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(Warper) returns (bool) {\\n        return\\n            interfaceId == type(IConfigurableRentalPeriodExtension).interfaceId ||\\n            interfaceId == type(IRentalPeriodMechanics).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc IConfigurableRentalPeriodExtension\\n     */\\n    function __setMinRentalPeriod(uint32 minRentalPeriod) external virtual onlyWarperAdmin {\\n        (, uint32 maxRentalPeriod) = _rentalPeriods();\\n        if (minRentalPeriod > maxRentalPeriod) revert InvalidMinRentalPeriod();\\n\\n        _setRentalPeriods(minRentalPeriod, maxRentalPeriod);\\n    }\\n\\n    /**\\n     * @inheritdoc IConfigurableRentalPeriodExtension\\n     */\\n    function __setMaxRentalPeriod(uint32 maxRentalPeriod) external virtual onlyWarperAdmin {\\n        (uint32 minRentalPeriod, ) = _rentalPeriods();\\n        if (minRentalPeriod > maxRentalPeriod) revert InvalidMaxRentalPeriod();\\n\\n        _setRentalPeriods(minRentalPeriod, maxRentalPeriod);\\n    }\\n\\n    /**\\n     * @inheritdoc IRentalPeriodMechanics\\n     */\\n    function __minRentalPeriod() external view virtual returns (uint32) {\\n        (uint32 minRentalPeriod, ) = _rentalPeriods();\\n        return minRentalPeriod;\\n    }\\n\\n    /**\\n     * @inheritdoc IRentalPeriodMechanics\\n     */\\n    function __maxRentalPeriod() external view virtual override returns (uint32) {\\n        (, uint32 maxRentalPeriod) = _rentalPeriods();\\n        return maxRentalPeriod;\\n    }\\n\\n    /**\\n     * @inheritdoc IRentalPeriodMechanics\\n     */\\n    function __rentalPeriodRange() external view returns (uint32 minRentalPeriod, uint32 maxRentalPeriod) {\\n        (minRentalPeriod, maxRentalPeriod) = _rentalPeriods();\\n    }\\n\\n    /**\\n     * @dev Stores warper rental period.\\n     */\\n    function _setRentalPeriods(uint32 minRentalPeriod, uint32 maxRentalPeriod) internal {\\n        uint256 data = (0 & _MAX_PERIOD_MASK) | (uint256(maxRentalPeriod) << _MAX_PERIOD_BITSHIFT);\\n        data = (data & _MIN_PERIOD_MASK) | (uint256(minRentalPeriod) << _MIN_PERIOD_BITSHIFT);\\n\\n        StorageSlot.getUint256Slot(_RENTAL_PERIOD_SLOT).value = data;\\n    }\\n\\n    /**\\n     * @dev Returns warper rental periods.\\n     */\\n    function _rentalPeriods() internal view returns (uint32 minRentalPeriod, uint32 maxRentalPeriod) {\\n        uint256 data = StorageSlot.getUint256Slot(_RENTAL_PERIOD_SLOT).value;\\n        minRentalPeriod = uint32((data & ~_MIN_PERIOD_MASK) >> _MIN_PERIOD_BITSHIFT);\\n        maxRentalPeriod = uint32((data & ~_MAX_PERIOD_MASK) >> _MAX_PERIOD_BITSHIFT);\\n    }\\n}\\n\",\"keccak256\":\"0xdbc48aef1409f6eace9ee2a11287da1a31b7590b3341736ad5982f4dd10b9aa6\",\"license\":\"MIT\"},\"contracts/warper/mechanics/rental-period/IConfigurableRentalPeriodExtension.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable private-vars-leading-underscore\\npragma solidity 0.8.13;\\n\\nimport \\\"./IRentalPeriodMechanics.sol\\\";\\n\\ninterface IConfigurableRentalPeriodExtension is IRentalPeriodMechanics {\\n    /**\\n     * @dev Thrown when the the min rental period is not strictly lesser than max rental period\\n     */\\n    error InvalidMinRentalPeriod();\\n\\n    /**\\n     * @dev Thrown when the max rental period is not greater or equal than min rental period\\n     */\\n    error InvalidMaxRentalPeriod();\\n\\n    /**\\n     * @dev Sets warper min rental period.\\n     * @param minRentalPeriod New min rental period value.\\n     */\\n    function __setMinRentalPeriod(uint32 minRentalPeriod) external;\\n\\n    /**\\n     * @dev Sets warper max rental period.\\n     * @param maxRentalPeriod New max rental period value.\\n     */\\n    function __setMaxRentalPeriod(uint32 maxRentalPeriod) external;\\n}\\n\",\"keccak256\":\"0x388f73ffbe34f5e706111b789f4700080279c2d67fb5972ff71121855a682335\",\"license\":\"MIT\"},\"contracts/warper/mechanics/rental-period/IRentalPeriodMechanics.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable private-vars-leading-underscore\\npragma solidity 0.8.13;\\n\\ninterface IRentalPeriodMechanics {\\n    /**\\n     * @dev Thrown when the requested rental period is not withing the warper allowed rental period range.\\n     */\\n    error WarperRentalPeriodIsOutOfRange(uint32 requestedRentalPeriod, uint32 minRentalPeriod, uint32 maxRentalPeriod);\\n\\n    /**\\n     * @dev Returns warper minimal rental period.\\n     * @return Time is seconds.\\n     */\\n    function __minRentalPeriod() external view returns (uint32);\\n\\n    /**\\n     * @dev Returns warper maximal rental period.\\n     * @return Time is seconds.\\n     */\\n    function __maxRentalPeriod() external view returns (uint32);\\n\\n    /**\\n     * @dev Returns warper rental period range.\\n     * @return minRentalPeriod The minimal amount of time the warper can be rented for.\\n     * @return maxRentalPeriod The maximal amount of time the warper can be rented for.\\n     */\\n    function __rentalPeriodRange() external view returns (uint32 minRentalPeriod, uint32 maxRentalPeriod);\\n}\\n\",\"keccak256\":\"0x88de2cc05754d55211d37eb9d58f5af275ac131370db09cc8a4d31c05a74bed7\",\"license\":\"MIT\"},\"contracts/warper/utils/CallForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nabstract contract CallForwarder {\\n    /**\\n     * @dev Thrown when a call is forwarded to a zero address.\\n     */\\n    error CallForwardToZeroAddress();\\n\\n    /**\\n     * @dev Forwards the current call to `target`.\\n     */\\n    function _forward(address target) internal {\\n        // Prevent call forwarding to the zero address.\\n        if (target == address(0)) {\\n            revert CallForwardToZeroAddress();\\n        }\\n\\n        uint256 value = msg.value;\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the target.\\n            // out and outsize are 0 for now, as we don't know the out size yet.\\n            let result := call(gas(), target, value, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // call returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd781193e9c8a094b9c0be8c1392a04f0b3bffb9b49bb4475a75aa21bd87824f0\",\"license\":\"MIT\"},\"contracts/warper/utils/InitializationContext.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nabstract contract InitializationContext {\\n    /**\\n     * @dev Thrown upon attempt to initialize a contract again.\\n     */\\n    error ContractIsAlreadyInitialized();\\n\\n    /**\\n     * @dev Thrown when a function is invoked outside of initialization transaction.\\n     */\\n    error ContractIsNotInitializing();\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bytes32 internal constant _INITIALIZED_SLOT = bytes32(uint256(keccak256(\\\"iq.context.initialized\\\")) - 1);\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bytes32 internal constant _INITIALIZING_SLOT = bytes32(uint256(keccak256(\\\"iq.context.initializing\\\")) - 1);\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        bool initialized = !(\\n            StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value\\n                ? _isConstructor()\\n                : !StorageSlot.getBooleanSlot(_INITIALIZED_SLOT).value\\n        );\\n\\n        if (initialized) {\\n            revert ContractIsAlreadyInitialized();\\n        }\\n\\n        bool isTopLevelCall = !StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value;\\n        if (isTopLevelCall) {\\n            StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value = true;\\n            StorageSlot.getBooleanSlot(_INITIALIZED_SLOT).value = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        if (!StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value) {\\n            revert ContractIsNotInitializing();\\n        }\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !Address.isContract(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x9a3055fe5e815c03f070435820a49867aaf93d7ab35d7fd78adb7818e85a6ad6\",\"license\":\"MIT\"},\"contracts/warper/utils/WarperContext.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\nimport \\\"../../metahub/IMetahub.sol\\\";\\nimport \\\"./InitializationContext.sol\\\";\\n\\nabstract contract WarperContext is Context, InitializationContext {\\n    /**\\n     * @dev Thrown when the message sender doesn't match the Metahub address.\\n     */\\n    error CallerIsNotMetahub();\\n\\n    /**\\n     * @dev Thrown when the message sender doesn't match the warper admin address.\\n     */\\n    error CallerIsNotWarperAdmin();\\n\\n    /**\\n     * @dev Metahub address slot.\\n     */\\n    bytes32 private constant _METAHUB_SLOT = bytes32(uint256(keccak256(\\\"iq.warper.metahub\\\")) - 1);\\n\\n    /**\\n     * @dev Original asset address slot.\\n     */\\n    bytes32 private constant _ORIGINAL_SLOT = bytes32(uint256(keccak256(\\\"iq.warper.original\\\")) - 1);\\n\\n    /**\\n     * @dev Modifier to make a function callable only by the metahub contract.\\n     */\\n    modifier onlyMetahub() {\\n        if (_msgSender() != _metahub()) {\\n            revert CallerIsNotMetahub();\\n        }\\n        _;\\n    }\\n    /**\\n     * @dev Modifier to make a function callable only by the warper admin.\\n     */\\n    modifier onlyWarperAdmin() {\\n        if (!IMetahub(_metahub()).isWarperAdmin(address(this), _msgSender())) {\\n            revert CallerIsNotWarperAdmin();\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Sets warper original asset address.\\n     */\\n    function _setOriginal(address original) internal onlyInitializing {\\n        StorageSlot.getAddressSlot(_ORIGINAL_SLOT).value = original;\\n    }\\n\\n    /**\\n     * @dev Sets warper metahub address.\\n     */\\n    function _setMetahub(address metahub) internal onlyInitializing {\\n        StorageSlot.getAddressSlot(_METAHUB_SLOT).value = metahub;\\n    }\\n\\n    /**\\n     * @dev Returns warper original asset address.\\n     */\\n    function _original() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ORIGINAL_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev warper metahub address.\\n     */\\n    function _metahub() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_METAHUB_SLOT).value;\\n    }\\n}\\n\",\"keccak256\":\"0x876bdba044a093f4fbd206211cdd28f11d54f634884347e291d7bfb014606794\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50612244806100206000396000f3fe60806040526004361061019f5760003560e01c80638993dafd116100ec578063b88d4fde1161008a578063e846a5a911610064578063e846a5a9146104d6578063e985e9c5146104f8578063f46c73c614610513578063ffd5b31714610528576101ae565b8063b88d4fde14610481578063c566b080146104a1578063d1958f2c146104c1576101ae565b8063986e9115116100c6578063986e91151461040f578063a22cb46514610424578063ab9a8dcd1461043f578063ac9650d814610454576101ae565b80638993dafd146103af5780638d796a37146103cf57806394d008ef146103ef576101ae565b80632a58f7ac116101595780635a70a283116101335780635a70a283146103225780635e88e74a146103375780636352211e1461036157806370a0823114610381576101ae565b80632a58f7ac146102c257806342842e0e146102e257806356a872bd14610302576101ae565b8062eb6ac7146101b657806301ffc9a7146101ed578063081812fc1461021d578063095ea7b3146102555780631f9e33041461027557806323b872dd146102a2576101ae565b366101ae576101ac61053d565b005b6101ac61053d565b3480156101c257600080fd5b506101cb61054f565b6040805163ffffffff9384168152929091166020830152015b60405180910390f35b3480156101f957600080fd5b5061020d610208366004611aa1565b610563565b60405190151581526020016101e4565b34801561022957600080fd5b5061023d610238366004611abe565b6105ac565b6040516001600160a01b0390911681526020016101e4565b34801561026157600080fd5b506101ac610270366004611aec565b6105c7565b34801561028157600080fd5b50610295610290366004611b5f565b6105e0565b6040516101e49190611c11565b3480156102ae57600080fd5b506101ac6102bd366004611c57565b6105ec565b3480156102ce57600080fd5b506101ac6102dd366004611c98565b6105fc565b3480156102ee57600080fd5b506101ac6102fd366004611c57565b6106e6565b34801561030e57600080fd5b506101ac61031d366004611c98565b610701565b34801561032e57600080fd5b5061023d6107e8565b34801561034357600080fd5b5061034c6107f7565b60405163ffffffff90911681526020016101e4565b34801561036d57600080fd5b5061023d61037c366004611abe565b610809565b34801561038d57600080fd5b506103a161039c366004611cbe565b610944565b6040519081526020016101e4565b3480156103bb57600080fd5b506101ac6103ca366004611cdb565b610a0d565b3480156103db57600080fd5b506101ac6103ea366004611c98565b610b92565b3480156103fb57600080fd5b506101ac61040a366004611dbd565b610c78565b34801561041b57600080fd5b5061034c610d6d565b34801561043057600080fd5b506101ac610270366004611e24565b34801561044b57600080fd5b5061034c610d78565b34801561046057600080fd5b5061047461046f366004611e5d565b610d83565b6040516101e49190611f18565b34801561048d57600080fd5b506101ac61049c366004611f7a565b610e71565b3480156104ad57600080fd5b506101ac6104bc366004611c98565b610e7d565b3480156104cd57600080fd5b506101cb610f64565b3480156104e257600080fd5b506040516339d690a360e11b81526020016101e4565b34801561050457600080fd5b5061020d610238366004611fe6565b34801561051f57600080fd5b5061023d610f6f565b34801561053457600080fd5b5061034c610f79565b61054d610548610f84565b610fc3565b565b60008061055a611010565b90939092509050565b60006001600160e01b03198216638993dafd60e01b1480610588575061058882611059565b80610597575061059782611099565b806105a657506105a6826110d9565b92915050565b60006040516341f8b8eb60e11b815260040160405180910390fd5b6040516341f8b8eb60e11b815260040160405180910390fd5b60606105a63083611119565b6105f78383836111dc565b505050565b6106046112a2565b6001600160a01b031663882080d330336040516001600160e01b031960e085901b1681526001600160a01b03928316600482015291166024820152604401602060405180830381865afa15801561065f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106839190612014565b61069f57604051621c9ee960e91b815260040160405180910390fd5b60006106a96112d2565b9150508063ffffffff168263ffffffff16106106d85760405163e652891d60e01b815260040160405180910390fd5b6106e28282611304565b5050565b6105f783838360405180602001604052806000815250610e71565b6107096112a2565b6001600160a01b031663882080d330336040516001600160e01b031960e085901b1681526001600160a01b03928316600482015291166024820152604401602060405180830381865afa158015610764573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107889190612014565b6107a457604051621c9ee960e91b815260040160405180910390fd5b60006107ae611010565b9150508063ffffffff168263ffffffff1611156107de5760405163dea1d81f60e01b815260040160405180910390fd5b6106e28282611350565b60006107f26112a2565b905090565b6000806108026112d2565b5092915050565b600080610814611396565b90506000816001600160a01b0316633f09518c61082f6112a2565b6040516001600160e01b031960e084901b1681526001600160a01b03909116600482015230602482015260448101879052606401602060405180830381865afa158015610880573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108a49190612031565b905060008160028111156108ba576108ba612052565b036108e05760405163e4c0734760e01b8152600481018590526024015b60405180910390fd5b60018160028111156108f4576108f4612052565b03610909576109016112a2565b949350505050565b50506000828152602081905260409020546001600160a01b0316806105a65760405163e4c0734760e01b8152600481018490526024016108d7565b60006001600160a01b03821661096d576040516323d3ad8160e21b815260040160405180910390fd5b6000610977611396565b9050806001600160a01b031663bfe0af996109906112a2565b6040516001600160e01b031960e084901b1681526001600160a01b0391821660048201523060248201529086166044820152606401602060405180830381865afa1580156109e2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a069190612068565b9392505050565b6000610a2e610a2b60016000805160206121ef833981519152612097565b90565b5460ff16610a6e57610a64610a2b60017f37e69e8e563db672cb7e105d3e1915d10ef53975d285d458a13e70818bf53d27612097565b5460ff1615610a72565b303b155b1590508015610a935760405162ea7fe560e71b815260040160405180910390fd5b6000610ab1610a2b60016000805160206121ef833981519152612097565b5460ff161590508015610b29576001610adb610a2b826000805160206121ef833981519152612097565b805460ff19169115159190911790556001610b19610a2b827f37e69e8e563db672cb7e105d3e1915d10ef53975d285d458a13e70818bf53d27612097565b805460ff19169115159190911790555b600080610b3885870187611fe6565b91509150610b46828261140a565b610b4e611462565b610b566114ae565b50508015610b8c576000610b7c610a2b60016000805160206121ef833981519152612097565b805460ff19169115159190911790555b50505050565b610b9a6112a2565b6001600160a01b031663882080d330336040516001600160e01b031960e085901b1681526001600160a01b03928316600482015291166024820152604401602060405180830381865afa158015610bf5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c199190612014565b610c3557604051621c9ee960e91b815260040160405180910390fd5b6000610c3f6112d2565b5090508163ffffffff168163ffffffff1610610c6e57604051636b97294960e11b815260040160405180910390fd5b6106e28183611304565b6001600160a01b038316610c9f5760405163c96c2a0b60e01b815260040160405180910390fd5b6000828152602081905260409020546001600160a01b031615610cd8576040516376b78f6560e01b8152600481018390526024016108d7565b610ce4600084846114fa565b60008281526020819052604080822080546001600160a01b0319166001600160a01b03871690811790915590518492907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a4610d466000848484611533565b6105f75760405162aae5b760e01b81526001600160a01b03841660048201526024016108d7565b600080610a06611010565b600080610802611010565b60608167ffffffffffffffff811115610d9e57610d9e611b18565b604051908082528060200260200182016040528015610dd157816020015b6060815260200190600190039081610dbc5790505b50905060005b8281101561080257610e4130858584818110610df557610df56120ae565b9050602002810190610e0791906120c4565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061163e92505050565b828281518110610e5357610e536120ae565b60200260200101819052508080610e6990612112565b915050610dd7565b610b8c84848484611663565b610e856112a2565b6001600160a01b031663882080d330336040516001600160e01b031960e085901b1681526001600160a01b03928316600482015291166024820152604401602060405180830381865afa158015610ee0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f049190612014565b610f2057604051621c9ee960e91b815260040160405180910390fd5b6000610f2a611010565b5090508163ffffffff168163ffffffff161115610f5a5760405163077f3cbd60e11b815260040160405180910390fd5b6106e28183611350565b60008061055a6112d2565b60006107f2610f84565b600080610a066112d2565b6000610fb4610a2b60017f1cd3cead3f33d5ed74fb83a237e17d126ef505cbae350d3d0ffce421e3a1d144612097565b546001600160a01b0316919050565b6001600160a01b038116610fea5760405163eb0308d160e01b815260040160405180910390fd5b34366000803760008036600084865af13d6000803e80801561100b573d6000f35b3d6000fd5b60008080611042610a2b60017f1b3d86ed8dfe582174d4360a5614978a5ce792b2850c12fe4f73655644f0ae46612097565b5463ffffffff602082901c81169591169350915050565b60006001600160e01b031982166394d008ef60e01b148061108a57506001600160e01b031982166380ac58cd60e01b145b806105a657506105a6826116a1565b60006001600160e01b0319821663a7219d9b60e01b14806110ca57506001600160e01b031982166370c8db7160e01b145b806105a657506105a682611059565b60006001600160e01b031982166393cec23d60e01b148061110a57506001600160e01b0319821663331f761f60e01b145b806105a657506105a682611099565b60606000825167ffffffffffffffff81111561113757611137611b18565b604051908082528060200260200182016040528015611160578160200160208202803683370190505b50905061116c846116f3565b15610a065760005b83518110156111d4576111a085858381518110611193576111936120ae565b6020026020010151611726565b8282815181106111b2576111b26120ae565b91151560209283029190910190910152806111cc81612112565b915050611174565b509392505050565b6000818152602081905260409020546001600160a01b03166112145760405163074fede760e51b8152600481018290526024016108d7565b6001600160a01b03821661123b5760405163671d1add60e11b815260040160405180910390fd5b6112468383836114fa565b60008181526020819052604080822080546001600160a01b0319166001600160a01b0386811691821790925591518493918716917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b6000610fb4610a2b60017fc57d320c8f1e45a5114285d6f31191434d3d45422aff570b70ab6787e45bcf00612097565b60008080611042610a2b60017f339f5f72bc92a5319eb93a988a231d1edc8fd9d738d9b83b98fdc16b8304d846612097565b67ffffffff00000000602083901b1663ffffffff8216178061134a610a2b60017f339f5f72bc92a5319eb93a988a231d1edc8fd9d738d9b83b98fdc16b8304d846612097565b55505050565b67ffffffff00000000602083901b1663ffffffff8216178061134a610a2b60017f1b3d86ed8dfe582174d4360a5614978a5ce792b2850c12fe4f73655644f0ae46612097565b60006113a06112a2565b60405163ebf03f4960e01b81523060048201526001600160a01b03919091169063ebf03f4990602401602060405180830381865afa1580156113e6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107f2919061212b565b611426610a2b60016000805160206121ef833981519152612097565b5460ff16611447576040516369be8d9360e11b815260040160405180910390fd5b6114508261180f565b6114598261181b565b6106e2816118a8565b61147e610a2b60016000805160206121ef833981519152612097565b5460ff1661149f576040516369be8d9360e11b815260040160405180910390fd5b61054d600063ffffffff611304565b6114ca610a2b60016000805160206121ef833981519152612097565b5460ff166114eb576040516369be8d9360e11b815260040160405180910390fd5b61054d600063ffffffff611350565b6115026112a2565b6001600160a01b0316336001600160a01b0316146105f75760405163323b4eed60e11b815260040160405180910390fd5b60006001600160a01b0384163b61154c57506001610901565b604051630a85bd0160e11b81526001600160a01b0385169063150b7a029061157e903390899088908890600401612148565b6020604051808303816000875af19250505080156115b9575060408051601f3d908101601f191682019092526115b69181019061217b565b60015b611621573d8080156115e7576040519150601f19603f3d011682016040523d82523d6000602084013e6115ec565b606091505b5080516000036116195760405162aae5b760e01b81526001600160a01b03861660048201526024016108d7565b805181602001fd5b6001600160e01b031916630a85bd0160e11b149050949350505050565b6060610a0683836040518060600160405280602781526020016121c860279139611914565b61166e8484846111dc565b61167a84848484611533565b610b8c5760405162aae5b760e01b81526001600160a01b03841660048201526024016108d7565b60006001600160e01b03198216630b3888fd60e31b14806116d257506001600160e01b031982166301ffc9a760e01b145b806105a657506105a6826116e4610f84565b6001600160a01b0316906119e7565b6000611706826301ffc9a760e01b611726565b80156105a6575061171f826001600160e01b0319611726565b1592915050565b604080516001600160e01b0319831660248083019190915282518083039091018152604490910182526020810180516001600160e01b03166301ffc9a760e01b179052905160009190829081906001600160a01b038716906175309061178d908690612198565b6000604051808303818686fa925050503d80600081146117c9576040519150601f19603f3d011682016040523d82523d6000602084013e6117ce565b606091505b50915091506020815110156117e957600093505050506105a6565b8180156118055750808060200190518101906118059190612014565b9695505050505050565b61181881611a03565b50565b611837610a2b60016000805160206121ef833981519152612097565b5460ff16611858576040516369be8d9360e11b815260040160405180910390fd5b80611887610a2b60017f1cd3cead3f33d5ed74fb83a237e17d126ef505cbae350d3d0ffce421e3a1d144612097565b80546001600160a01b0319166001600160a01b039290921691909117905550565b6118c4610a2b60016000805160206121ef833981519152612097565b5460ff166118e5576040516369be8d9360e11b815260040160405180910390fd5b80611887610a2b60017fc57d320c8f1e45a5114285d6f31191434d3d45422aff570b70ab6787e45bcf00612097565b60606001600160a01b0384163b61197c5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b60648201526084016108d7565b600080856001600160a01b0316856040516119979190612198565b600060405180830381855af49150503d80600081146119d2576040519150601f19603f3d011682016040523d82523d6000602084013e6119d7565b606091505b5091509150611805828286611a52565b60006119f2836116f3565b8015610a065750610a068383611726565b611a1d6001600160a01b038216635b5e139f60e01b6119e7565b6118185760405163c30175c560e01b81526001600160a01b0382166004820152635b5e139f60e01b60248201526044016108d7565b60608315611a61575081610a06565b825115611a715782518084602001fd5b8160405162461bcd60e51b81526004016108d791906121b4565b6001600160e01b03198116811461181857600080fd5b600060208284031215611ab357600080fd5b8135610a0681611a8b565b600060208284031215611ad057600080fd5b5035919050565b6001600160a01b038116811461181857600080fd5b60008060408385031215611aff57600080fd5b8235611b0a81611ad7565b946020939093013593505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611b5757611b57611b18565b604052919050565b60006020808385031215611b7257600080fd5b823567ffffffffffffffff80821115611b8a57600080fd5b818501915085601f830112611b9e57600080fd5b813581811115611bb057611bb0611b18565b8060051b9150611bc1848301611b2e565b8181529183018401918481019088841115611bdb57600080fd5b938501935b83851015611c055784359250611bf583611a8b565b8282529385019390850190611be0565b98975050505050505050565b6020808252825182820181905260009190848201906040850190845b81811015611c4b578351151583529284019291840191600101611c2d565b50909695505050505050565b600080600060608486031215611c6c57600080fd5b8335611c7781611ad7565b92506020840135611c8781611ad7565b929592945050506040919091013590565b600060208284031215611caa57600080fd5b813563ffffffff81168114610a0657600080fd5b600060208284031215611cd057600080fd5b8135610a0681611ad7565b60008060208385031215611cee57600080fd5b823567ffffffffffffffff80821115611d0657600080fd5b818501915085601f830112611d1a57600080fd5b813581811115611d2957600080fd5b866020828501011115611d3b57600080fd5b60209290920196919550909350505050565b600082601f830112611d5e57600080fd5b813567ffffffffffffffff811115611d7857611d78611b18565b611d8b601f8201601f1916602001611b2e565b818152846020838601011115611da057600080fd5b816020850160208301376000918101602001919091529392505050565b600080600060608486031215611dd257600080fd5b8335611ddd81611ad7565b925060208401359150604084013567ffffffffffffffff811115611e0057600080fd5b611e0c86828701611d4d565b9150509250925092565b801515811461181857600080fd5b60008060408385031215611e3757600080fd5b8235611e4281611ad7565b91506020830135611e5281611e16565b809150509250929050565b60008060208385031215611e7057600080fd5b823567ffffffffffffffff80821115611e8857600080fd5b818501915085601f830112611e9c57600080fd5b813581811115611eab57600080fd5b8660208260051b8501011115611d3b57600080fd5b60005b83811015611edb578181015183820152602001611ec3565b83811115610b8c5750506000910152565b60008151808452611f04816020860160208601611ec0565b601f01601f19169290920160200192915050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b82811015611f6d57603f19888603018452611f5b858351611eec565b94509285019290850190600101611f3f565b5092979650505050505050565b60008060008060808587031215611f9057600080fd5b8435611f9b81611ad7565b93506020850135611fab81611ad7565b925060408501359150606085013567ffffffffffffffff811115611fce57600080fd5b611fda87828801611d4d565b91505092959194509250565b60008060408385031215611ff957600080fd5b823561200481611ad7565b91506020830135611e5281611ad7565b60006020828403121561202657600080fd5b8151610a0681611e16565b60006020828403121561204357600080fd5b815160038110610a0657600080fd5b634e487b7160e01b600052602160045260246000fd5b60006020828403121561207a57600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b6000828210156120a9576120a9612081565b500390565b634e487b7160e01b600052603260045260246000fd5b6000808335601e198436030181126120db57600080fd5b83018035915067ffffffffffffffff8211156120f657600080fd5b60200191503681900382131561210b57600080fd5b9250929050565b60006001820161212457612124612081565b5060010190565b60006020828403121561213d57600080fd5b8151610a0681611ad7565b6001600160a01b038581168252841660208201526040810183905260806060820181905260009061180590830184611eec565b60006020828403121561218d57600080fd5b8151610a0681611a8b565b600082516121aa818460208701611ec0565b9190910192915050565b602081526000610a066020830184611eec56fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564c2221768d9692f01d28cc433c84b2dc197fbcc867663b61d61e17ca4877697faa26469706673582212207d09cba5a8a1577f553849ac436d9825d1ff9317da8f5b94604115b777c6071864736f6c634300080d0033",
  "deployedBytecode": "0x60806040526004361061019f5760003560e01c80638993dafd116100ec578063b88d4fde1161008a578063e846a5a911610064578063e846a5a9146104d6578063e985e9c5146104f8578063f46c73c614610513578063ffd5b31714610528576101ae565b8063b88d4fde14610481578063c566b080146104a1578063d1958f2c146104c1576101ae565b8063986e9115116100c6578063986e91151461040f578063a22cb46514610424578063ab9a8dcd1461043f578063ac9650d814610454576101ae565b80638993dafd146103af5780638d796a37146103cf57806394d008ef146103ef576101ae565b80632a58f7ac116101595780635a70a283116101335780635a70a283146103225780635e88e74a146103375780636352211e1461036157806370a0823114610381576101ae565b80632a58f7ac146102c257806342842e0e146102e257806356a872bd14610302576101ae565b8062eb6ac7146101b657806301ffc9a7146101ed578063081812fc1461021d578063095ea7b3146102555780631f9e33041461027557806323b872dd146102a2576101ae565b366101ae576101ac61053d565b005b6101ac61053d565b3480156101c257600080fd5b506101cb61054f565b6040805163ffffffff9384168152929091166020830152015b60405180910390f35b3480156101f957600080fd5b5061020d610208366004611aa1565b610563565b60405190151581526020016101e4565b34801561022957600080fd5b5061023d610238366004611abe565b6105ac565b6040516001600160a01b0390911681526020016101e4565b34801561026157600080fd5b506101ac610270366004611aec565b6105c7565b34801561028157600080fd5b50610295610290366004611b5f565b6105e0565b6040516101e49190611c11565b3480156102ae57600080fd5b506101ac6102bd366004611c57565b6105ec565b3480156102ce57600080fd5b506101ac6102dd366004611c98565b6105fc565b3480156102ee57600080fd5b506101ac6102fd366004611c57565b6106e6565b34801561030e57600080fd5b506101ac61031d366004611c98565b610701565b34801561032e57600080fd5b5061023d6107e8565b34801561034357600080fd5b5061034c6107f7565b60405163ffffffff90911681526020016101e4565b34801561036d57600080fd5b5061023d61037c366004611abe565b610809565b34801561038d57600080fd5b506103a161039c366004611cbe565b610944565b6040519081526020016101e4565b3480156103bb57600080fd5b506101ac6103ca366004611cdb565b610a0d565b3480156103db57600080fd5b506101ac6103ea366004611c98565b610b92565b3480156103fb57600080fd5b506101ac61040a366004611dbd565b610c78565b34801561041b57600080fd5b5061034c610d6d565b34801561043057600080fd5b506101ac610270366004611e24565b34801561044b57600080fd5b5061034c610d78565b34801561046057600080fd5b5061047461046f366004611e5d565b610d83565b6040516101e49190611f18565b34801561048d57600080fd5b506101ac61049c366004611f7a565b610e71565b3480156104ad57600080fd5b506101ac6104bc366004611c98565b610e7d565b3480156104cd57600080fd5b506101cb610f64565b3480156104e257600080fd5b506040516339d690a360e11b81526020016101e4565b34801561050457600080fd5b5061020d610238366004611fe6565b34801561051f57600080fd5b5061023d610f6f565b34801561053457600080fd5b5061034c610f79565b61054d610548610f84565b610fc3565b565b60008061055a611010565b90939092509050565b60006001600160e01b03198216638993dafd60e01b1480610588575061058882611059565b80610597575061059782611099565b806105a657506105a6826110d9565b92915050565b60006040516341f8b8eb60e11b815260040160405180910390fd5b6040516341f8b8eb60e11b815260040160405180910390fd5b60606105a63083611119565b6105f78383836111dc565b505050565b6106046112a2565b6001600160a01b031663882080d330336040516001600160e01b031960e085901b1681526001600160a01b03928316600482015291166024820152604401602060405180830381865afa15801561065f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106839190612014565b61069f57604051621c9ee960e91b815260040160405180910390fd5b60006106a96112d2565b9150508063ffffffff168263ffffffff16106106d85760405163e652891d60e01b815260040160405180910390fd5b6106e28282611304565b5050565b6105f783838360405180602001604052806000815250610e71565b6107096112a2565b6001600160a01b031663882080d330336040516001600160e01b031960e085901b1681526001600160a01b03928316600482015291166024820152604401602060405180830381865afa158015610764573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107889190612014565b6107a457604051621c9ee960e91b815260040160405180910390fd5b60006107ae611010565b9150508063ffffffff168263ffffffff1611156107de5760405163dea1d81f60e01b815260040160405180910390fd5b6106e28282611350565b60006107f26112a2565b905090565b6000806108026112d2565b5092915050565b600080610814611396565b90506000816001600160a01b0316633f09518c61082f6112a2565b6040516001600160e01b031960e084901b1681526001600160a01b03909116600482015230602482015260448101879052606401602060405180830381865afa158015610880573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108a49190612031565b905060008160028111156108ba576108ba612052565b036108e05760405163e4c0734760e01b8152600481018590526024015b60405180910390fd5b60018160028111156108f4576108f4612052565b03610909576109016112a2565b949350505050565b50506000828152602081905260409020546001600160a01b0316806105a65760405163e4c0734760e01b8152600481018490526024016108d7565b60006001600160a01b03821661096d576040516323d3ad8160e21b815260040160405180910390fd5b6000610977611396565b9050806001600160a01b031663bfe0af996109906112a2565b6040516001600160e01b031960e084901b1681526001600160a01b0391821660048201523060248201529086166044820152606401602060405180830381865afa1580156109e2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a069190612068565b9392505050565b6000610a2e610a2b60016000805160206121ef833981519152612097565b90565b5460ff16610a6e57610a64610a2b60017f37e69e8e563db672cb7e105d3e1915d10ef53975d285d458a13e70818bf53d27612097565b5460ff1615610a72565b303b155b1590508015610a935760405162ea7fe560e71b815260040160405180910390fd5b6000610ab1610a2b60016000805160206121ef833981519152612097565b5460ff161590508015610b29576001610adb610a2b826000805160206121ef833981519152612097565b805460ff19169115159190911790556001610b19610a2b827f37e69e8e563db672cb7e105d3e1915d10ef53975d285d458a13e70818bf53d27612097565b805460ff19169115159190911790555b600080610b3885870187611fe6565b91509150610b46828261140a565b610b4e611462565b610b566114ae565b50508015610b8c576000610b7c610a2b60016000805160206121ef833981519152612097565b805460ff19169115159190911790555b50505050565b610b9a6112a2565b6001600160a01b031663882080d330336040516001600160e01b031960e085901b1681526001600160a01b03928316600482015291166024820152604401602060405180830381865afa158015610bf5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c199190612014565b610c3557604051621c9ee960e91b815260040160405180910390fd5b6000610c3f6112d2565b5090508163ffffffff168163ffffffff1610610c6e57604051636b97294960e11b815260040160405180910390fd5b6106e28183611304565b6001600160a01b038316610c9f5760405163c96c2a0b60e01b815260040160405180910390fd5b6000828152602081905260409020546001600160a01b031615610cd8576040516376b78f6560e01b8152600481018390526024016108d7565b610ce4600084846114fa565b60008281526020819052604080822080546001600160a01b0319166001600160a01b03871690811790915590518492907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a4610d466000848484611533565b6105f75760405162aae5b760e01b81526001600160a01b03841660048201526024016108d7565b600080610a06611010565b600080610802611010565b60608167ffffffffffffffff811115610d9e57610d9e611b18565b604051908082528060200260200182016040528015610dd157816020015b6060815260200190600190039081610dbc5790505b50905060005b8281101561080257610e4130858584818110610df557610df56120ae565b9050602002810190610e0791906120c4565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061163e92505050565b828281518110610e5357610e536120ae565b60200260200101819052508080610e6990612112565b915050610dd7565b610b8c84848484611663565b610e856112a2565b6001600160a01b031663882080d330336040516001600160e01b031960e085901b1681526001600160a01b03928316600482015291166024820152604401602060405180830381865afa158015610ee0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f049190612014565b610f2057604051621c9ee960e91b815260040160405180910390fd5b6000610f2a611010565b5090508163ffffffff168163ffffffff161115610f5a5760405163077f3cbd60e11b815260040160405180910390fd5b6106e28183611350565b60008061055a6112d2565b60006107f2610f84565b600080610a066112d2565b6000610fb4610a2b60017f1cd3cead3f33d5ed74fb83a237e17d126ef505cbae350d3d0ffce421e3a1d144612097565b546001600160a01b0316919050565b6001600160a01b038116610fea5760405163eb0308d160e01b815260040160405180910390fd5b34366000803760008036600084865af13d6000803e80801561100b573d6000f35b3d6000fd5b60008080611042610a2b60017f1b3d86ed8dfe582174d4360a5614978a5ce792b2850c12fe4f73655644f0ae46612097565b5463ffffffff602082901c81169591169350915050565b60006001600160e01b031982166394d008ef60e01b148061108a57506001600160e01b031982166380ac58cd60e01b145b806105a657506105a6826116a1565b60006001600160e01b0319821663a7219d9b60e01b14806110ca57506001600160e01b031982166370c8db7160e01b145b806105a657506105a682611059565b60006001600160e01b031982166393cec23d60e01b148061110a57506001600160e01b0319821663331f761f60e01b145b806105a657506105a682611099565b60606000825167ffffffffffffffff81111561113757611137611b18565b604051908082528060200260200182016040528015611160578160200160208202803683370190505b50905061116c846116f3565b15610a065760005b83518110156111d4576111a085858381518110611193576111936120ae565b6020026020010151611726565b8282815181106111b2576111b26120ae565b91151560209283029190910190910152806111cc81612112565b915050611174565b509392505050565b6000818152602081905260409020546001600160a01b03166112145760405163074fede760e51b8152600481018290526024016108d7565b6001600160a01b03821661123b5760405163671d1add60e11b815260040160405180910390fd5b6112468383836114fa565b60008181526020819052604080822080546001600160a01b0319166001600160a01b0386811691821790925591518493918716917fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef91a4505050565b6000610fb4610a2b60017fc57d320c8f1e45a5114285d6f31191434d3d45422aff570b70ab6787e45bcf00612097565b60008080611042610a2b60017f339f5f72bc92a5319eb93a988a231d1edc8fd9d738d9b83b98fdc16b8304d846612097565b67ffffffff00000000602083901b1663ffffffff8216178061134a610a2b60017f339f5f72bc92a5319eb93a988a231d1edc8fd9d738d9b83b98fdc16b8304d846612097565b55505050565b67ffffffff00000000602083901b1663ffffffff8216178061134a610a2b60017f1b3d86ed8dfe582174d4360a5614978a5ce792b2850c12fe4f73655644f0ae46612097565b60006113a06112a2565b60405163ebf03f4960e01b81523060048201526001600160a01b03919091169063ebf03f4990602401602060405180830381865afa1580156113e6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107f2919061212b565b611426610a2b60016000805160206121ef833981519152612097565b5460ff16611447576040516369be8d9360e11b815260040160405180910390fd5b6114508261180f565b6114598261181b565b6106e2816118a8565b61147e610a2b60016000805160206121ef833981519152612097565b5460ff1661149f576040516369be8d9360e11b815260040160405180910390fd5b61054d600063ffffffff611304565b6114ca610a2b60016000805160206121ef833981519152612097565b5460ff166114eb576040516369be8d9360e11b815260040160405180910390fd5b61054d600063ffffffff611350565b6115026112a2565b6001600160a01b0316336001600160a01b0316146105f75760405163323b4eed60e11b815260040160405180910390fd5b60006001600160a01b0384163b61154c57506001610901565b604051630a85bd0160e11b81526001600160a01b0385169063150b7a029061157e903390899088908890600401612148565b6020604051808303816000875af19250505080156115b9575060408051601f3d908101601f191682019092526115b69181019061217b565b60015b611621573d8080156115e7576040519150601f19603f3d011682016040523d82523d6000602084013e6115ec565b606091505b5080516000036116195760405162aae5b760e01b81526001600160a01b03861660048201526024016108d7565b805181602001fd5b6001600160e01b031916630a85bd0160e11b149050949350505050565b6060610a0683836040518060600160405280602781526020016121c860279139611914565b61166e8484846111dc565b61167a84848484611533565b610b8c5760405162aae5b760e01b81526001600160a01b03841660048201526024016108d7565b60006001600160e01b03198216630b3888fd60e31b14806116d257506001600160e01b031982166301ffc9a760e01b145b806105a657506105a6826116e4610f84565b6001600160a01b0316906119e7565b6000611706826301ffc9a760e01b611726565b80156105a6575061171f826001600160e01b0319611726565b1592915050565b604080516001600160e01b0319831660248083019190915282518083039091018152604490910182526020810180516001600160e01b03166301ffc9a760e01b179052905160009190829081906001600160a01b038716906175309061178d908690612198565b6000604051808303818686fa925050503d80600081146117c9576040519150601f19603f3d011682016040523d82523d6000602084013e6117ce565b606091505b50915091506020815110156117e957600093505050506105a6565b8180156118055750808060200190518101906118059190612014565b9695505050505050565b61181881611a03565b50565b611837610a2b60016000805160206121ef833981519152612097565b5460ff16611858576040516369be8d9360e11b815260040160405180910390fd5b80611887610a2b60017f1cd3cead3f33d5ed74fb83a237e17d126ef505cbae350d3d0ffce421e3a1d144612097565b80546001600160a01b0319166001600160a01b039290921691909117905550565b6118c4610a2b60016000805160206121ef833981519152612097565b5460ff166118e5576040516369be8d9360e11b815260040160405180910390fd5b80611887610a2b60017fc57d320c8f1e45a5114285d6f31191434d3d45422aff570b70ab6787e45bcf00612097565b60606001600160a01b0384163b61197c5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f6044820152651b9d1c9858dd60d21b60648201526084016108d7565b600080856001600160a01b0316856040516119979190612198565b600060405180830381855af49150503d80600081146119d2576040519150601f19603f3d011682016040523d82523d6000602084013e6119d7565b606091505b5091509150611805828286611a52565b60006119f2836116f3565b8015610a065750610a068383611726565b611a1d6001600160a01b038216635b5e139f60e01b6119e7565b6118185760405163c30175c560e01b81526001600160a01b0382166004820152635b5e139f60e01b60248201526044016108d7565b60608315611a61575081610a06565b825115611a715782518084602001fd5b8160405162461bcd60e51b81526004016108d791906121b4565b6001600160e01b03198116811461181857600080fd5b600060208284031215611ab357600080fd5b8135610a0681611a8b565b600060208284031215611ad057600080fd5b5035919050565b6001600160a01b038116811461181857600080fd5b60008060408385031215611aff57600080fd5b8235611b0a81611ad7565b946020939093013593505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611b5757611b57611b18565b604052919050565b60006020808385031215611b7257600080fd5b823567ffffffffffffffff80821115611b8a57600080fd5b818501915085601f830112611b9e57600080fd5b813581811115611bb057611bb0611b18565b8060051b9150611bc1848301611b2e565b8181529183018401918481019088841115611bdb57600080fd5b938501935b83851015611c055784359250611bf583611a8b565b8282529385019390850190611be0565b98975050505050505050565b6020808252825182820181905260009190848201906040850190845b81811015611c4b578351151583529284019291840191600101611c2d565b50909695505050505050565b600080600060608486031215611c6c57600080fd5b8335611c7781611ad7565b92506020840135611c8781611ad7565b929592945050506040919091013590565b600060208284031215611caa57600080fd5b813563ffffffff81168114610a0657600080fd5b600060208284031215611cd057600080fd5b8135610a0681611ad7565b60008060208385031215611cee57600080fd5b823567ffffffffffffffff80821115611d0657600080fd5b818501915085601f830112611d1a57600080fd5b813581811115611d2957600080fd5b866020828501011115611d3b57600080fd5b60209290920196919550909350505050565b600082601f830112611d5e57600080fd5b813567ffffffffffffffff811115611d7857611d78611b18565b611d8b601f8201601f1916602001611b2e565b818152846020838601011115611da057600080fd5b816020850160208301376000918101602001919091529392505050565b600080600060608486031215611dd257600080fd5b8335611ddd81611ad7565b925060208401359150604084013567ffffffffffffffff811115611e0057600080fd5b611e0c86828701611d4d565b9150509250925092565b801515811461181857600080fd5b60008060408385031215611e3757600080fd5b8235611e4281611ad7565b91506020830135611e5281611e16565b809150509250929050565b60008060208385031215611e7057600080fd5b823567ffffffffffffffff80821115611e8857600080fd5b818501915085601f830112611e9c57600080fd5b813581811115611eab57600080fd5b8660208260051b8501011115611d3b57600080fd5b60005b83811015611edb578181015183820152602001611ec3565b83811115610b8c5750506000910152565b60008151808452611f04816020860160208601611ec0565b601f01601f19169290920160200192915050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b82811015611f6d57603f19888603018452611f5b858351611eec565b94509285019290850190600101611f3f565b5092979650505050505050565b60008060008060808587031215611f9057600080fd5b8435611f9b81611ad7565b93506020850135611fab81611ad7565b925060408501359150606085013567ffffffffffffffff811115611fce57600080fd5b611fda87828801611d4d565b91505092959194509250565b60008060408385031215611ff957600080fd5b823561200481611ad7565b91506020830135611e5281611ad7565b60006020828403121561202657600080fd5b8151610a0681611e16565b60006020828403121561204357600080fd5b815160038110610a0657600080fd5b634e487b7160e01b600052602160045260246000fd5b60006020828403121561207a57600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b6000828210156120a9576120a9612081565b500390565b634e487b7160e01b600052603260045260246000fd5b6000808335601e198436030181126120db57600080fd5b83018035915067ffffffffffffffff8211156120f657600080fd5b60200191503681900382131561210b57600080fd5b9250929050565b60006001820161212457612124612081565b5060010190565b60006020828403121561213d57600080fd5b8151610a0681611ad7565b6001600160a01b038581168252841660208201526040810183905260806060820181905260009061180590830184611eec565b60006020828403121561218d57600080fd5b8151610a0681611a8b565b600082516121aa818460208701611ec0565b9190910192915050565b602081526000610a066020830184611eec56fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564c2221768d9692f01d28cc433c84b2dc197fbcc867663b61d61e17ca4877697faa26469706673582212207d09cba5a8a1577f553849ac436d9825d1ff9317da8f5b94604115b777c6071864736f6c634300080d0033",
  "devdoc": {
    "errors": {
      "CallForwardToZeroAddress()": [
        {
          "details": "Thrown when a call is forwarded to a zero address."
        }
      ],
      "CallerIsNotMetahub()": [
        {
          "details": "Thrown when the message sender doesn't match the Metahub address."
        }
      ],
      "CallerIsNotWarperAdmin()": [
        {
          "details": "Thrown when the message sender doesn't match the warper admin address."
        }
      ],
      "ContractIsAlreadyInitialized()": [
        {
          "details": "Thrown upon attempt to initialize a contract again."
        }
      ],
      "ContractIsNotInitializing()": [
        {
          "details": "Thrown when a function is invoked outside of initialization transaction."
        }
      ],
      "InvalidAvailabilityPeriodEnd()": [
        {
          "details": "Thrown when the availability period end time is not greater or equal than the start time"
        }
      ],
      "InvalidAvailabilityPeriodStart()": [
        {
          "details": "Thrown when the availability period start time is not strictly lesser than the end time"
        }
      ],
      "InvalidMaxRentalPeriod()": [
        {
          "details": "Thrown when the max rental period is not greater or equal than min rental period"
        }
      ],
      "InvalidMinRentalPeriod()": [
        {
          "details": "Thrown when the the min rental period is not strictly lesser than max rental period"
        }
      ],
      "InvalidOriginalTokenInterface(address,bytes4)": [
        {
          "details": "Thrown when the original asset contract does not implement the interface, expected by Warper."
        }
      ],
      "WarperIsNotAvailableForRenting(uint256,uint32,uint32)": [
        {
          "details": "Thrown when the current time is not withing the warper availability period."
        }
      ],
      "WarperRentalPeriodIsOutOfRange(uint32,uint32,uint32)": [
        {
          "details": "Thrown when the requested rental period is not withing the warper allowed rental period range."
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "__assetClass()": {
        "details": "Returns the warper asset class ID."
      },
      "__availabilityPeriodEnd()": {
        "details": "Returns warper availability period ending time.",
        "returns": {
          "_0": "Unix timestamp after which the warper is NOT rentable."
        }
      },
      "__availabilityPeriodRange()": {
        "details": "Returns warper availability period.",
        "returns": {
          "availabilityPeriodEnd": "Unix timestamp after which the warper is NOT rentable.",
          "availabilityPeriodStart": "Unix timestamp after which the warper is rentable."
        }
      },
      "__availabilityPeriodStart()": {
        "details": "Returns warper availability period starting time.",
        "returns": {
          "_0": "Unix timestamp after which the warper is rentable."
        }
      },
      "__initialize(bytes)": {
        "details": "Warper generic initialization method.",
        "params": {
          "config": "Warper configuration parameters."
        }
      },
      "__maxRentalPeriod()": {
        "details": "Returns warper maximal rental period.",
        "returns": {
          "_0": "Time is seconds."
        }
      },
      "__metahub()": {
        "details": "Returns the Metahub address."
      },
      "__minRentalPeriod()": {
        "details": "Returns warper minimal rental period.",
        "returns": {
          "_0": "Time is seconds."
        }
      },
      "__original()": {
        "details": "Returns the original NFT address."
      },
      "__rentalPeriodRange()": {
        "details": "Returns warper rental period range.",
        "returns": {
          "maxRentalPeriod": "The maximal amount of time the warper can be rented for.",
          "minRentalPeriod": "The minimal amount of time the warper can be rented for."
        }
      },
      "__setAvailabilityPeriodEnd(uint32)": {
        "details": "Sets warper availability period ending time.",
        "params": {
          "availabilityPeriodEnd": "Unix timestamp after which the warper is NOT rentable."
        }
      },
      "__setAvailabilityPeriodStart(uint32)": {
        "details": "Sets warper availability period starting time.",
        "params": {
          "availabilityPeriodStart": "Unix timestamp after which the warper is rentable."
        }
      },
      "__setMaxRentalPeriod(uint32)": {
        "details": "Sets warper max rental period.",
        "params": {
          "maxRentalPeriod": "New max rental period value."
        }
      },
      "__setMinRentalPeriod(uint32)": {
        "details": "Sets warper min rental period.",
        "params": {
          "minRentalPeriod": "New min rental period value."
        }
      },
      "__supportedInterfaces(bytes4[])": {
        "details": "Validates if a warper supports multiple interfaces at once.",
        "returns": {
          "_0": "an array of `bool` flags in order as the `interfaceIds` were passed."
        }
      },
      "approve(address,uint256)": {
        "details": "Method is disabled, kept only for interface compatibility purposes."
      },
      "balanceOf(address)": {
        "details": "The rental count calculations get offloaded to the Metahub"
      },
      "getApproved(uint256)": {
        "details": "Method is disabled, kept only for interface compatibility purposes."
      },
      "isApprovedForAll(address,address)": {
        "details": "Method is disabled, kept only for interface compatibility purposes."
      },
      "mint(address,uint256,bytes)": {
        "details": "Safely mints `tokenId` and transfers it to `to`. Requirements: - needs to pass validation of `_beforeTokenTransfer()`. - `tokenId` must not exist. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."
      },
      "multicall(bytes[])": {
        "details": "Receives and executes a batch of function calls on this contract."
      },
      "ownerOf(uint256)": {
        "details": "The ownership is dependant on the rental status - metahub is      responsible for tracking the state:          - NONE: revert with an error          - AVAILABLE: means, that the token is not currently rented. Metahub is the owner.          - RENTED: Use the Warpers internal ownership constructs"
      },
      "safeTransferFrom(address,address,uint256)": {
        "details": "Need to fulfill all the requirements of `_transfer()`"
      },
      "safeTransferFrom(address,address,uint256,bytes)": {
        "details": "Need to fulfill all the requirements of `_transfer()`"
      },
      "setApprovalForAll(address,bool)": {
        "details": "Method is disabled, kept only for interface compatibility purposes."
      },
      "supportsInterface(bytes4)": {
        "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
      },
      "transferFrom(address,address,uint256)": {
        "details": "Need to fulfill all the requirements of `_transfer()`"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 15769,
        "contract": "contracts/warper/ERC721/presets/ERC721PresetConfigurable.sol:ERC721PresetConfigurable",
        "label": "_owners",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_address)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}