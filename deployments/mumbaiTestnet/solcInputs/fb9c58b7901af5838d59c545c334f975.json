{
  "language": "Solidity",
  "sources": {
    "contracts/accounting/Accounts.sol": {
      "content": "// solhint-disable private-vars-leading-underscore\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableMapUpgradeable.sol\";\nimport \"../renting/Rentings.sol\";\nimport \"../universe/IUniverseRegistry.sol\";\nimport \"../listing/Listings.sol\";\nimport \"./IPaymentManager.sol\";\n\nlibrary Accounts {\n    using Accounts for Account;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using EnumerableMapUpgradeable for EnumerableMapUpgradeable.AddressToUintMap;\n\n    /**\n     * @dev Thrown when the estimated rental fee calculated upon renting\n     * is higher than maximal payment amount the renter is willing to pay.\n     */\n    error RentalFeeSlippage();\n\n    /**\n     * @dev Thrown when the amount requested to be paid out is not valid.\n     */\n    error InvalidWithdrawalAmount(uint256 amount);\n\n    /**\n     * @dev Thrown when the amount requested to be paid out is larger than available balance.\n     */\n    error InsufficientBalance(uint256 balance);\n\n    /**\n     * @dev A structure that describes account balance in ERC20 tokens.\n     */\n    struct Balance {\n        address token;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Describes an account state.\n     * @param tokenBalances Mapping from an ERC20 token address to the amount.\n     */\n    struct Account {\n        EnumerableMapUpgradeable.AddressToUintMap tokenBalances;\n    }\n\n    /**\n     * @dev Transfers funds from the account balance to the specific address after validating balance sufficiency.\n     */\n    function withdraw(\n        Account storage self,\n        address token,\n        uint256 amount,\n        address to\n    ) external {\n        if (amount == 0) revert InvalidWithdrawalAmount(amount);\n        uint256 currentBalance = self.balance(token);\n        if (amount > currentBalance) revert InsufficientBalance(currentBalance);\n        unchecked {\n            self.tokenBalances.set(token, currentBalance - amount);\n        }\n        IERC20Upgradeable(token).safeTransfer(to, amount);\n    }\n\n    struct UserEarning {\n        IPaymentManager.EarningType earningType;\n        address account;\n        uint256 value;\n        address token;\n    }\n\n    struct RentalEarnings {\n        UserEarning[] userEarnings;\n        // Universe\n        uint256 universeId;\n        uint256 universeEarningValue;\n        address universeEarningToken;\n        // Protocol\n        uint256 protocolEarningValue;\n        address protocolEarningToken;\n    }\n\n    function handleRentalPayment(\n        Accounts.Registry storage self,\n        Rentings.Params calldata rentingParams,\n        Rentings.RentalFees calldata fees,\n        address payer,\n        uint256 maxPaymentAmount,\n        IWarperManager warperManager,\n        Listings.Registry storage listingRegistry\n    ) external returns (RentalEarnings memory earnings) {\n        // Ensure no rental fee payment slippage.\n        if (fees.total > maxPaymentAmount) revert RentalFeeSlippage();\n\n        // The amount of payment tokens to be accumulated on the Metahub for future payouts.\n        // This will include all fees which are not being paid out immediately.\n        uint256 accumulatedTokens = 0;\n\n        // Initialize user earnings array. Currently we only support earnings for single user, who is the lister.\n        earnings.userEarnings = new UserEarning[](1);\n\n        // Handle lister fee component.\n        Listings.Listing storage listing = listingRegistry.listings[rentingParams.listingId];\n        UserEarning memory listerEarning = UserEarning({\n            earningType: IPaymentManager.EarningType.LISTER_FEE,\n            account: listing.lister,\n            value: fees.listerBaseFee + fees.listerPremium,\n            token: rentingParams.paymentToken\n        });\n        earnings.userEarnings[0] = listerEarning;\n\n        // If the lister has not requested immediate payout, the earned amount is added to the lister balance.\n        // The direct payout case is handled along with other transfers later.\n        if (!listing.immediatePayout) {\n            self.users[listerEarning.account].increaseBalance(listerEarning.token, listerEarning.value);\n            accumulatedTokens += listerEarning.value;\n        }\n\n        // Handle universe fee component.\n        earnings.universeId = warperManager.warperInfo(rentingParams.warper).universeId;\n        earnings.universeEarningValue = fees.universeBaseFee + fees.universePremium;\n        earnings.universeEarningToken = rentingParams.paymentToken;\n        // Increase universe balance.\n        self.universes[earnings.universeId].increaseBalance(\n            earnings.universeEarningToken,\n            earnings.universeEarningValue\n        );\n        accumulatedTokens += earnings.universeEarningValue;\n\n        // Handle protocol fee component.\n        earnings.protocolEarningValue = fees.protocolFee;\n        earnings.protocolEarningToken = rentingParams.paymentToken;\n        self.protocol.increaseBalance(earnings.protocolEarningToken, earnings.protocolEarningValue);\n        accumulatedTokens += earnings.protocolEarningValue;\n\n        // Proceed with transfers.\n        // If immediate payout requested, transfer the lister earnings directly to the lister account.\n        if (listing.immediatePayout && listerEarning.value > 0) {\n            IERC20Upgradeable(listerEarning.token).safeTransferFrom(payer, listerEarning.account, listerEarning.value);\n        }\n\n        // Transfer the accumulated token amount from payer to the metahub.\n        if (accumulatedTokens > 0) {\n            IERC20Upgradeable(rentingParams.paymentToken).safeTransferFrom(payer, address(this), accumulatedTokens);\n        }\n    }\n\n    /**\n     * @dev Increments value of the particular account balance.\n     */\n    function increaseBalance(\n        Account storage self,\n        address token,\n        uint256 amount\n    ) internal {\n        uint256 currentBalance = self.balance(token);\n        self.tokenBalances.set(token, currentBalance + amount);\n    }\n\n    /**\n     * @dev Returns account current balance.\n     * Does not revert if `token` is not in the map.\n     */\n    function balance(Account storage self, address token) internal view returns (uint256) {\n        (, uint256 value) = self.tokenBalances.tryGet(token);\n        return value;\n    }\n\n    /**\n     * @dev Returns the list of account balances in various tokens.\n     */\n    function balances(Account storage self) internal view returns (Balance[] memory) {\n        uint256 length = self.tokenBalances.length();\n        Balance[] memory allBalances = new Balance[](length);\n        for (uint256 i = 0; i < length; i++) {\n            (address token, uint256 amount) = self.tokenBalances.at(i);\n            allBalances[i] = Balance({token: token, amount: amount});\n        }\n        return allBalances;\n    }\n\n    /**\n     * @dev Account registry.\n     * @param protocol The protocol account state.\n     * @param universes Mapping from a universe ID to the universe account state.\n     * @param users Mapping from a user address to the account state.\n     */\n    struct Registry {\n        Account protocol;\n        mapping(uint256 => Account) universes;\n        mapping(address => Account) users;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableMapUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableMap.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./EnumerableSetUpgradeable.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`) since v4.6.0\n */\nlibrary EnumerableMapUpgradeable {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSetUpgradeable.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        AddressToUintMap storage map,\n        address key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n}\n"
    },
    "contracts/renting/Rentings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../asset/Assets.sol\";\nimport \"../metahub/Protocol.sol\";\nimport \"../listing/Listings.sol\";\nimport \"../warper/Warpers.sol\";\nimport \"../universe/IUniverseRegistry.sol\";\n\nlibrary Rentings {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n    using Rentings for RenterInfo;\n    using Rentings for Agreement;\n    using Rentings for Registry;\n    using Assets for Assets.AssetId;\n    using Protocol for Protocol.Config;\n    using Listings for Listings.Registry;\n    using Listings for Listings.Listing;\n    using Warpers for Warpers.Registry;\n    using Warpers for Warpers.Warper;\n\n    /**\n     * A constant that represents one hundred percent for calculation.\n     * This defines a calculation precision for percentage values as two decimals.\n     * For example: 1 is 0.01%, 100 is 1%, 10_000 is 100%.\n     */\n    uint16 public constant HUNDRED_PERCENT = 10_000;\n\n    /**\n     * @dev Thrown when a rental agreement is being registered for a specific warper ID,\n     * while the previous rental agreement for this warper is still effective.\n     */\n    error RentalAgreementConflict(uint256 conflictingRentalId);\n\n    /**\n     * @dev Thrown when attempting to delete effective rental agreement data (before expiration).\n     */\n    error CannotDeleteEffectiveRentalAgreement(uint256 rentalId);\n\n    /**\n     * @dev Warper rental status.\n     * NONE - means the warper had never been minted.\n     * AVAILABLE - can be rented.\n     * RENTED - currently rented.\n     */\n    enum RentalStatus {\n        NONE,\n        AVAILABLE,\n        RENTED\n    }\n\n    /**\n     * @dev Defines the maximal allowed number of cycles when looking for expired rental agreements.\n     */\n    uint256 private constant _GC_CYCLES = 20;\n\n    /**\n     * @dev Rental fee breakdown.\n     */\n    struct RentalFees {\n        uint256 total;\n        uint256 protocolFee;\n        uint256 listerBaseFee;\n        uint256 listerPremium;\n        uint256 universeBaseFee;\n        uint256 universePremium;\n    }\n\n    /**\n     * @dev Renting parameters structure.\n     * It is used to encode all the necessary information to estimate and/or fulfill a particular renting request.\n     * @param listingId Listing ID. Also allows to identify the asset being rented.\n     * @param warper Warper address.\n     * @param renter Renter address.\n     * @param rentalPeriod Desired period of asset renting.\n     * @param paymentToken The token address which renter offers as a mean of payment.\n     */\n    struct Params {\n        uint256 listingId;\n        address warper;\n        address renter;\n        uint32 rentalPeriod;\n        address paymentToken;\n    }\n\n    /**\n     * @dev Rental agreement information.\n     * @param warpedAsset Rented asset.\n     * @param collectionId Warped collection ID.\n     * @param listingId The corresponding ID of the original asset listing.\n     * @param renter The renter account address.\n     * @param startTime The rental agreement staring time. This is the timestamp after which the `renter`\n     * considered to be an warped asset owner.\n     * @param endTime The rental agreement ending time. After this timestamp, the rental agreement is terminated\n     * and the `renter` is no longer the owner of the warped asset.\n     * @param listingParams Selected listing parameters.\n     */\n    struct Agreement {\n        // slots 0-2\n        Assets.Asset warpedAsset;\n        // slot 3\n        bytes32 collectionId;\n        // slot 4\n        uint256 listingId;\n        // slot 5 (4 bytes left)\n        address renter;\n        uint32 startTime;\n        uint32 endTime;\n        // slots 6-7\n        Listings.Params listingParams;\n    }\n\n    function isEffective(Agreement storage self) internal view returns (bool) {\n        return self.endTime > uint32(block.timestamp);\n    }\n\n    function duration(Agreement memory self) internal pure returns (uint32) {\n        return self.endTime - self.startTime;\n    }\n\n    /**\n     * @dev Describes user specific renting information.\n     * @param rentalIndex Renter's set of rental agreement IDs.\n     * @param collectionRentalIndex Mapping from collection ID to the set of rental IDs.\n     */\n    struct RenterInfo {\n        EnumerableSetUpgradeable.UintSet rentalIndex;\n        mapping(bytes32 => EnumerableSetUpgradeable.UintSet) collectionRentalIndex;\n    }\n\n    /**\n     * @dev Describes asset specific renting information.\n     * @param latestRentalId Holds the most recent rental agreement ID.\n     */\n    struct AssetInfo {\n        uint256 latestRentalId; // NOTE: This must never be deleted during cleanup.\n    }\n\n    /**\n     * @dev Renting registry.\n     * @param idTracker Rental agreement ID tracker (incremental counter).\n     * @param agreements Mapping from rental ID to the rental agreement details.\n     * @param renters Mapping from renter address to the user specific renting info.\n     * @param assets Mapping from asset ID (byte32) to the asset specific renting info.\n     */\n    struct Registry {\n        CountersUpgradeable.Counter idTracker;\n        mapping(uint256 => Agreement) agreements;\n        mapping(address => RenterInfo) renters;\n        mapping(bytes32 => AssetInfo) assets;\n    }\n\n    /**\n     * @dev Returns the number of currently registered rental agreements for particular renter account.\n     */\n    function userRentalCount(Registry storage self, address renter) internal view returns (uint256) {\n        return self.renters[renter].rentalIndex.length();\n    }\n\n    /**\n     * @dev Returns the paginated list of currently registered rental agreements for particular renter account.\n     */\n    function userRentalAgreements(\n        Registry storage self,\n        address renter,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Rentings.Agreement[] memory) {\n        EnumerableSetUpgradeable.UintSet storage userRentalIndex = self.renters[renter].rentalIndex;\n        uint256 indexSize = userRentalIndex.length();\n        if (offset >= indexSize) return (new uint256[](0), new Rentings.Agreement[](0));\n\n        if (limit > indexSize - offset) {\n            limit = indexSize - offset;\n        }\n\n        Rentings.Agreement[] memory agreements = new Rentings.Agreement[](limit);\n        uint256[] memory rentalIds = new uint256[](limit);\n        for (uint256 i = 0; i < limit; i++) {\n            rentalIds[i] = userRentalIndex.at(offset + i);\n            agreements[i] = self.agreements[rentalIds[i]];\n        }\n\n        return (rentalIds, agreements);\n    }\n\n    /**\n     * @dev Finds expired user rental agreements associated with `collectionId` and deletes them.\n     * Deletes only first N entries defined by `toBeRemoved` param.\n     * The total number of cycles is capped by GC_CYCLES constant.\n     */\n    function deleteExpiredUserRentalAgreements(\n        Registry storage self,\n        address renter,\n        bytes32 collectionId,\n        uint256 toBeRemoved\n    ) external {\n        EnumerableSetUpgradeable.UintSet storage rentalIndex = self.renters[renter].collectionRentalIndex[collectionId];\n        uint256 rentalCount = rentalIndex.length();\n        if (rentalCount == 0 || toBeRemoved == 0) return;\n\n        uint256 maxCycles = rentalCount < _GC_CYCLES ? rentalCount : _GC_CYCLES;\n        uint256 removed = 0;\n\n        for (uint256 i = 0; i < maxCycles; i++) {\n            uint256 rentalId = rentalIndex.at(i);\n\n            if (!self.agreements[rentalId].isEffective()) {\n                // Warning: we are iterating an array that we are also modifying!\n                _removeRentalAgreement(self, rentalId);\n                removed += 1;\n                maxCycles -= 1; // This is so we account for reduced `rentalCount`.\n\n                // Stop iterating if we have cleaned up enough desired items.\n                if (removed == toBeRemoved) break;\n            }\n        }\n    }\n\n    /**\n     * @dev Performs new rental agreement registration.\n     */\n    function register(Registry storage self, Agreement memory agreement) external returns (uint256 rentalId) {\n        // Make sure the there is no active rentals for the warper ID.\n        bytes32 assetId = agreement.warpedAsset.id.hash();\n        uint256 latestRentalId = self.assets[assetId].latestRentalId;\n        if (latestRentalId != 0 && self.agreements[latestRentalId].isEffective()) {\n            revert RentalAgreementConflict(latestRentalId);\n        }\n\n        // Generate new rental ID.\n        self.idTracker.increment();\n        rentalId = self.idTracker.current();\n\n        // Save new rental agreement.\n        self.agreements[rentalId] = agreement;\n\n        // Update warper latest rental ID.\n        self.assets[assetId].latestRentalId = rentalId;\n\n        // Update user rental data.\n        self.renters[agreement.renter].rentalIndex.add(rentalId);\n        self.renters[agreement.renter].collectionRentalIndex[agreement.collectionId].add(rentalId);\n    }\n\n    /**\n     * @dev Safely removes expired rental data from the registry.\n     */\n    function removeExpiredRentalAgreement(Registry storage self, uint256 rentalId) external {\n        if (self.agreements[rentalId].isEffective()) revert CannotDeleteEffectiveRentalAgreement(rentalId);\n        _removeRentalAgreement(self, rentalId);\n    }\n\n    /**\n     * @dev Removes rental data from the registry.\n     */\n    function _removeRentalAgreement(Registry storage self, uint256 rentalId) private {\n        address renter = self.agreements[rentalId].renter;\n        bytes32 collectionId = self.agreements[rentalId].collectionId;\n\n        // Remove user rental data.\n        self.renters[renter].rentalIndex.remove(rentalId);\n        self.renters[renter].collectionRentalIndex[collectionId].remove(rentalId);\n\n        // Delete rental agreement.\n        delete self.agreements[rentalId];\n    }\n\n    /**\n     * @dev Finds all effective rental agreements from specific collection.\n     * Returns the total value rented by `renter`.\n     */\n    function collectionRentedValue(\n        Registry storage self,\n        address renter,\n        bytes32 collectionId\n    ) external view returns (uint256 value) {\n        EnumerableSetUpgradeable.UintSet storage rentalIndex = self.renters[renter].collectionRentalIndex[collectionId];\n        uint256 length = rentalIndex.length();\n        for (uint256 i = 0; i < length; i++) {\n            Agreement storage agreement = self.agreements[rentalIndex.at(i)];\n            if (agreement.isEffective()) {\n                value += agreement.warpedAsset.value;\n            }\n        }\n    }\n\n    /**\n     * @dev Returns asset rental status based on latest rental agreement.\n     */\n    function assetRentalStatus(Registry storage self, Assets.AssetId memory assetId)\n        external\n        view\n        returns (RentalStatus)\n    {\n        uint256 latestRentalId = self.assets[assetId.hash()].latestRentalId;\n        if (latestRentalId == 0) return RentalStatus.NONE;\n\n        return self.agreements[latestRentalId].isEffective() ? RentalStatus.RENTED : RentalStatus.AVAILABLE;\n    }\n\n    /**\n     * @dev Main renting request validation function.\n     */\n    function validateRentingParams(\n        Params calldata params,\n        Protocol.Config storage protocolConfig,\n        Listings.Registry storage listingRegistry,\n        IWarperManager warperManager\n    ) external view {\n        // Validate from the protocol perspective.\n        protocolConfig.checkBaseToken(params.paymentToken);\n\n        // Validate from the listing perspective.\n        listingRegistry.checkListed(params.listingId);\n        Listings.Listing storage listing = listingRegistry.listings[params.listingId];\n        listing.checkNotPaused();\n        listing.checkValidLockPeriod(params.rentalPeriod);\n\n        // Validate from the warper perspective.\n        warperManager.checkRegisteredWarper(params.warper);\n        Warpers.Warper memory warper = warperManager.warperInfo(params.warper);\n        warper.checkCompatibleAsset(listing.asset);\n        warper.checkNotPaused();\n        warper.controller.validateRentingParams(listing.asset, params);\n    }\n\n    /**\n     * @dev Performs rental fee calculation and returns the fee breakdown.\n     */\n    function calculateRentalFees(\n        Params calldata rentingParams,\n        Protocol.Config storage protocolConfig,\n        Listings.Registry storage listingRegistry,\n        IWarperManager warperManager,\n        IUniverseRegistry universeRegistry\n    ) external view returns (RentalFees memory fees) {\n        // Calculate lister base fee.\n        Listings.Listing storage listing = listingRegistry.listings[rentingParams.listingId];\n        Listings.Params memory listingParams = listing.params;\n        // Resolve listing controller to calculate lister fee based on selected listing strategy.\n        IListingController listingController = listingRegistry.listingController(listingParams.strategy);\n        fees.listerBaseFee = listingController.calculateRentalFee(listingParams, rentingParams);\n\n        // Calculate universe base fee.\n        Warpers.Warper memory warper = warperManager.warperInfo(rentingParams.warper);\n        uint16 universeRentalFeePercent = universeRegistry.universeRentalFeePercent(warper.universeId);\n        fees.universeBaseFee = (fees.listerBaseFee * universeRentalFeePercent) / HUNDRED_PERCENT;\n\n        // Calculate protocol fee.\n        fees.protocolFee = (fees.listerBaseFee * protocolConfig.rentalFeePercent) / HUNDRED_PERCENT;\n\n        // Calculate warper premiums.\n        (uint256 universePremium, uint256 listerPremium) = warper.controller.calculatePremiums(\n            listing.asset,\n            rentingParams,\n            fees.universeBaseFee,\n            fees.listerBaseFee\n        );\n        fees.listerPremium = listerPremium;\n        fees.universePremium = universePremium;\n\n        // Calculate TOTAL rental fee.\n        fees.total += fees.listerBaseFee + listerPremium;\n        fees.total += fees.universeBaseFee + universePremium;\n        fees.total += fees.protocolFee;\n    }\n}\n"
    },
    "contracts/universe/IUniverseRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface IUniverseRegistry {\n    /**\n     * @dev Thrown when a check is made where the given account must also be the universe owner.\n     */\n    error AccountIsNotUniverseOwner(address account);\n\n    /**\n     * @dev Thrown when a the supplied universe name is empty.\n     */\n    error EmptyUniverseName();\n\n    /**\n     * @dev Thrown when trying to read universe data for a universe is not registered.\n     */\n    error QueryForNonexistentUniverse(uint256 universeId);\n\n    /**\n     * @dev Emitted when a universe is created.\n     * @param universeId Universe ID.\n     * @param name Universe name.\n     */\n    event UniverseCreated(uint256 indexed universeId, string name);\n\n    /**\n     * @dev Emitted when a universe name is changed.\n     * @param universeId Universe ID.\n     * @param name The newly set name.\n     */\n    event UniverseNameChanged(uint256 indexed universeId, string name);\n\n    /**\n     * @dev Emitted when universe rental fee is changed.\n     * @param universeId Universe ID.\n     * @param rentalFeePercent The newly rental fee.\n     */\n    event UniverseRentalFeeChanged(uint256 indexed universeId, uint16 rentalFeePercent);\n\n    /**\n     * @dev Updates the universe token base URI.\n     * @param baseURI New base URI. Must include a trailing slash (\"/\").\n     */\n    function setUniverseTokenBaseURI(string calldata baseURI) external;\n\n    /**\n     * @dev The universe properties & initial configuration params.\n     * @param name The universe name.\n     * @param rentalFeePercent The base percentage of the rental fee which the universe charges for using its warpers.\n     */\n    struct UniverseParams {\n        string name;\n        uint16 rentalFeePercent;\n    }\n\n    /**\n     * @dev Creates new Universe. This includes minting new universe NFT,\n     * where the caller of this method becomes the universe owner.\n     * @param params The universe properties & initial configuration params.\n     * @return Universe ID (universe token ID).\n     */\n    function createUniverse(UniverseParams calldata params) external returns (uint256);\n\n    /**\n     * @dev Update the universe name.\n     * @param universeId The unique identifier for the universe.\n     * @param universeName The universe name to set.\n     */\n    function setUniverseName(uint256 universeId, string memory universeName) external;\n\n    /**\n     * @dev Update the universe rental fee percent.\n     * @param universeId The unique identifier for the universe.\n     * @param rentalFeePercent The universe rental fee percent.\n     */\n    function setUniverseRentalFeePercent(uint256 universeId, uint16 rentalFeePercent) external;\n\n    /**\n     * @dev Returns Universe owner address.\n     * @param universeId Universe ID.\n     * @return Universe owner.\n     */\n    function universeOwner(uint256 universeId) external view returns (address);\n\n    /**\n     * @dev Returns Universe rental fee percent.\n     * @param universeId Universe ID.\n     * @return universe fee percent.\n     */\n    function universeRentalFeePercent(uint256 universeId) external view returns (uint16);\n\n    /**\n     * @dev Returns name.\n     * @param universeId Universe ID.\n     * @return universe name.\n     */\n    function universeName(uint256 universeId) external view returns (string memory);\n\n    /**\n     * @dev Returns the Universe token address.\n     */\n    function universeToken() external view returns (address);\n\n    /**\n     * @dev Returns the Universe token base URI.\n     */\n    function universeTokenBaseURI() external view returns (string memory);\n\n    /**\n     * @dev Aggregate and return Universe data.\n     * @param universeId Universe-specific ID.\n     * @return name The name of the universe.\n     * @return rentalFeePercent The base percentage of the rental fee which the universe charges for using its warpers.\n     */\n    function universe(uint256 universeId) external view returns (string memory name, uint16 rentalFeePercent);\n\n    /**\n     * @dev Reverts if the universe owner is not the provided account address.\n     * @param universeId Universe ID.\n     * @param account The address of the expected owner.\n     */\n    function checkUniverseOwner(uint256 universeId, address account) external view;\n\n    /**\n     * @dev Returns `true` if the universe owner is the supplied account address.\n     * @param universeId Universe ID.\n     * @param account The address of the expected owner.\n     */\n    function isUniverseOwner(uint256 universeId, address account) external view returns (bool);\n}\n"
    },
    "contracts/listing/Listings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../asset/Assets.sol\";\nimport \"./IListingController.sol\";\nimport \"./IListingStrategyRegistry.sol\";\n\nlibrary Listings {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n    using Listings for Registry;\n    using Listings for Listing;\n    using Assets for Assets.Asset;\n\n    /**\n     * @dev Thrown when the `listingId` is invalid or the asset has been delisted.\n     */\n    error NotListed(uint256 listingId);\n\n    /**\n     * @dev Thrown when the `listingId` has never been registered.\n     */\n    error ListingIsNotRegistered(uint256 listingId);\n\n    /**\n     * @dev Thrown when the operation is not allowed due to the listing being paused.\n     */\n    error ListingIsPaused();\n\n    /**\n     * @dev Thrown when the operation is not allowed due to the listing not being paused.\n     */\n    error ListingIsNotPaused();\n\n    /**\n     * @dev Thrown when attempting to lock the listed asset for the period longer than the lister allowed.\n     */\n    error InvalidLockPeriod(uint32 period);\n\n    /**\n     * @dev Thrown when the listing strategy is not registered or deprecated.\n     * @param strategyId Unsupported listing strategy ID.\n     */\n    error UnsupportedListingStrategy(bytes4 strategyId);\n\n    /**\n     * @dev Thrown when the operation is not allowed due to the listing group being nonempty.\n     * @param listingGroupId Listing group ID.\n     */\n    error ListingGroupIsNotEmpty(uint256 listingGroupId);\n\n    /**\n     * @dev Thrown when the provided `account` doesn't match the listing group owner address.\n     * @param listingGroupId Listing group ID.\n     * @param account Invalid owner account.\n     */\n    error InvalidListingGroupOwner(uint256 listingGroupId, address account);\n\n    /*\n     * @dev Listing strategy identifiers to be used across the system:\n     */\n    bytes4 public constant FIXED_PRICE = bytes4(keccak256(\"FIXED_PRICE\"));\n    bytes4 public constant FIXED_PRICE_WITH_REWARD = bytes4(keccak256(\"FIXED_PRICE_WITH_REWARD\"));\n\n    /**\n     * @dev Listing params.\n     * The layout of `data` might vary for different listing strategies.\n     * For example, in case of FIXED_PRICE strategy, the `data` might contain only base rate,\n     * and for more advanced auction strategies it might include period, min bid step etc.\n     * @param strategy Listing strategy ID\n     * @param data Listing strategy data.\n     */\n    struct Params {\n        bytes4 strategy;\n        bytes data;\n    }\n\n    /**\n     * @dev Listing structure.\n     * @param asset Listed asset structure.\n     * @param params Listing strategy parameters.\n     * @param lister Lister account address.\n     * @param maxLockPeriod The maximum amount of time the asset owner can wait before getting the asset back.\n     * @param lockedTill The earliest possible time when the asset can be returned to the owner.\n     * @param immediatePayout Indicates whether the rental fee must be transferred to the lister on every renting.\n     * If FALSE, the rental fees get accumulated until withdrawn manually.\n     * @param delisted Indicates whether the asset is delisted.\n     * @param paused Indicates whether the listing is paused.\n     * @param groupId Listing group ID.\n     */\n    struct Listing {\n        // slots 0-2\n        Assets.Asset asset;\n        // slot 3-4\n        Params params;\n        // slot 5 (1 byte)\n        address lister;\n        uint32 maxLockPeriod;\n        uint32 lockedTill;\n        bool immediatePayout;\n        bool delisted;\n        bool paused;\n        // slot 6\n        uint256 groupId;\n    }\n\n    /**\n     * @dev Listing related data associated with the specific account.\n     * @param listingIndex The set of listing IDs.\n     * @param listingGroupIndex The set of listing group IDs.\n     */\n    struct ListerInfo {\n        EnumerableSetUpgradeable.UintSet listingIndex;\n        EnumerableSetUpgradeable.UintSet listingGroupIndex;\n    }\n\n    /**\n     * @dev Listing related data associated with the specific account.\n     * @param listingIndex The set of listing IDs.\n     */\n    struct AssetInfo {\n        EnumerableSetUpgradeable.UintSet listingIndex;\n    }\n\n    /**\n     * @dev Listing group information.\n     * @param name The listing group name.\n     * @param owner The listing group owner address.\n     * @param listingIndex The set of listing IDs which belong to the group.\n     */\n    struct ListingGroupInfo {\n        string name;\n        address owner;\n        EnumerableSetUpgradeable.UintSet listingIndex;\n    }\n\n    /**\n     * @dev Listing registry.\n     * @param idTracker Listing ID tracker (incremental counter).\n     * @param strategyRegistry Listing strategy registry contract.\n     * @param listingIndex The global set of registered listing IDs.\n     * @param listings Mapping from listing ID to the listing info.\n     * @param listers Mapping from lister address to the lister info.\n     * @param assets Mapping from an asset address to the asset info.\n     * @param listingGroups Mapping from listing group ID to the listing group info.\n     */\n    struct Registry {\n        CountersUpgradeable.Counter listingIdTracker;\n        IListingStrategyRegistry strategyRegistry;\n        EnumerableSetUpgradeable.UintSet listingIndex;\n        mapping(uint256 => Listing) listings;\n        mapping(address => ListerInfo) listers;\n        mapping(address => AssetInfo) assets;\n        CountersUpgradeable.Counter listingGroupIdTracker;\n        mapping(uint256 => ListingGroupInfo) listingGroups;\n    }\n\n    /**\n     * @dev Puts the listing on pause.\n     */\n    function pause(Listing storage self) internal {\n        if (self.paused) revert ListingIsPaused();\n\n        self.paused = true;\n    }\n\n    /**\n     * @dev Lifts the listing pause.\n     */\n    function unpause(Listing storage self) internal {\n        if (!self.paused) revert ListingIsNotPaused();\n\n        self.paused = false;\n    }\n\n    /**\n     * Determines whether the listing is active.\n     */\n    function listed(Listing storage self) internal view returns (bool) {\n        return self.lister != address(0) && !self.delisted;\n    }\n\n    /**\n     * @dev Reverts if the listing is paused.\n     */\n    function checkNotPaused(Listing storage self) internal view {\n        if (self.paused) revert ListingIsPaused();\n    }\n\n    /*\n     * @dev Validates lock period.\n     */\n    function isValidLockPeriod(Listing storage self, uint32 lockPeriod) internal view returns (bool) {\n        return (lockPeriod > 0 && lockPeriod <= self.maxLockPeriod);\n    }\n\n    /**\n     * @dev Reverts if the lock period is not valid.\n     */\n    function checkValidLockPeriod(Listing storage self, uint32 lockPeriod) internal view {\n        if (!self.isValidLockPeriod(lockPeriod)) revert InvalidLockPeriod(lockPeriod);\n    }\n\n    /**\n     * @dev Extends listing lock time.\n     * Does not modify the state if current lock time is larger.\n     */\n    function addLock(Listing storage self, uint32 unlockTimestamp) internal {\n        // Listing is already locked till later time, no need to extend locking period.\n        if (self.lockedTill >= unlockTimestamp) return;\n        // Extend listing lock.\n        self.lockedTill = unlockTimestamp;\n    }\n\n    /**\n     * @dev Registers new listing group.\n     * @param name The listing group name.\n     * @param owner The listing group owner address.\n     * @return listingGroupId New listing group ID.\n     */\n    function registerListingGroup(\n        Registry storage self,\n        string memory name,\n        address owner\n    ) external returns (uint256 listingGroupId) {\n        listingGroupId = _registerListingGroup(self, name, owner);\n    }\n\n    /**\n     * @dev Removes listing group data.\n     * @param listingGroupId The ID of the listing group to be deleted.\n     */\n    function removeListingGroup(Registry storage self, uint256 listingGroupId) external {\n        ListingGroupInfo storage listingGroup = self.listingGroups[listingGroupId];\n\n        // Deleting nonempty listing groups is forbidden.\n        if (listingGroup.listingIndex.length() > 0) revert ListingGroupIsNotEmpty(listingGroupId);\n\n        // Remove the listing group ID from the user account data.\n        self.listers[listingGroup.owner].listingGroupIndex.remove(listingGroupId);\n\n        // Delete listing group.\n        delete self.listingGroups[listingGroupId];\n    }\n\n    /**\n     * @dev Registers new listing.\n     * @return listingId New listing ID.\n     * @return listingGroupId Effective listing group ID.\n     */\n    function register(Registry storage self, Listing memory listing)\n        external\n        returns (uint256 listingId, uint256 listingGroupId)\n    {\n        // Generate new listing ID.\n        self.listingIdTracker.increment();\n        listingId = self.listingIdTracker.current();\n\n        // Listing is being added to an existing group.\n        if (listing.groupId != 0) {\n            listingGroupId = listing.groupId;\n            self.checkListingGroupOwner(listingGroupId, listing.lister);\n        } else {\n            // Otherwise the new listing group is created and the listing is added to this group by default.\n            listingGroupId = _registerListingGroup(self, \"\", listing.lister);\n            listing.groupId = listingGroupId;\n        }\n\n        // Add new listing ID to the global index.\n        self.listingIndex.add(listingId);\n        // Add new listing ID to the listing group index.\n        self.listingGroups[listingGroupId].listingIndex.add(listingId);\n        // Add user listing data.\n        self.listers[listing.lister].listingIndex.add(listingId);\n        // Add asset listing data.\n        self.assets[listing.asset.token()].listingIndex.add(listingId);\n        // Store new listing record.\n        self.listings[listingId] = listing;\n    }\n\n    /**\n     * @dev Removes listing data.\n     * @param listingId The ID of the listing to be deleted.\n     */\n    function remove(Registry storage self, uint256 listingId) external {\n        address lister = self.listings[listingId].lister;\n        address original = self.listings[listingId].asset.token();\n        uint256 listingGroupId = self.listings[listingId].groupId;\n\n        // Remove the listing ID from the global index.\n        self.listingIndex.remove(listingId);\n        // Remove the listing ID from the group index.\n        self.listingGroups[listingGroupId].listingIndex.remove(listingId);\n        // Remove user listing data.\n        self.listers[lister].listingIndex.remove(listingId);\n        // Remove asset listing data.\n        self.assets[original].listingIndex.remove(listingId);\n        // Delete listing.\n        delete self.listings[listingId];\n    }\n\n    /**\n     * @dev Returns the paginated list of currently registered listings.\n     */\n    function allListings(\n        Registry storage self,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Listing[] memory) {\n        return self.paginateIndexedListings(self.listingIndex, offset, limit);\n    }\n\n    /**\n     * @dev Returns the paginated list of currently registered listings for the particular lister account.\n     */\n    function userListings(\n        Registry storage self,\n        address lister,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Listing[] memory) {\n        return self.paginateIndexedListings(self.listers[lister].listingIndex, offset, limit);\n    }\n\n    /**\n     * @dev Returns the paginated list of currently registered listings for the original asset.\n     */\n    function assetListings(\n        Registry storage self,\n        address original,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Listing[] memory) {\n        return self.paginateIndexedListings(self.assets[original].listingIndex, offset, limit);\n    }\n\n    /**\n     * @dev Reverts if listing has not been registered.\n     * @param listingId Listing ID.\n     */\n    function checkRegisteredListing(Registry storage self, uint256 listingId) external view {\n        if (!self.isRegisteredListing(listingId)) revert ListingIsNotRegistered(listingId);\n    }\n\n    /**\n     * @dev Reverts if the provided `account` doesn't match the listing group owner address.\n     * @param listingGroupId Listing group ID.\n     * @param account The account to check ownership for.\n     */\n    function checkListingGroupOwner(\n        Registry storage self,\n        uint256 listingGroupId,\n        address account\n    ) internal view {\n        if (self.listingGroups[listingGroupId].owner != account)\n            revert InvalidListingGroupOwner(listingGroupId, account);\n    }\n\n    /**\n     * @dev Checks listing registration by ID.\n     * @param listingId Listing ID.\n     */\n    function isRegisteredListing(Registry storage self, uint256 listingId) internal view returns (bool) {\n        return self.listings[listingId].lister != address(0);\n    }\n\n    /**\n     * @dev Reverts if listing strategy is not supported.\n     * @param strategyId Listing strategy ID.\n     */\n    function checkSupportedListingStrategy(Registry storage self, bytes4 strategyId) internal view {\n        if (!self.strategyRegistry.isRegisteredListingStrategy(strategyId))\n            revert UnsupportedListingStrategy(strategyId);\n    }\n\n    /**\n     * @dev Returns listing controller for strategy.\n     * @param strategyId Listing strategy ID.\n     */\n    function listingController(Registry storage self, bytes4 strategyId) internal view returns (IListingController) {\n        return IListingController(self.strategyRegistry.listingController(strategyId));\n    }\n\n    /**\n     * @dev Reverts if listing is not registered or has been already delisted.\n     * @param listingId Listing ID.\n     */\n    function checkListed(Registry storage self, uint256 listingId) internal view {\n        if (!self.listings[listingId].listed()) revert NotListed(listingId);\n    }\n\n    /**\n     * @dev Returns the number of currently registered listings.\n     */\n    function listingCount(Registry storage self) internal view returns (uint256) {\n        return self.listingIndex.length();\n    }\n\n    /**\n     * @dev Returns the number of currently registered listings for a particular lister account.\n     */\n    function userListingCount(Registry storage self, address lister) internal view returns (uint256) {\n        return self.listers[lister].listingIndex.length();\n    }\n\n    /**\n     * @dev Returns the number of currently registered listings for a particular original asset.\n     */\n    function assetListingCount(Registry storage self, address original) internal view returns (uint256) {\n        return self.assets[original].listingIndex.length();\n    }\n\n    /**\n     * @dev Returns the paginated list of currently registered listing using provided index reference.\n     */\n    function paginateIndexedListings(\n        Registry storage self,\n        EnumerableSetUpgradeable.UintSet storage listingIndex,\n        uint256 offset,\n        uint256 limit\n    ) internal view returns (uint256[] memory, Listing[] memory) {\n        uint256 indexSize = listingIndex.length();\n        if (offset >= indexSize) return (new uint256[](0), new Listing[](0));\n\n        if (limit > indexSize - offset) {\n            limit = indexSize - offset;\n        }\n\n        Listing[] memory listings = new Listing[](limit);\n        uint256[] memory listingIds = new uint256[](limit);\n        for (uint256 i = 0; i < limit; i++) {\n            listingIds[i] = listingIndex.at(offset + i);\n            listings[i] = self.listings[listingIds[i]];\n        }\n\n        return (listingIds, listings);\n    }\n\n    /**\n     * @dev Registers new listing group.\n     * @param name The listing group name.\n     * @param owner The listing group owner address.\n     * @return listingGroupId New listing group ID.\n     */\n    function _registerListingGroup(\n        Registry storage self,\n        string memory name,\n        address owner\n    ) private returns (uint256 listingGroupId) {\n        // Generate new listing group ID.\n        self.listingGroupIdTracker.increment();\n        listingGroupId = self.listingGroupIdTracker.current();\n\n        // Store new listing group record.\n        self.listingGroups[listingGroupId].name = name;\n        self.listingGroups[listingGroupId].owner = owner;\n\n        // Associate the new listing group with the user account.\n        self.listers[owner].listingGroupIndex.add(listingGroupId);\n    }\n}\n"
    },
    "contracts/accounting/IPaymentManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./Accounts.sol\";\n\ninterface IPaymentManager {\n    /**\n     * @notice Describes the earning type.\n     */\n    enum EarningType {\n        LISTER_FEE\n    }\n\n    /**\n     * @dev Emitted when a user has earned some amount tokens.\n     * @param user Address of the user that earned some amount.\n     * @param earningType Describes the type of the user.\n     * @param paymentToken The currency that the user has earned.\n     * @param amount The amount of tokens that the user has earned.\n     */\n    event UserEarned(\n        address indexed user,\n        EarningType indexed earningType,\n        address indexed paymentToken,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted when the universe has earned some amount of tokens.\n     * @param universeId ID of the universe that earned the tokens.\n     * @param paymentToken The currency that the user has earned.\n     * @param amount The amount of tokens that the user has earned.\n     */\n    event UniverseEarned(uint256 indexed universeId, address indexed paymentToken, uint256 amount);\n\n    /**\n     * @dev Emitted when the protocol has earned some amount of tokens.\n     * @param paymentToken The currency that the user has earned.\n     * @param amount The amount of tokens that the user has earned.\n     */\n    event ProtocolEarned(address indexed paymentToken, uint256 amount);\n\n    /**\n     * @dev Transfers the specific `amount` of `token` from a protocol balance to an arbitrary address.\n     * @param token The token address.\n     * @param amount The amount to be withdrawn.\n     * @param to The payee address.\n     */\n    function withdrawProtocolFunds(\n        address token,\n        uint256 amount,\n        address to\n    ) external;\n\n    /**\n     * @dev Transfers the specific `amount` of `token` from a universe balance to an arbitrary address.\n     * @param universeId The universe ID.\n     * @param token The token address.\n     * @param amount The amount to be withdrawn.\n     * @param to The payee address.\n     */\n    function withdrawUniverseFunds(\n        uint256 universeId,\n        address token,\n        uint256 amount,\n        address to\n    ) external;\n\n    /**\n     * @dev Transfers the specific `amount` of `token` from a user balance to an arbitrary address.\n     * @param token The token address.\n     * @param amount The amount to be withdrawn.\n     * @param to The payee address.\n     */\n    function withdrawFunds(\n        address token,\n        uint256 amount,\n        address to\n    ) external;\n\n    /**\n     * @dev Returns the amount of `token`, currently accumulated by the protocol.\n     * @param token The token address.\n     * @return Balance of `token`.\n     */\n    function protocolBalance(address token) external view returns (uint256);\n\n    /**\n     * @dev Returns the list of protocol balances in various tokens.\n     * @return List of balances.\n     */\n    function protocolBalances() external view returns (Accounts.Balance[] memory);\n\n    /**\n     * @dev Returns the amount of `token`, currently accumulated by the universe.\n     * @param universeId The universe ID.\n     * @param token The token address.\n     * @return Balance of `token`.\n     */\n    function universeBalance(uint256 universeId, address token) external view returns (uint256);\n\n    /**\n     * @dev Returns the list of universe balances in various tokens.\n     * @param universeId The universe ID.\n     * @return List of balances.\n     */\n    function universeBalances(uint256 universeId) external view returns (Accounts.Balance[] memory);\n\n    /**\n     * @dev Returns the amount of `token`, currently accumulated by the user.\n     * @param account The account to query the balance for.\n     * @param token The token address.\n     * @return Balance of `token`.\n     */\n    function balance(address account, address token) external view returns (uint256);\n\n    /**\n     * @dev Returns the list of user balances in various tokens.\n     * @param account The account to query the balance for.\n     * @return List of balances.\n     */\n    function balances(address account) external view returns (Accounts.Balance[] memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "contracts/asset/Assets.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"./IAssetController.sol\";\nimport \"./IAssetVault.sol\";\nimport \"./IAssetClassRegistry.sol\";\n\nlibrary Assets {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using Address for address;\n    using Assets for Registry;\n    using Assets for Asset;\n\n    /*\n     * @dev This is the list of asset class identifiers to be used across the system.\n     */\n    bytes4 public constant ERC721 = bytes4(keccak256(\"ERC721\"));\n    bytes4 public constant ERC1155 = bytes4(keccak256(\"ERC1155\"));\n\n    bytes32 public constant ASSET_ID_TYPEHASH = keccak256(\"AssetId(bytes4 class,bytes data)\");\n\n    bytes32 public constant ASSET_TYPEHASH =\n        keccak256(\"Asset(AssetId id,uint256 value)AssetId(bytes4 class,bytes data)\");\n\n    /**\n     * @dev Thrown upon attempting to register an asset twice.\n     * @param asset Duplicate asset address.\n     */\n    error AssetIsAlreadyRegistered(address asset);\n\n    /**\n     * @dev Communicates asset identification information.\n     * The structure designed to be token-standard agnostic,\n     * so the layout of `data` might vary for different token standards.\n     * For example, in case of ERC721 token, the `data` will contain contract address and tokenId.\n     * @param class Asset class ID\n     * @param data Asset identification data.\n     */\n    struct AssetId {\n        bytes4 class;\n        bytes data;\n    }\n\n    /**\n     * @dev Calculates Asset ID hash\n     */\n    function hash(AssetId memory assetId) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ASSET_ID_TYPEHASH, assetId.class, keccak256(assetId.data)));\n    }\n\n    /**\n     * @dev Extracts token contract address from the Asset ID structure.\n     * The address is the common attribute for all assets regardless of their asset class.\n     */\n    function token(AssetId memory self) internal pure returns (address) {\n        return abi.decode(self.data, (address));\n    }\n\n    /**\n     * @dev Uniformed structure to describe arbitrary asset (token) and its value.\n     * @param id Asset ID structure.\n     * @param value Asset value (amount).\n     */\n    struct Asset {\n        AssetId id;\n        uint256 value;\n    }\n\n    /**\n     * @dev Calculates Asset hash\n     */\n    function hash(Asset memory asset) internal pure returns (bytes32) {\n        return keccak256(abi.encode(ASSET_TYPEHASH, hash(asset.id), asset.value));\n    }\n\n    /**\n     * @dev Extracts token contract address from the Asset structure.\n     * The address is the common attribute for all assets regardless of their asset class.\n     */\n    function token(Asset memory self) internal pure returns (address) {\n        return abi.decode(self.id.data, (address));\n    }\n\n    /**\n     * @dev Original asset data.\n     * @param controller Asset controller.\n     * @param assetClass The asset class identifier.\n     * @param vault Asset vault.\n     */\n    struct AssetConfig {\n        IAssetController controller;\n        bytes4 assetClass;\n        IAssetVault vault;\n    }\n\n    /**\n     * @dev Asset registry.\n     * @param classRegistry Asset class registry contract.\n     * @param assetIndex Set of registered asset addresses.\n     * @param assets Mapping from asset address to the asset configuration.\n     */\n    struct Registry {\n        IAssetClassRegistry classRegistry;\n        EnumerableSetUpgradeable.AddressSet assetIndex;\n        mapping(address => AssetConfig) assets;\n    }\n\n    /**\n     * @dev Registers new asset.\n     */\n    function registerAsset(\n        Registry storage self,\n        bytes4 assetClass,\n        address asset\n    ) external {\n        if (!self.assetIndex.add(asset)) revert AssetIsAlreadyRegistered(asset);\n\n        IAssetClassRegistry.ClassConfig memory assetClassConfig = self.classRegistry.assetClassConfig(assetClass);\n        self.assets[asset] = AssetConfig({\n            controller: IAssetController(assetClassConfig.controller),\n            assetClass: assetClass,\n            vault: IAssetVault(assetClassConfig.vault)\n        });\n    }\n\n    /**\n     * @dev Returns the paginated list of currently registered listings and their corresponding asset configs.\n     */\n    function supportedAssets(\n        Registry storage self,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (address[] memory, AssetConfig[] memory) {\n        uint256 indexSize = self.assetIndex.length();\n        if (offset >= indexSize) return (new address[](0), new AssetConfig[](0));\n\n        if (limit > indexSize - offset) {\n            limit = indexSize - offset;\n        }\n\n        AssetConfig[] memory assetConfigs = new AssetConfig[](limit);\n        address[] memory assetAddresses = new address[](limit);\n        for (uint256 i = 0; i < limit; i++) {\n            assetAddresses[i] = self.assetIndex.at(offset + i);\n            assetConfigs[i] = self.assets[assetAddresses[i]];\n        }\n        return (assetAddresses, assetConfigs);\n    }\n\n    /**\n     * @dev Transfers an asset to the vault using associated controller.\n     */\n    function transferAssetToVault(\n        Registry storage self,\n        Assets.Asset memory asset,\n        address from\n    ) external {\n        // Extract token address from asset struct and check whether the asset is supported.\n        address assetToken = asset.token();\n\n        // Transfer asset to the class asset specific vault.\n        address assetController = address(self.assets[assetToken].controller);\n        address assetVault = address(self.assets[assetToken].vault);\n        assetController.functionDelegateCall(\n            abi.encodeWithSelector(IAssetController.transferAssetToVault.selector, asset, from, assetVault)\n        );\n    }\n\n    /**\n     * @dev Transfers an asset from the vault using associated controller.\n     */\n    function returnAssetFromVault(Registry storage self, Assets.Asset memory asset) external {\n        address assetToken = asset.token();\n        address assetController = address(self.assets[assetToken].controller);\n        address assetVault = address(self.assets[assetToken].vault);\n\n        assetController.functionDelegateCall(\n            abi.encodeWithSelector(IAssetController.returnAssetFromVault.selector, asset, assetVault)\n        );\n    }\n\n    function assetCount(Registry storage self) internal view returns (uint256) {\n        return self.assetIndex.length();\n    }\n\n    /**\n     * @dev Checks asset registration by address.\n     */\n    function isRegisteredAsset(Registry storage self, address asset) internal view returns (bool) {\n        return self.assetIndex.contains(asset);\n    }\n\n    /**\n     * @dev Returns controller for asset class.\n     * @param assetClass Asset class ID.\n     */\n    function assetClassController(Registry storage self, bytes4 assetClass) internal view returns (address) {\n        return self.classRegistry.assetClassConfig(assetClass).controller;\n    }\n}\n"
    },
    "contracts/metahub/Protocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nlibrary Protocol {\n    /**\n     * @dev Thrown when the provided token does not match with the configured base token.\n     */\n    error BaseTokenMismatch();\n\n    /**\n     * @dev Protocol configuration.\n     * @param baseToken ERC20 contract. Used as the price denominator.\n     * @param rentalFeePercent The fixed part of the total rental fee paid to protocol.\n     */\n    struct Config {\n        IERC20Upgradeable baseToken;\n        uint16 rentalFeePercent;\n    }\n\n    /**\n     * @dev Reverts if the `token` does not match the base one.\n     */\n    function checkBaseToken(Config storage self, address token) internal view {\n        if (token != address(self.baseToken)) revert BaseTokenMismatch();\n    }\n}\n"
    },
    "contracts/warper/Warpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\nimport \"./IWarperController.sol\";\nimport \"./IWarperPresetFactory.sol\";\nimport \"../asset/Assets.sol\";\nimport \"./IWarperManager.sol\";\n\nlibrary Warpers {\n    using AddressUpgradeable for address;\n    using ERC165CheckerUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n    using Warpers for Registry;\n    using Assets for Assets.Asset;\n    using Assets for Assets.Registry;\n\n    /**\n     * @dev Thrown if provided warper address does not implement warper interface.\n     */\n    error InvalidWarperInterface();\n\n    /**\n     * @dev Thrown when the warper returned metahub address differs from the one it is being registered in.\n     * @param provided Metahub address returned by warper.\n     * @param required Required metahub address.\n     */\n    error WarperHasIncorrectMetahubReference(address provided, address required);\n\n    /**\n     * @dev Thrown when performing action or accessing data of an unknown warper.\n     * @param warper Warper address.\n     */\n    error WarperIsNotRegistered(address warper);\n\n    /**\n     * @dev Thrown upon attempting to register a warper twice.\n     * @param warper Duplicate warper address.\n     */\n    error WarperIsAlreadyRegistered(address warper);\n\n    /**\n     * @dev Thrown when the operation is not allowed due to the warper being paused.\n     */\n    error WarperIsPaused();\n\n    /**\n     * @dev Thrown when the operation is not allowed due to the warper not being paused.\n     */\n    error WarperIsNotPaused();\n\n    /**\n     * @dev Thrown when there are no registered warpers for a particular asset.\n     * @param asset Asset address.\n     */\n    error UnsupportedAsset(address asset);\n\n    /**\n     * @dev Thrown upon attempting to use the warper which is not registered for the provided asset.\n     */\n    error IncompatibleAsset(address asset);\n\n    /**\n     * @dev Registered warper data.\n     * @param assetClass The identifying asset class.\n     * @param original Original asset contract address.\n     * @param paused Indicates whether the warper is paused.\n     * @param controller Warper controller.\n     * @param name Warper name.\n     * @param universeId Warper universe ID.\n     */\n    struct Warper {\n        bytes4 assetClass;\n        address original;\n        bool paused;\n        IWarperController controller;\n        string name;\n        uint256 universeId;\n    }\n\n    /**\n     * @dev Reverts if the warper original does not match the `asset`;\n     */\n    function checkCompatibleAsset(Warper memory self, Assets.Asset memory asset) internal pure {\n        address original = asset.token();\n        if (self.original != original) revert IncompatibleAsset(original);\n    }\n\n    /**\n     * @dev Puts the warper on pause.\n     */\n    function pause(Warper storage self) internal {\n        if (self.paused) revert WarperIsPaused();\n\n        self.paused = true;\n    }\n\n    /**\n     * @dev Lifts the warper pause.\n     */\n    function unpause(Warper storage self) internal {\n        if (!self.paused) revert WarperIsNotPaused();\n\n        self.paused = false;\n    }\n\n    /**\n     * @dev Reverts if the warper is paused.\n     */\n    function checkNotPaused(Warper memory self) internal pure {\n        if (self.paused) revert WarperIsPaused();\n    }\n\n    /**\n     * @dev Warper registry.\n     * @param presetFactory Warper preset factory contract.\n     * @param warperIndex Set of registered warper addresses.\n     * @param universeWarperIndex Mapping from a universe ID to the set of warper addresses registered by the universe.\n     * @param assetWarperIndex Mapping from an original asset address to the set of warper addresses,\n     * registered for the asset.\n     * @param warpers Mapping from a warper address to the warper details.\n     */\n    struct Registry {\n        IWarperPresetFactory presetFactory;\n        EnumerableSetUpgradeable.AddressSet warperIndex;\n        mapping(uint256 => EnumerableSetUpgradeable.AddressSet) universeWarperIndex;\n        mapping(address => EnumerableSetUpgradeable.AddressSet) assetWarperIndex;\n        mapping(address => Warpers.Warper) warpers;\n    }\n\n    /**\n     * @dev Performs warper registration.\n     * @param warper Warper address.\n     * @param params Warper registration params.\n     */\n    function registerWarper(\n        Registry storage self,\n        address warper,\n        IWarperManager.WarperRegistrationParams calldata params,\n        IAssetClassRegistry assetClassRegistry\n    ) internal returns (bytes4 assetClass, address original) {\n        // Check that provided warper address is a valid contract.\n        if (!warper.isContract() || !warper.supportsInterface(type(IWarper).interfaceId)) {\n            revert InvalidWarperInterface();\n        }\n\n        // Check that warper has correct metahub reference.\n        address metahub = IWarper(warper).__metahub();\n        if (metahub != IWarperManager(address(this)).metahub())\n            revert WarperHasIncorrectMetahubReference(metahub, address(this));\n\n        // Check that warper asset class is supported.\n        assetClass = IWarper(warper).__assetClass();\n\n        // Retrieve warper controller based on assetClass.\n        // Controller resolution for unsupported asset class will revert.\n        IWarperController controller = IWarperController(assetClassRegistry.assetClassConfig(assetClass).controller);\n\n        // Ensure warper compatibility with the current generation of asset controller.\n        controller.checkCompatibleWarper(warper);\n\n        // Retrieve original asset address.\n        original = IWarper(warper).__original();\n\n        // Save warper record.\n        _register(\n            self,\n            warper,\n            Warpers.Warper({\n                original: original,\n                controller: controller,\n                name: params.name,\n                universeId: params.universeId,\n                paused: params.paused,\n                assetClass: assetClass\n            })\n        );\n    }\n\n    /**\n     * @dev Performs warper registration.\n     */\n    function _register(\n        Registry storage self,\n        address warperAddress,\n        Warper memory warper\n    ) private {\n        if (!self.warperIndex.add(warperAddress)) revert WarperIsAlreadyRegistered(warperAddress);\n\n        // Create warper main registration record.\n        self.warpers[warperAddress] = warper;\n        // Associate the warper with the universe.\n        self.universeWarperIndex[warper.universeId].add(warperAddress);\n        // Associate the warper with the original asset.\n        self.assetWarperIndex[warper.original].add(warperAddress);\n    }\n\n    /**\n     * @dev Removes warper data from the registry.\n     */\n    function remove(Registry storage self, address warperAddress) internal {\n        Warper storage warper = self.warpers[warperAddress];\n        // Clean up universe index.\n        self.universeWarperIndex[warper.universeId].remove(warperAddress);\n        // Clean up asset index.\n        self.assetWarperIndex[warper.original].remove(warperAddress);\n        // Clean up main index.\n        self.warperIndex.remove(warperAddress);\n        // Delete warper data.\n        delete self.warpers[warperAddress];\n    }\n\n    /**\n     * @dev Returns the paginated list of warpers belonging to the particular universe.\n     */\n    function universeWarpers(\n        Registry storage self,\n        uint256 universeId,\n        uint256 offset,\n        uint256 limit\n    ) internal view returns (address[] memory, Warpers.Warper[] memory) {\n        return self.paginateIndexedWarpers(self.universeWarperIndex[universeId], offset, limit);\n    }\n\n    /**\n     * @dev Returns the paginated list of warpers associated with the particular original asset.\n     */\n    function assetWarpers(\n        Registry storage self,\n        address original,\n        uint256 offset,\n        uint256 limit\n    ) internal view returns (address[] memory, Warpers.Warper[] memory) {\n        return self.paginateIndexedWarpers(self.assetWarperIndex[original], offset, limit);\n    }\n\n    /**\n     * @dev Checks warper registration by address.\n     */\n    function isRegisteredWarper(Registry storage self, address warper) internal view returns (bool) {\n        return self.warperIndex.contains(warper);\n    }\n\n    /**\n     * @dev Reverts if warper is not registered.\n     */\n    function checkRegisteredWarper(Registry storage self, address warper) internal view {\n        if (!self.isRegisteredWarper(warper)) revert WarperIsNotRegistered(warper);\n    }\n\n    /**\n     * @dev Reverts if asset is not supported.\n     * @param asset Asset address.\n     */\n    function checkSupportedAsset(Registry storage self, address asset) internal view {\n        if (!self.isSupportedAsset(asset)) revert UnsupportedAsset(asset);\n    }\n\n    /**\n     * @dev Checks asset support by address.\n     * The supported asset should have at least one warper.\n     * @param asset Asset address.\n     */\n    function isSupportedAsset(Registry storage self, address asset) internal view returns (bool) {\n        return self.assetWarperIndex[asset].length() > 0;\n    }\n\n    /**\n     * @dev Returns the number of warpers belonging to the particular universe.\n     */\n    function universeWarperCount(Registry storage self, uint256 universeId) internal view returns (uint256) {\n        return self.universeWarperIndex[universeId].length();\n    }\n\n    /**\n     * @dev Returns the number of warpers associated with the particular original asset.\n     */\n    function assetWarperCount(Registry storage self, address original) internal view returns (uint256) {\n        return self.assetWarperIndex[original].length();\n    }\n\n    /**\n     * @dev Returns the paginated list of registered warpers using provided index reference.\n     */\n    function paginateIndexedWarpers(\n        Registry storage self,\n        EnumerableSetUpgradeable.AddressSet storage warperIndex,\n        uint256 offset,\n        uint256 limit\n    ) internal view returns (address[] memory, Warper[] memory) {\n        uint256 indexSize = warperIndex.length();\n        if (offset >= indexSize) return (new address[](0), new Warper[](0));\n\n        if (limit > indexSize - offset) {\n            limit = indexSize - offset;\n        }\n\n        Warper[] memory warpers = new Warper[](limit);\n        address[] memory warperAddresses = new address[](limit);\n        for (uint256 i = 0; i < limit; i++) {\n            warperAddresses[i] = warperIndex.at(offset + i);\n            warpers[i] = self.warpers[warperAddresses[i]];\n        }\n\n        return (warperAddresses, warpers);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/asset/IAssetController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"./Assets.sol\";\n\ninterface IAssetController is IERC165 {\n    /**\n     * @dev Thrown when the asset has invalid class for specific operation.\n     * @param provided Provided class ID.\n     * @param required Required class ID.\n     */\n    error AssetClassMismatch(bytes4 provided, bytes4 required);\n\n    /**\n     * @dev Emitted when asset is transferred.\n     * @param asset Asset being transferred.\n     * @param from Asset sender.\n     * @param to Asset recipient.\n     * @param data Auxiliary data.\n     */\n    event AssetTransfer(Assets.Asset asset, address indexed from, address indexed to, bytes data);\n\n    /**\n     * @dev Returns controller asset class.\n     * @return Asset class ID.\n     */\n    function assetClass() external pure returns (bytes4);\n\n    /**\n     * @dev Transfers asset.\n     * Emits a {AssetTransfer} event.\n     * @param asset Asset being transferred.\n     * @param from Asset sender.\n     * @param to Asset recipient.\n     * @param data Auxiliary data.\n     */\n    function transfer(\n        Assets.Asset memory asset,\n        address from,\n        address to,\n        bytes memory data\n    ) external;\n\n    /**\n     * @dev Transfers asset from owner to the vault contract.\n     * @param asset Asset being transferred.\n     * @param assetOwner Original asset owner address.\n     * @param vault Asset vault contract address.\n     */\n    function transferAssetToVault(\n        Assets.Asset memory asset,\n        address assetOwner,\n        address vault\n    ) external;\n\n    /**\n     * @dev Transfers asset from the vault contract to the original owner.\n     * @param asset Asset being transferred.\n     * @param vault Asset vault contract address.\n     */\n    function returnAssetFromVault(Assets.Asset memory asset, address vault) external;\n\n    /**\n     * @dev Decodes asset ID structure and returns collection identifier.\n     * The collection ID is byte32 value which is calculated based on the asset class.\n     * For example, ERC721 collection can be identified by address only,\n     * but for ERC1155 it should be calculated based on address and token ID.\n     * @return Collection ID.\n     */\n    function collectionId(Assets.AssetId memory assetId) external pure returns (bytes32);\n}\n"
    },
    "contracts/asset/IAssetVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IAssetVault is IERC165 {\n    /**\n     * @dev Thrown when the asset is not is found among vault inventory.\n     */\n    error AssetNotFound();\n\n    /**\n     * @dev Thrown when the function is called on the vault in recovery mode.\n     */\n    error VaultIsInRecoveryMode();\n\n    /**\n     * @dev Thrown when the asset return is not allowed, due to the vault state or the caller permissions.\n     */\n    error AssetReturnIsNotAllowed();\n\n    /**\n     * @dev Thrown when the asset deposit is not allowed, due to the vault state or the caller permissions.\n     */\n    error AssetDepositIsNotAllowed();\n\n    /**\n     * @dev Emitted when the vault is switched to recovery mode by `account`.\n     */\n    event RecoveryModeActivated(address account);\n\n    /**\n     * @dev Activates asset recovery mode.\n     * Emits a {RecoveryModeActivated} event.\n     */\n    function switchToRecoveryMode() external;\n\n    /**\n     * @notice Send ERC20 tokens to an address.\n     */\n    function withdrawERC20Tokens(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) external;\n\n    /**\n     * @dev Pauses the vault.\n     */\n    function pause() external;\n\n    /**\n     * @dev Unpauses the vault.\n     */\n    function unpause() external;\n\n    /**\n     * @dev Returns vault asset class.\n     * @return Asset class ID.\n     */\n    function assetClass() external pure returns (bytes4);\n\n    /**\n     * @dev Returns the Metahub address.\n     */\n    function metahub() external view returns (address);\n\n    /**\n     * @dev Returns vault recovery mode flag state.\n     * @return True when the vault is in recovery mode.\n     */\n    function isRecovery() external view returns (bool);\n}\n"
    },
    "contracts/asset/IAssetClassRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./IAssetController.sol\";\nimport \"./IAssetVault.sol\";\n\ninterface IAssetClassRegistry {\n    /**\n     * @dev Thrown when the asset class supported by contract does not match the required one.\n     * @param provided Provided class ID.\n     * @param required Required class ID.\n     */\n    error AssetClassMismatch(bytes4 provided, bytes4 required);\n\n    /**\n     * @dev Thrown upon attempting to register an asset class twice.\n     * @param assetClass Duplicate asset class ID.\n     */\n    error AssetClassIsAlreadyRegistered(bytes4 assetClass);\n\n    /**\n     * @dev Thrown upon attempting to work with unregistered asset class.\n     * @param assetClass Asset class ID.\n     */\n    error UnregisteredAssetClass(bytes4 assetClass);\n\n    /**\n     * @dev Thrown when the asset controller contract does not implement the required interface.\n     */\n    error InvalidAssetControllerInterface();\n\n    /**\n     * @dev Thrown when the vault contract does not implement the required interface.\n     */\n    error InvalidAssetVaultInterface();\n\n    /**\n     * @dev Emitted when the new asset class is registered.\n     * @param assetClass Asset class ID.\n     * @param controller Controller address.\n     * @param vault Vault address.\n     */\n    event AssetClassRegistered(bytes4 indexed assetClass, address indexed controller, address indexed vault);\n\n    /**\n     * @dev Emitted when the asset class controller is changed.\n     * @param assetClass Asset class ID.\n     * @param newController New controller address.\n     */\n    event AssetClassControllerChanged(bytes4 indexed assetClass, address indexed newController);\n\n    /**\n     * @dev Emitted when the asset class vault is changed.\n     * @param assetClass Asset class ID.\n     * @param newVault New vault address.\n     */\n    event AssetClassVaultChanged(bytes4 indexed assetClass, address indexed newVault);\n\n    /**\n     * @dev Asset class configuration.\n     * @param vault Asset class vault.\n     * @param controller Asset class controller.\n     */\n    struct ClassConfig {\n        address vault;\n        address controller;\n    }\n\n    /**\n     * @dev Registers new asset class.\n     * @param assetClass Asset class ID.\n     * @param config Asset class initial configuration.\n     */\n    function registerAssetClass(bytes4 assetClass, ClassConfig calldata config) external;\n\n    /**\n     * @dev Sets asset class vault.\n     * @param assetClass Asset class ID.\n     * @param vault Asset class vault address.\n     */\n    function setAssetClassVault(bytes4 assetClass, address vault) external;\n\n    /**\n     * @dev Sets asset class controller.\n     * @param assetClass Asset class ID.\n     * @param controller Asset class controller address.\n     */\n    function setAssetClassController(bytes4 assetClass, address controller) external;\n\n    /**\n     * @dev Returns asset class configuration.\n     * @param assetClass Asset class ID.\n     * @return Asset class configuration.\n     */\n    function assetClassConfig(bytes4 assetClass) external view returns (ClassConfig memory);\n\n    /**\n     * @dev Checks asset class registration.\n     * @param assetClass Asset class ID.\n     */\n    function isRegisteredAssetClass(bytes4 assetClass) external view returns (bool);\n\n    /**\n     * @dev Reverts if asset class is not registered.\n     * @param assetClass Asset class ID.\n     */\n    function checkRegisteredAssetClass(bytes4 assetClass) external view;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/listing/IListingController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\nimport \"./Listings.sol\";\nimport \"../renting/Rentings.sol\";\n\ninterface IListingController is IERC165 {\n    /**\n     * @dev Thrown when the listing strategy ID does not match the required one.\n     * @param provided Provided listing strategy ID.\n     * @param required Required listing strategy ID.\n     */\n    error ListingStrategyMismatch(bytes4 provided, bytes4 required);\n\n    /**\n     * @dev Returns implemented strategy ID.\n     * @return Listing strategy ID.\n     */\n    function strategyId() external pure returns (bytes4);\n\n    /**\n     * @dev Calculates rental fee based on renting params and implemented listing strategy.\n     * @param listingParams Listing strategy params.\n     * @param rentingParams Renting params.\n     * @return Asset rental fee (base tokens per second).\n     */\n    function calculateRentalFee(Listings.Params calldata listingParams, Rentings.Params calldata rentingParams)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/listing/IListingStrategyRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./Listings.sol\";\nimport \"./IListingController.sol\";\n\ninterface IListingStrategyRegistry {\n    /**\n     * @dev Thrown when listing controller does not implement the required interface.\n     */\n    error InvalidListingControllerInterface();\n\n    /**\n     * @dev Thrown when the listing cannot be processed by the specific controller due to the listing strategy ID\n     * mismatch.\n     * @param provided Provided listing strategy ID.\n     * @param required Required listing strategy ID.\n     */\n    error ListingStrategyMismatch(bytes4 provided, bytes4 required);\n\n    /**\n     * @dev Thrown upon attempting to register a listing strategy twice.\n     * @param strategyId Duplicate listing strategy ID.\n     */\n    error ListingStrategyIsAlreadyRegistered(bytes4 strategyId);\n\n    /**\n     * @dev Thrown upon attempting to work with unregistered listing strategy.\n     * @param strategyId Listing strategy ID.\n     */\n    error UnregisteredListingStrategy(bytes4 strategyId);\n\n    /**\n     * @dev Emitted when the new listing strategy is registered.\n     * @param strategyId Listing strategy ID.\n     * @param controller Controller address.\n     */\n    event ListingStrategyRegistered(bytes4 indexed strategyId, address indexed controller);\n\n    /**\n     * @dev Emitted when the listing strategy controller is changed.\n     * @param strategyId Listing strategy ID.\n     * @param newController Controller address.\n     */\n    event ListingStrategyControllerChanged(bytes4 indexed strategyId, address indexed newController);\n\n    /**\n     * @dev Listing strategy information.\n     * @param controller Listing controller address.\n     */\n    struct StrategyConfig {\n        address controller;\n    }\n\n    /**\n     * @dev Registers new listing strategy.\n     * @param strategyId Listing strategy ID.\n     * @param config Listing strategy configuration.\n     */\n    function registerListingStrategy(bytes4 strategyId, StrategyConfig calldata config) external;\n\n    /**\n     * @dev Sets listing strategy controller.\n     * @param strategyId Listing strategy ID.\n     * @param controller Listing controller address.\n     */\n    function setListingController(bytes4 strategyId, address controller) external;\n\n    /**\n     * @dev Returns listing strategy configuration.\n     * @param strategyId Listing strategy ID.\n     * @return Listing strategy information.\n     */\n    function listingStrategy(bytes4 strategyId) external view returns (StrategyConfig memory);\n\n    /**\n     * @dev Returns listing strategy controller.\n     * @param strategyId Listing strategy ID.\n     * @return Listing controller address.\n     */\n    function listingController(bytes4 strategyId) external view returns (address);\n\n    /**\n     * @dev Checks listing strategy registration.\n     * @param strategyId Listing strategy ID.\n     */\n    function isRegisteredListingStrategy(bytes4 strategyId) external view returns (bool);\n\n    /**\n     * @dev Reverts if listing strategy is not registered.\n     * @param strategyId Listing strategy ID.\n     */\n    function checkRegisteredListingStrategy(bytes4 strategyId) external view;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165CheckerUpgradeable {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165Upgradeable).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165Upgradeable.supportsInterface.selector, interfaceId);\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\n        if (result.length < 32) return false;\n        return success && abi.decode(result, (bool));\n    }\n}\n"
    },
    "contracts/warper/IWarperController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../accounting/Accounts.sol\";\nimport \"../asset/Assets.sol\";\nimport \"../renting/Rentings.sol\";\nimport \"../asset/IAssetController.sol\";\nimport \"./IWarper.sol\";\n\ninterface IWarperController is IAssetController {\n    /**\n     * @dev Thrown if warper interface is not compatible with the controller.\n     */\n    error IncompatibleWarperInterface();\n\n    /**\n     * @dev Thrown upon attempting to use the warper with an asset different from the one expected by the warper.\n     */\n    error InvalidAssetForWarper(address warper, address asset);\n\n    /**\n     * @dev Thrown upon attempting to rent a warped asset which is already rented.\n     */\n    error AlreadyRented();\n\n    /**\n     * @dev Takes an existing asset and then mints a warper token representing it.\n     *      Used in Metahub->Warper communication.\n     * @param asset The asset that must be warped.\n     * @param warper Warper contract to used for warping.\n     * @param to The account which will receive the warped asset.\n     * @return warpedCollectionId Warped collection ID.\n     * @return warpedAsset Warper asset structure.\n     */\n    function warp(\n        Assets.Asset calldata asset,\n        address warper,\n        address to\n    ) external returns (bytes32 warpedCollectionId, Assets.Asset memory warpedAsset);\n\n    /**\n     * @dev Executes warper rental hook.\n     * @param rentalId Rental agreement ID.\n     * @param rentalAgreement Newly registered rental agreement details.\n     * @param rentalEarnings The rental earnings breakdown.\n     */\n    function executeRentingHooks(\n        uint256 rentalId,\n        Rentings.Agreement calldata rentalAgreement,\n        Accounts.RentalEarnings calldata rentalEarnings\n    ) external;\n\n    /**\n     * @dev Validates that the warper interface is supported by the current WarperController.\n     * @param warper Warper whose interface we must validate.\n     * @return bool - `true` if warper is supported.\n     */\n    function isCompatibleWarper(address warper) external view returns (bool);\n\n    /**\n     * @dev Reverts if provided warper is not compatible with the controller.\n     */\n    function checkCompatibleWarper(address warper) external view;\n\n    /**\n     * @dev Validates renting params taking into account various warper mechanics.\n     * Throws an error if the specified asset cannot be rented with particular renting parameters.\n     * @param asset Asset being rented.\n     * @param rentingParams Renting parameters.\n     */\n    function validateRentingParams(Assets.Asset calldata asset, Rentings.Params calldata rentingParams) external view;\n\n    /**\n     * @dev Calculates the universe and/or lister premiums.\n     * Those are extra amounts that should be added the the resulting rental fee paid by renter.\n     * @param asset Asset being rented.\n     * @param rentingParams Renting parameters.\n     * @param universeFee The current value of the universe fee component.\n     * @param listerFee The current value of the lister fee component.\n     * @return universePremium The universe premium amount.\n     * @return listerPremium The lister premium amount.\n     */\n    function calculatePremiums(\n        Assets.Asset calldata asset,\n        Rentings.Params calldata rentingParams,\n        uint256 universeFee,\n        uint256 listerFee\n    ) external view returns (uint256 universePremium, uint256 listerPremium);\n}\n"
    },
    "contracts/warper/IWarperPresetFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ninterface IWarperPresetFactory {\n    /**\n     * @dev Thrown when the implementation does not support the IWarperPreset interface\n     */\n    error InvalidWarperPresetInterface();\n\n    /**\n     * @dev Thrown when the warper preset id is already present in the storage.\n     */\n    error DuplicateWarperPresetId(bytes32 presetId);\n\n    /**\n     * @dev Thrown when the warper preset has been disabled, when it was expected for it to be enabled.\n     */\n    error DisabledWarperPreset(bytes32 presetId);\n\n    /**\n     * @dev Thrown when the warper preset has been enabled, when it was expected for it to be disabled.\n     */\n    error EnabledWarperPreset(bytes32 presetId);\n\n    /**\n     * @dev Thrown when it was expected for the warper preset to be registeredr.\n     */\n    error WarperPresetNotRegistered(bytes32 presetId);\n\n    /**\n     * @dev Thrown when the provided preset initialization data is empty.\n     */\n    error EmptyPresetData();\n\n    struct WarperPreset {\n        bytes32 id;\n        address implementation;\n        bool enabled;\n    }\n\n    /**\n     * @dev Emitted when new warper preset is added.\n     */\n    event WarperPresetAdded(bytes32 indexed presetId, address indexed implementation);\n\n    /**\n     * @dev Emitted when a warper preset is disabled.\n     */\n    event WarperPresetDisabled(bytes32 indexed presetId);\n\n    /**\n     * @dev Emitted when a warper preset is enabled.\n     */\n    event WarperPresetEnabled(bytes32 indexed presetId);\n\n    /**\n     * @dev Emitted when a warper preset is enabled.\n     */\n    event WarperPresetRemoved(bytes32 indexed presetId);\n\n    /**\n     * @dev Emitted when a warper preset is deployed.\n     */\n    event WarperPresetDeployed(bytes32 indexed presetId, address indexed warper);\n\n    /**\n     * @dev Stores the association between `presetId` and `implementation` address.\n     * NOTE: Warper `implementation` must be deployed beforehand.\n     * @param presetId Warper preset id.\n     * @param implementation Warper implementation address.\n     */\n    function addPreset(bytes32 presetId, address implementation) external;\n\n    /**\n     * @dev Removes the association between `presetId` and its implementation.\n     * @param presetId Warper preset id.\n     */\n    function removePreset(bytes32 presetId) external;\n\n    /**\n     * @dev Enables warper preset, which makes it deployable.\n     * @param presetId Warper preset id.\n     */\n    function enablePreset(bytes32 presetId) external;\n\n    /**\n     * @dev Disable warper preset, which makes non-deployable.\n     * @param presetId Warper preset id.\n     */\n    function disablePreset(bytes32 presetId) external;\n\n    /**\n     * @dev Deploys a new warper from the preset identified by `presetId`.\n     * @param presetId Warper preset id.\n     * @param initData Warper initialization payload.\n     * @return Deployed warper address.\n     */\n    function deployPreset(bytes32 presetId, bytes calldata initData) external returns (address);\n\n    /**\n     * @dev Checks whether warper preset is enabled and available for deployment.\n     * @param presetId Warper preset id.\n     */\n    function presetEnabled(bytes32 presetId) external view returns (bool);\n\n    /**\n     * @dev Returns the list of all registered warper presets.\n     */\n    function presets() external view returns (WarperPreset[] memory);\n\n    /**\n     * @dev Returns the warper preset details.\n     * @param presetId Warper preset id.\n     */\n    function preset(bytes32 presetId) external view returns (WarperPreset memory);\n}\n"
    },
    "contracts/warper/IWarperManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../asset/IAssetController.sol\";\nimport \"./Warpers.sol\";\n\ninterface IWarperManager {\n    /**\n     * @dev Warper registration params.\n     * @param name The warper name.\n     * @param universeId The universe ID.\n     * @param paused Indicates whether the warper should stay paused after registration.\n     */\n    struct WarperRegistrationParams {\n        string name;\n        uint256 universeId;\n        bool paused;\n    }\n\n    /**\n     * @dev Emitted when a new warper is registered.\n     * @param universeId Universe ID.\n     * @param warper Warper address.\n     * @param original Original asset address.\n     * @param assetClass Asset class ID (identical for the `original` and `warper`).\n     */\n    event WarperRegistered(\n        uint256 indexed universeId,\n        address indexed warper,\n        address indexed original,\n        bytes4 assetClass\n    );\n\n    /**\n     * @dev Emitted when the warper is no longer registered.\n     * @param warper Warper address.\n     */\n    event WarperDeregistered(address indexed warper);\n\n    /**\n     * @dev Emitted when the warper is paused.\n     * @param warper Address.\n     */\n    event WarperPaused(address indexed warper);\n\n    /**\n     * @dev Emitted when the warper pause is lifted.\n     * @param warper Address.\n     */\n    event WarperUnpaused(address indexed warper);\n\n    /**\n     * @dev Registers a new warper.\n     * The warper must be deployed and configured prior to registration,\n     * since it becomes available for renting immediately.\n     * @param warper Warper address.\n     * @param params Warper registration params.\n     */\n    function registerWarper(address warper, WarperRegistrationParams calldata params) external;\n\n    /**\n     * @dev Deletes warper registration information.\n     * All current rental agreements with the warper will stay intact, but the new rentals won't be possible.\n     * @param warper Warper address.\n     */\n    function deregisterWarper(address warper) external;\n\n    /**\n     * @dev Puts the warper on pause.\n     * Emits a {WarperPaused} event.\n     * @param warper Address.\n     */\n    function pauseWarper(address warper) external;\n\n    /**\n     * @dev Lifts the warper pause.\n     * Emits a {WarperUnpaused} event.\n     * @param warper Address.\n     */\n    function unpauseWarper(address warper) external;\n\n    /**\n     * @dev Sets the new controller address for one or multiple registered warpers.\n     * @param warpers A list of registered warper addresses which controller will be changed.\n     * @param controller Warper controller address.\n     */\n    function setWarperController(address[] calldata warpers, address controller) external;\n\n    /**\n     * @dev Reverts if asset is not supported.\n     * @param asset Asset address.\n     */\n    function checkSupportedAsset(address asset) external view;\n\n    /**\n     * @dev Reverts if warper is not registered.\n     */\n    function checkRegisteredWarper(address warper) external view;\n\n    /**\n     * @dev Returns the number of warpers belonging to the particular universe.\n     * @param universeId The universe ID.\n     * @return Warper count.\n     */\n    function universeWarperCount(uint256 universeId) external view returns (uint256);\n\n    /**\n     * @dev Returns the list of warpers belonging to the particular universe.\n     * @param universeId The universe ID.\n     * @param offset Starting index.\n     * @param limit Max number of items.\n     * @return List of warper addresses.\n     * @return List of warpers.\n     */\n    function universeWarpers(\n        uint256 universeId,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (address[] memory, Warpers.Warper[] memory);\n\n    /**\n     * @dev Returns the number of warpers associated with the particular original asset.\n     * @param original Original asset address.\n     * @return Warper count.\n     */\n    function assetWarperCount(address original) external view returns (uint256);\n\n    /**\n     * @dev Returns the list of warpers associated with the particular original asset.\n     * @param original Original asset address.\n     * @param offset Starting index.\n     * @param limit Max number of items.\n     * @return List of warper addresses.\n     * @return List of warpers.\n     */\n    function assetWarpers(\n        address original,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (address[] memory, Warpers.Warper[] memory);\n\n    /**\n     * @dev Returns warper preset factory address.\n     */\n    function warperPresetFactory() external view returns (address);\n\n    /**\n     * @dev Returns the Metahub address.\n     */\n    function metahub() external view returns (address);\n\n    /**\n     * @dev Checks whether `account` is the `warper` admin.\n     * @param warper Warper address.\n     * @param account Account address.\n     * @return True if the `account` is the admin of the `warper` and false otherwise.\n     */\n    function isWarperAdmin(address warper, address account) external view returns (bool);\n\n    /**\n     * @dev Returns registered warper details.\n     * @param warper Warper address.\n     * @return Warper details.\n     */\n    function warperInfo(address warper) external view returns (Warpers.Warper memory);\n\n    /**\n     * @dev Returns warper controller address.\n     * @param warper Warper address.\n     * @return Current controller.\n     */\n    function warperController(address warper) external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/warper/IWarper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\n\ninterface IWarper is IERC165 {\n    /**\n     * @dev Returns the original asset address.\n     */\n    function __original() external view returns (address);\n\n    /**\n     * @dev Returns the Metahub address.\n     */\n    function __metahub() external view returns (address);\n\n    /**\n     * @dev Returns the warper asset class ID.\n     */\n    function __assetClass() external view returns (bytes4);\n\n    /**\n     * @dev Validates if a warper supports multiple interfaces at once.\n     * @return an array of `bool` flags in order as the `interfaceIds` were passed.\n     */\n    function __supportedInterfaces(bytes4[] memory interfaceIds) external view returns (bool[] memory);\n}\n"
    },
    "contracts/warper/mechanics/renting-hook/IRentingHookMechanics.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\nimport \"../../../renting/Rentings.sol\";\nimport \"../../../accounting/Accounts.sol\";\n\ninterface IRentingHookMechanics {\n    /**\n     * @dev Thrown when the renting hook execution failed due to the `reason`.\n     */\n    error RentingHookError(string reason);\n\n    /**\n     * @dev Executes arbitrary logic after successful renting.\n     * NOTE: This function should not revert directly and must set correct `success` value instead.\n     *\n     * @param rentalId Rental agreement ID.\n     * @param tokenId The token ID.\n     * @param amount The token amount.\n     * @param rentalAgreement Newly registered rental agreement details.\n     * @param rentalEarnings The rental earnings breakdown.\n     * @return success True if hook was executed successfully.\n     * @return errorMessage The reason of the hook execution failure.\n     */\n    function __onRent(\n        uint256 rentalId,\n        uint256 tokenId,\n        uint256 amount,\n        Rentings.Agreement calldata rentalAgreement,\n        Accounts.RentalEarnings calldata rentalEarnings\n    ) external returns (bool success, string memory errorMessage);\n}\n"
    },
    "contracts/mocks/WarperRentalHook.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\nimport \"../warper/ERC721/ERC721Warper.sol\";\nimport \"../warper/mechanics/renting-hook/IRentingHookMechanics.sol\";\n\ncontract WarperWithRenting is IRentingHookMechanics, ERC721Warper {\n    uint256 public rentalId;\n    uint256 public tokenId;\n    uint256 public amount;\n    Rentings.Agreement public rentalAgreement;\n    Accounts.RentalEarnings public rentalEarnings;\n\n    bool public successState = true;\n\n    function __initialize(address original, address metahub) external virtual warperInitializer {\n        _Warper_init(original, metahub);\n    }\n\n    function setSuccessState(bool successState_) external {\n        successState = successState_;\n    }\n\n    function __onRent(\n        uint256 rentalId_,\n        uint256 tokenId_,\n        uint256 amount_,\n        Rentings.Agreement calldata rentalAgreement_,\n        Accounts.RentalEarnings calldata rentalEarnings_\n    ) external override returns (bool success, string memory errorMessage) {\n        rentalId = rentalId_;\n        tokenId = tokenId_;\n        amount = amount_;\n        rentalAgreement = rentalAgreement_;\n        rentalEarnings = rentalEarnings_;\n\n        success = successState;\n        errorMessage = \"There was an error!\";\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return interfaceId == type(IRentingHookMechanics).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/warper/ERC721/ERC721Warper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable ordering\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC721Receiver.sol\";\nimport \"../../metahub/IMetahub.sol\";\nimport \"../../renting/Rentings.sol\";\nimport \"../Warper.sol\";\nimport \"./IERC721Warper.sol\";\nimport \"./IERC721WarperController.sol\";\n\n/**\n * @title Warper for the ERC721 token contract\n */\nabstract contract ERC721Warper is IERC721Warper, Warper {\n    using ERC165Checker for address;\n    using Address for address;\n\n    /**\n     * @dev Mapping from token ID to owner address\n     */\n    mapping(uint256 => address) private _owners;\n\n    /**\n     * @inheritdoc IWarper\n     */\n    // solhint-disable-next-line private-vars-leading-underscore\n    function __assetClass() external pure returns (bytes4) {\n        return Assets.ERC721;\n    }\n\n    /**\n     * @inheritdoc IERC721\n     * @dev Method is disabled, kept only for interface compatibility purposes.\n     */\n    function setApprovalForAll(address, bool) external virtual {\n        revert MethodNotAllowed();\n    }\n\n    /**\n     * @inheritdoc IERC721\n     * @dev Method is disabled, kept only for interface compatibility purposes.\n     */\n    function approve(address, uint256) external virtual {\n        revert MethodNotAllowed();\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - needs to pass validation of `_beforeTokenTransfer()`.\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function mint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external {\n        if (to == address(0)) revert MintToTheZeroAddress();\n        if (_exists(tokenId)) revert TokenIsAlreadyMinted(tokenId);\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        if (!_checkOnERC721Received(address(0), to, tokenId, data)) {\n            revert TransferToNonERC721ReceiverImplementer(to);\n        }\n    }\n\n    /**\n     * @inheritdoc IERC721\n     *\n     * @dev Need to fulfill all the requirements of `_transfer()`\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external {\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     *\n     * @dev Need to fulfill all the requirements of `_transfer()`\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @inheritdoc IERC721\n     *\n     * @dev Need to fulfill all the requirements of `_transfer()`\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public {\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(Warper, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721Warper).interfaceId ||\n            interfaceId == type(IERC721).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     * @dev The rental count calculations get offloaded to the Metahub\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        IERC721WarperController warperController = _warperController();\n        return warperController.rentalBalance(_metahub(), address(this), owner);\n    }\n\n    /**\n     * @inheritdoc IERC721\n     * @dev The ownership is dependant on the rental status - metahub is\n     *      responsible for tracking the state:\n     *          - NONE: revert with an error\n     *          - AVAILABLE: means, that the token is not currently rented. Metahub is the owner.\n     *          - RENTED: Use the Warpers internal ownership constructs\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        // Special rent-sate handling\n        {\n            Rentings.RentalStatus rentalStatus = _getWarperRentalStatus(tokenId);\n\n            if (rentalStatus == Rentings.RentalStatus.NONE) revert OwnerQueryForNonexistentToken(tokenId);\n            if (rentalStatus == Rentings.RentalStatus.AVAILABLE) return _metahub();\n        }\n\n        // `rentalStatus` is now RENTED\n        // Fallback to using the internal owner tracker\n        address owner = _owners[tokenId];\n        if (owner == address(0)) revert OwnerQueryForNonexistentToken(tokenId);\n\n        return owner;\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        Rentings.RentalStatus rentalStatus = _getWarperRentalStatus(tokenId);\n        if (rentalStatus == Rentings.RentalStatus.NONE) revert OwnerQueryForNonexistentToken(tokenId);\n\n        return _metahub();\n    }\n\n    /**\n     * @inheritdoc IERC721\n     */\n    function isApprovedForAll(address, address operator) public view returns (bool) {\n        return operator == _metahub();\n    }\n\n    /**\n     * @dev Validates the original NFT.\n     */\n    function _validateOriginal(address original) internal virtual override {\n        if (!original.supportsInterface(type(IERC721Metadata).interfaceId)) {\n            revert InvalidOriginalTokenInterface(original, type(IERC721Metadata).interfaceId);\n        }\n        super._validateOriginal(original);\n    }\n\n    /**\n     * @dev ONLY THE METAHUB CAN CALL THIS METHOD.\n     *      This validates every single transfer that the warper can perform.\n     *      Metahub can be the only source of transfers, so it can properly synchronise\n     *      the rental agreement ownership.\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal onlyMetahub {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - Needs to fulfill all the requirements of `_transfer()`\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal {\n        _transfer(from, to, tokenId);\n        if (!_checkOnERC721Received(from, to, tokenId, data)) {\n            revert TransferToNonERC721ReceiverImplementer(to);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - needs to pass validation of `_beforeTokenTransfer()`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        if (!_exists(tokenId)) revert OperatorQueryForNonexistentToken(tokenId);\n        if (to == address(0)) revert TransferToTheZeroAddress();\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Get the associated warper controller.\n     */\n    function _warperController() internal view returns (IERC721WarperController) {\n        return IERC721WarperController(IMetahub(_metahub()).warperController(address(this)));\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (!to.isContract()) return true;\n\n        try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 result) {\n            return result == IERC721Receiver.onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert TransferToNonERC721ReceiverImplementer(to);\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Get the rental status of a token.\n     */\n    function _getWarperRentalStatus(uint256 tokenId) private view returns (Rentings.RentalStatus) {\n        IERC721WarperController warperController = _warperController();\n        return warperController.rentalStatus(_metahub(), address(this), tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\n        if (result.length < 32) return false;\n        return success && abi.decode(result, (bool));\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/extensions/IERC721Metadata.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721Receiver.sol\";\n"
    },
    "contracts/metahub/IMetahub.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable no-empty-blocks\npragma solidity ^0.8.13;\n\nimport \"../accounting/IPaymentManager.sol\";\nimport \"../listing/IListingManager.sol\";\nimport \"../renting/IRentingManager.sol\";\nimport \"../asset/IAssetManager.sol\";\nimport \"./IProtocolConfigManager.sol\";\n\ninterface IMetahub is IProtocolConfigManager, IPaymentManager, IListingManager, IRentingManager, IAssetManager {}\n"
    },
    "contracts/warper/Warper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore, func-name-mixedcase\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"./IWarper.sol\";\nimport \"./utils/CallForwarder.sol\";\nimport \"./utils/WarperContext.sol\";\n\nabstract contract Warper is IWarper, WarperContext, CallForwarder, Multicall {\n    using ERC165Checker for address;\n\n    /**\n     * @dev Thrown when the original asset contract does not implement the interface, expected by Warper.\n     */\n    error InvalidOriginalTokenInterface(address original, bytes4 requiredInterfaceId);\n\n    /**\n     * @dev Forwards the current call to the original asset contract. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Forwards the current call to the original asset contract`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Warper initializer.\n     *\n     */\n    function _Warper_init(address original, address metahub) internal onlyInitializingWarper {\n        _validateOriginal(original);\n        _setOriginal(original);\n        _setMetahub(metahub);\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165) returns (bool) {\n        return\n            interfaceId == type(IWarper).interfaceId ||\n            interfaceId == type(IERC165).interfaceId ||\n            _original().supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IWarper\n     */\n    function __supportedInterfaces(bytes4[] memory interfaceIds) external view returns (bool[] memory) {\n        return address(this).getSupportedInterfaces(interfaceIds);\n    }\n\n    /**\n     * @dev Returns the original NFT address.\n     */\n    function __original() external view returns (address) {\n        return _original();\n    }\n\n    /**\n     * @inheritdoc IWarper\n     */\n    function __metahub() external view returns (address) {\n        return _metahub();\n    }\n\n    /**\n     * @dev Forwards the current call to the original asset contract`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _forward(_original());\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the original. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Validates the original NFT.\n     *\n     * If overridden should call `super._validateOriginal()`.\n     */\n    function _validateOriginal(address original) internal virtual {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n"
    },
    "contracts/warper/ERC721/IERC721Warper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"../IWarper.sol\";\n\ninterface IERC721Warper is IWarper, IERC721 {\n    /**\n     * @dev Thrown when querying token balance for address(0)\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * @dev Thrown when querying for the owner of a token that has not been minted yet.\n     */\n    error OwnerQueryForNonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Thrown when querying for the operator of a token that has not been minted yet.\n     */\n    error OperatorQueryForNonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Thrown when attempting to safeTransfer to a contract that cannot handle ERC721 tokens.\n     */\n    error TransferToNonERC721ReceiverImplementer(address to);\n\n    /**\n     * @dev Thrown when minting to the address(0).\n     */\n    error MintToTheZeroAddress();\n\n    /**\n     * @dev Thrown when minting a token that already exists.\n     */\n    error TokenIsAlreadyMinted(uint256 tokenId);\n\n    /**\n     * @dev Thrown transferring a token to the address(0).\n     */\n    error TransferToTheZeroAddress();\n\n    /**\n     * @dev Thrown when calling a method that has been purposely disabled.\n     */\n    error MethodNotAllowed();\n\n    /**\n     * @dev Mint new tokens.\n     * @param to The address to mint the token to.\n     * @param tokenId The ID of the token to mint.\n     * @param data The data to send over to the receiver if it supports `onERC721Received` hook.\n     */\n    function mint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external;\n}\n"
    },
    "contracts/warper/ERC721/IERC721WarperController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../IWarperController.sol\";\nimport \"../../asset/Assets.sol\";\n\ninterface IERC721WarperController is IWarperController {\n    /**\n     * @dev Get the active rental balance for a given warper and a renter.\n     *      Used in Warper->Metahub communication.\n     * @param metahub Address of the metahub.\n     * @param warper Address of the warper.\n     * @param renter Address of the renter whose active rental counts we need to fetch.\n     */\n    function rentalBalance(\n        address metahub,\n        address warper,\n        address renter\n    ) external view returns (uint256);\n\n    /**\n     * @dev Get the rental status of a specific token.\n     *      Used in Warper->Metahub communication.\n     * @param metahub Address of the metahub.\n     * @param warper Address of the warper.\n     * @param tokenId The token ID to be checked for status.\n     */\n    function rentalStatus(\n        address metahub,\n        address warper,\n        uint256 tokenId\n    ) external view returns (Rentings.RentalStatus);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/listing/IListingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../asset/Assets.sol\";\nimport \"../asset/IAssetController.sol\";\nimport \"../listing/IListingController.sol\";\nimport \"./Listings.sol\";\n\ninterface IListingManager {\n    /**\n     * @dev Thrown when the message sender doesn't match the asset lister address.\n     */\n    error CallerIsNotAssetLister();\n\n    /**\n     * @dev Thrown when the original asset cannot be withdrawn because of active rentals\n     * or other activity that requires asset to stay in the vault.\n     */\n    error AssetIsLocked();\n\n    /**\n     * @dev Emitted when a new asset is listed for renting.\n     * @param listingId Listing ID.\n     * @param listingGroupId Listing group ID.\n     * @param lister Lister account address.\n     * @param asset Listing asset.\n     * @param params Listing strategy parameters.\n     * @param maxLockPeriod The maximum amount of time the original asset owner can wait before getting the asset back.\n     */\n    event AssetListed(\n        uint256 indexed listingId,\n        uint256 indexed listingGroupId,\n        address indexed lister,\n        Assets.Asset asset,\n        Listings.Params params,\n        uint32 maxLockPeriod\n    );\n\n    /**\n     * @dev Emitted when the asset is no longer available for renting.\n     * @param listingId Listing ID.\n     * @param lister Lister account address.\n     * @param unlocksAt The earliest possible time when the asset can be returned to the owner.\n     */\n    event AssetDelisted(uint256 indexed listingId, address indexed lister, uint32 unlocksAt);\n\n    /**\n     * @dev Emitted when the asset is returned to the `lister`.\n     * @param listingId Listing ID.\n     * @param lister Lister account address.\n     * @param asset Returned asset.\n     */\n    event AssetWithdrawn(uint256 indexed listingId, address indexed lister, Assets.Asset asset);\n\n    /**\n     * @dev Emitted when the listing is paused.\n     * @param listingId Listing ID.\n     */\n    event ListingPaused(uint256 indexed listingId);\n\n    /**\n     * @dev Emitted when the listing pause is lifted.\n     * @param listingId Listing ID.\n     */\n    event ListingUnpaused(uint256 indexed listingId);\n\n    /**\n     * @dev Performs new asset listing.\n     * Emits an {AssetListed} event.\n     * @param asset Asset to be listed.\n     * @param params Listing strategy parameters.\n     * @param maxLockPeriod The maximum amount of time the original asset owner can wait before getting the asset back.\n     * @param immediatePayout Indicates whether the rental fee must be transferred to the lister on every renting.\n     * If FALSE, the rental fees get accumulated until withdrawn manually.\n     * @return listingId New listing ID.\n     * @return listingGroupId Listing group ID.\n     */\n    function listAsset(\n        Assets.Asset calldata asset,\n        Listings.Params calldata params,\n        uint32 maxLockPeriod,\n        bool immediatePayout\n    ) external returns (uint256 listingId, uint256 listingGroupId);\n\n    /**\n     * @dev Marks the asset as being delisted. This operation in irreversible.\n     * After delisting, the asset can only be withdrawn when it has no active rentals.\n     * Emits an {AssetDelisted} event.\n     * @param listingId Listing ID.\n     */\n    function delistAsset(uint256 listingId) external;\n\n    /**\n     * @dev Returns the asset back to the lister.\n     * Emits an {AssetWithdrawn} event.\n     * @param listingId Listing ID.\n     */\n    function withdrawAsset(uint256 listingId) external;\n\n    /**\n     * @dev Puts the listing on pause.\n     * Emits a {ListingPaused} event.\n     * @param listingId Listing ID.\n     */\n    function pauseListing(uint256 listingId) external;\n\n    /**\n     * @dev Lifts the listing pause.\n     * Emits a {ListingUnpaused} event.\n     * @param listingId Listing ID.\n     */\n    function unpauseListing(uint256 listingId) external;\n\n    /**\n     * @dev Returns the listing details by the listing ID.\n     * @param listingId Listing ID.\n     * @return Listing details.\n     */\n    function listingInfo(uint256 listingId) external view returns (Listings.Listing memory);\n\n    /**\n     * @dev Returns the number of currently registered listings.\n     * @return Listing count.\n     */\n    function listingCount() external view returns (uint256);\n\n    /**\n     * @dev Returns the paginated list of currently registered listings.\n     * @param offset Starting index.\n     * @param limit Max number of items.\n     * @return Listing IDs.\n     * @return Listings.\n     */\n    function listings(uint256 offset, uint256 limit)\n        external\n        view\n        returns (uint256[] memory, Listings.Listing[] memory);\n\n    /**\n     * @dev Returns the number of currently registered listings for the particular lister account.\n     * @param lister Lister address.\n     * @return Listing count.\n     */\n    function userListingCount(address lister) external view returns (uint256);\n\n    /**\n     * @dev Returns the paginated list of currently registered listings for the particular lister account.\n     * @param lister Lister address.\n     * @param offset Starting index.\n     * @param limit Max number of items.\n     * @return Listing IDs.\n     * @return Listings.\n     */\n    function userListings(\n        address lister,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Listings.Listing[] memory);\n\n    /**\n     * @dev Returns the number of currently registered listings for the particular original asset address.\n     * @param original Original asset address.\n     * @return Listing count.\n     */\n    function assetListingCount(address original) external view returns (uint256);\n\n    /**\n     * @dev Returns the paginated list of currently registered listings for the particular original asset address.\n     * @param original Original asset address.\n     * @param offset Starting index.\n     * @param limit Max number of items.\n     * @return Listing IDs.\n     * @return Listings.\n     */\n    function assetListings(\n        address original,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Listings.Listing[] memory);\n\n    /**\n     * @dev Returns listing strategy controller.\n     * @param strategyId Listing strategy ID.\n     * @return Listing controller address.\n     */\n    function listingController(bytes4 strategyId) external view returns (address);\n}\n"
    },
    "contracts/renting/IRentingManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./Rentings.sol\";\n\ninterface IRentingManager {\n    /**\n     * @dev Thrown when the message sender doesn't match the renter address.\n     */\n    error CallerIsNotRenter();\n\n    /**\n     * @dev Emitted when the warped asset is rented.\n     * @param rentalId Rental agreement ID.\n     * @param renter The renter account address.\n     * @param listingId The corresponding ID of the original asset listing.\n     * @param warpedAsset Rented warped asset.\n     * @param startTime The rental agreement staring time.\n     * @param endTime The rental agreement ending time.\n     */\n    event AssetRented(\n        uint256 indexed rentalId,\n        address indexed renter,\n        uint256 indexed listingId,\n        Assets.Asset warpedAsset,\n        uint32 startTime,\n        uint32 endTime\n    );\n\n    /**\n     * @dev Returns token amount from specific collection rented by particular account.\n     * @param warpedCollectionId Warped collection ID.\n     * @param renter The renter account address.\n     * @return Rented value.\n     */\n    function collectionRentedValue(bytes32 warpedCollectionId, address renter) external view returns (uint256);\n\n    /**\n     * @dev Returns the rental status of a given warped asset.\n     * @param warpedAssetId Warped asset ID.\n     * @return The asset rental status.\n     */\n    function assetRentalStatus(Assets.AssetId calldata warpedAssetId) external view returns (Rentings.RentalStatus);\n\n    /**\n     * @dev Evaluates renting params and returns rental fee breakdown.\n     * @param rentingParams Renting parameters.\n     * @return Rental fee breakdown.\n     */\n    function estimateRent(Rentings.Params calldata rentingParams) external view returns (Rentings.RentalFees memory);\n\n    /**\n     * @dev Performs renting operation.\n     * @param rentingParams Renting parameters.\n     * @param maxPaymentAmount Maximal payment amount the renter is willing to pay.\n     * @return New rental ID.\n     */\n    function rent(Rentings.Params calldata rentingParams, uint256 maxPaymentAmount) external returns (uint256);\n\n    /**\n     * @dev Returns the rental agreement details.\n     * @param rentalId Rental agreement ID.\n     * @return Rental agreement details.\n     */\n    function rentalAgreementInfo(uint256 rentalId) external view returns (Rentings.Agreement memory);\n\n    /**\n     * @dev Returns the number of currently registered rental agreements for particular renter account.\n     * @param renter Renter address.\n     * @return Rental agreement count.\n     */\n    function userRentalCount(address renter) external view returns (uint256);\n\n    /**\n     * @dev Returns the paginated list of currently registered rental agreements for particular renter account.\n     * @param renter Renter address.\n     * @param offset Starting index.\n     * @param limit Max number of items.\n     * @return Rental agreement IDs.\n     * @return Rental agreements.\n     */\n    function userRentalAgreements(\n        address renter,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Rentings.Agreement[] memory);\n}\n"
    },
    "contracts/asset/IAssetManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../warper/IWarperManager.sol\";\nimport \"../warper/IWarperController.sol\";\n\ninterface IAssetManager {\n    /**\n     * @dev Register a new asset.\n     * @param assetClass Asset class identifier.\n     * @param original The original assets address.\n     */\n    function registerAsset(bytes4 assetClass, address original) external;\n\n    /**\n     * @dev Retrieve the asset class controller for a given assetClass.\n     * @param assetClass Asset class identifier.\n     * @return The asset class controller.\n     */\n    function assetClassController(bytes4 assetClass) external view returns (address);\n\n    /**\n     * @dev Check if the given account is the admin of a warper.\n     * @param warper Address of the warper.\n     * @param account The users account to checked for the admin permissions on the warper.\n     * @return True if the account is the admin of the warper.\n     */\n    function isWarperAdmin(address warper, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the number of currently supported assets.\n     * @return Asset count.\n     */\n    function supportedAssetCount() external view returns (uint256);\n\n    /**\n     * @dev Returns the list of all supported asset addresses.\n     * @param offset Starting index.\n     * @param limit Max number of items.\n     * @return List of original asset addresses.\n     * @return List of asset config structures.\n     */\n    function supportedAssets(uint256 offset, uint256 limit)\n        external\n        view\n        returns (address[] memory, Assets.AssetConfig[] memory);\n}\n"
    },
    "contracts/metahub/IProtocolConfigManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"./Protocol.sol\";\nimport \"../warper/IWarperManager.sol\";\n\ninterface IProtocolConfigManager {\n    /**\n     * @dev Raised when the caller is not the WarperManager contract.\n     */\n    error CallerIsNotWarperManager();\n\n    /**\n     * @dev Emitted when a protocol rental fee is changed.\n     * @param rentalFeePercent New protocol rental fee percentage.\n     */\n    event ProtocolRentalFeeChanged(uint16 rentalFeePercent);\n\n    /**\n     * @dev Updates the protocol rental fee percentage.\n     * @param rentalFeePercent New protocol rental fee percentage.\n     */\n    function setProtocolRentalFeePercent(uint16 rentalFeePercent) external;\n\n    /**\n     * @dev Returns the protocol rental fee percentage.\n     * @return protocol fee percent.\n     */\n    function protocolRentalFeePercent() external view returns (uint16);\n\n    /**\n     * @dev Returns the base token that's used for stable price denomination.\n     * @return The base token address.\n     */\n    function baseToken() external view returns (address);\n\n    /**\n     * @dev Get thee Warper Controller contracts address for a given warper.\n     * @param warper the warper address.\n     * @return The Warper Controller address.\n     */\n    function warperController(address warper) external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract Multicall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n}\n"
    },
    "contracts/warper/utils/CallForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nabstract contract CallForwarder {\n    /**\n     * @dev Thrown when a call is forwarded to a zero address.\n     */\n    error CallForwardToZeroAddress();\n\n    /**\n     * @dev Forwards the current call to `target`.\n     */\n    function _forward(address target) internal {\n        // Prevent call forwarding to the zero address.\n        if (target == address(0)) {\n            revert CallForwardToZeroAddress();\n        }\n\n        uint256 value = msg.value;\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the target.\n            // out and outsize are 0 for now, as we don't know the out size yet.\n            let result := call(gas(), target, value, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // call returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/warper/utils/WarperContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../metahub/IMetahub.sol\";\nimport \"./InitializationContext.sol\";\n\nabstract contract WarperContext is Context, InitializationContext {\n    /**\n     * @dev Thrown when the message sender doesn't match the Metahub address.\n     */\n    error CallerIsNotMetahub();\n\n    /**\n     * @dev Thrown when the message sender doesn't match the warper admin address.\n     */\n    error CallerIsNotWarperAdmin();\n\n    /**\n     * @dev Metahub address slot.\n     */\n    bytes32 private constant _METAHUB_SLOT = bytes32(uint256(keccak256(\"iq.warper.metahub\")) - 1);\n\n    /**\n     * @dev Original asset address slot.\n     */\n    bytes32 private constant _ORIGINAL_SLOT = bytes32(uint256(keccak256(\"iq.warper.original\")) - 1);\n\n    /**\n     * @dev Modifier to make a function callable only by the metahub contract.\n     */\n    modifier onlyMetahub() {\n        if (_msgSender() != _metahub()) {\n            revert CallerIsNotMetahub();\n        }\n        _;\n    }\n    /**\n     * @dev Modifier to make a function callable only by the warper admin.\n     */\n    modifier onlyWarperAdmin() {\n        if (!IMetahub(_metahub()).isWarperAdmin(address(this), _msgSender())) {\n            revert CallerIsNotWarperAdmin();\n        }\n        _;\n    }\n\n    /**\n     * @dev Sets warper original asset address.\n     */\n    function _setOriginal(address original) internal onlyInitializingWarper {\n        StorageSlot.getAddressSlot(_ORIGINAL_SLOT).value = original;\n    }\n\n    /**\n     * @dev Sets warper metahub address.\n     */\n    function _setMetahub(address metahub) internal onlyInitializingWarper {\n        StorageSlot.getAddressSlot(_METAHUB_SLOT).value = metahub;\n    }\n\n    /**\n     * @dev Returns warper original asset address.\n     */\n    function _original() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ORIGINAL_SLOT).value;\n    }\n\n    /**\n     * @dev warper metahub address.\n     */\n    function _metahub() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_METAHUB_SLOT).value;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/warper/utils/InitializationContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nabstract contract InitializationContext {\n    /**\n     * @dev Thrown upon attempt to initialize a contract again.\n     */\n    error ContractIsAlreadyInitialized();\n\n    /**\n     * @dev Thrown when a function is invoked outside of initialization transaction.\n     */\n    error ContractIsNotInitializing();\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bytes32 internal constant _INITIALIZED_SLOT = bytes32(uint256(keccak256(\"iq.context.initialized\")) - 1);\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bytes32 internal constant _INITIALIZING_SLOT = bytes32(uint256(keccak256(\"iq.context.initializing\")) - 1);\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier warperInitializer() {\n        bool initialized = !(\n            StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value\n                ? _isConstructor()\n                : !StorageSlot.getBooleanSlot(_INITIALIZED_SLOT).value\n        );\n\n        if (initialized) {\n            revert ContractIsAlreadyInitialized();\n        }\n\n        bool isTopLevelCall = !StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value;\n        if (isTopLevelCall) {\n            StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value = true;\n            StorageSlot.getBooleanSlot(_INITIALIZED_SLOT).value = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializingWarper() {\n        if (!StorageSlot.getBooleanSlot(_INITIALIZING_SLOT).value) {\n            revert ContractIsNotInitializing();\n        }\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "contracts/warper/WarperManagerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n// Libraries\nimport \"../warper/Warpers.sol\";\nimport \"../acl/IACL.sol\";\nimport \"../universe/IUniverseRegistry.sol\";\nimport \"../asset/Assets.sol\";\nimport \"../metahub/IMetahub.sol\";\n\nabstract contract WarperManagerStorage {\n    /**\n     * @dev ACL contract.\n     */\n    IACL internal _aclContract;\n\n    Warpers.Registry internal _warperRegistry;\n\n    IAssetClassRegistry internal _assetClassRegistry;\n\n    IMetahub internal _metahub;\n\n    IUniverseRegistry internal _universeRegistry;\n}\n"
    },
    "contracts/acl/IACL.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol\";\n\n/**\n * @title Access Control List contract interface.\n */\ninterface IACL is IAccessControlEnumerableUpgradeable {\n    /**\n     * @dev Thrown when the Admin roles bytes is incorrectly formatted.\n     */\n    error RolesContractIncorrectlyConfigured();\n\n    /**\n     * @dev Thrown when the attempting to remove the very last admin from ACL.\n     */\n    error CannotRemoveLastAdmin();\n\n    /**\n     * @notice revert if the `account` does not have the specified role.\n     * @param role the role specifier.\n     * @param account the address to check the role for.\n     */\n    function checkRole(bytes32 role, address account) external view;\n\n    /**\n     * @notice Get the admin role describing bytes\n     * return role bytes\n     */\n    function adminRole() external pure returns (bytes32);\n\n    /**\n     * @notice Get the supervisor role describing bytes\n     * return role bytes\n     */\n    function supervisorRole() external pure returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/mocks/WarperPresetMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\nimport \"../warper/Warper.sol\";\nimport \"../warper/IWarperPreset.sol\";\n\ncontract WarperPresetMock is IWarperPreset, Warper {\n    uint256 internal _initValue;\n    uint256 internal _extraValue;\n\n    function __initialize(bytes calldata config) external warperInitializer {\n        (address original, address metahub, bytes memory presetData) = abi.decode(config, (address, address, bytes));\n\n        (uint256 initValue1, uint256 initValue2) = abi.decode(presetData, (uint256, uint256));\n        _Warper_init(original, metahub);\n        _initValue = initValue1 + initValue2;\n    }\n\n    function setExtraValue(uint256 value) external {\n        _extraValue = value;\n    }\n\n    function extraValue() external view returns (uint256) {\n        return _extraValue;\n    }\n\n    function initValue() external view returns (uint256) {\n        return _initValue;\n    }\n\n    function __assetClass() external pure returns (bytes4) {\n        return \"\";\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view override(Warper, IERC165) returns (bool) {\n        return interfaceId == type(IWarperPreset).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/warper/IWarperPreset.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\nimport \"./IWarper.sol\";\n\ninterface IWarperPreset is IWarper {\n    /**\n     * @dev Warper generic initialization method.\n     * @param config Warper configuration parameters.\n     */\n    function __initialize(bytes calldata config) external;\n}\n"
    },
    "contracts/warper/WarperPresetFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"../acl/AccessControlledUpgradeable.sol\";\nimport \"./IWarperPresetFactory.sol\";\nimport \"./IWarperPreset.sol\";\nimport \"./WarperPresetFactoryStorage.sol\";\n\n/**\n * @title Warper preset factory contract.\n */\ncontract WarperPresetFactory is\n    IWarperPresetFactory,\n    UUPSUpgradeable,\n    AccessControlledUpgradeable,\n    WarperPresetFactoryStorage\n{\n    using ClonesUpgradeable for address;\n    using AddressUpgradeable for address;\n    using ERC165CheckerUpgradeable for address;\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.Bytes32Set;\n\n    /**\n     * @dev Modifier to check that the preset is currently enabled.\n     */\n    modifier whenEnabled(bytes32 presetId) {\n        if (!_presets[presetId].enabled) revert DisabledWarperPreset(presetId);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check that the preset is currently disabled.\n     */\n    modifier whenDisabled(bytes32 presetId) {\n        if (_presets[presetId].enabled) revert EnabledWarperPreset(presetId);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check that the preset is registered.\n     */\n    modifier presetIsRegistered(bytes32 presetId) {\n        if (_presets[presetId].implementation == address(0)) revert WarperPresetNotRegistered(presetId);\n        _;\n    }\n\n    /**\n     * @dev Constructor that gets called for the implementation contract.\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() initializer {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev WarperPresetFactory initializer.\n     * @param acl Address of the ACL contract.\n     */\n    function initialize(address acl) external initializer {\n        __UUPSUpgradeable_init();\n\n        _aclContract = IACL(acl);\n    }\n\n    /**\n     * @inheritdoc IWarperPresetFactory\n     */\n    function addPreset(bytes32 presetId, address implementation) external onlySupervisor {\n        // Check whether provided implementation address is a contract with the correct interface.\n        if (!implementation.supportsInterface(type(IWarperPreset).interfaceId)) {\n            revert InvalidWarperPresetInterface();\n        }\n\n        if (_presetIds.add(presetId)) {\n            _presets[presetId] = WarperPreset(presetId, implementation, true);\n            emit WarperPresetAdded(presetId, implementation);\n        } else {\n            revert DuplicateWarperPresetId(presetId);\n        }\n    }\n\n    /**\n     * @inheritdoc IWarperPresetFactory\n     */\n    function removePreset(bytes32 presetId) external onlySupervisor {\n        if (_presetIds.remove(presetId)) {\n            delete _presets[presetId];\n            emit WarperPresetRemoved(presetId);\n        }\n    }\n\n    /**\n     * @inheritdoc IWarperPresetFactory\n     */\n    function enablePreset(bytes32 presetId)\n        external\n        presetIsRegistered(presetId)\n        whenDisabled(presetId)\n        onlySupervisor\n    {\n        _presets[presetId].enabled = true;\n        emit WarperPresetEnabled(presetId);\n    }\n\n    /**\n     * @inheritdoc IWarperPresetFactory\n     */\n    function disablePreset(bytes32 presetId)\n        external\n        presetIsRegistered(presetId)\n        whenEnabled(presetId)\n        onlySupervisor\n    {\n        _presets[presetId].enabled = false;\n        emit WarperPresetDisabled(presetId);\n    }\n\n    /**\n     * @inheritdoc IWarperPresetFactory\n     */\n    function deployPreset(bytes32 presetId, bytes calldata initData) external whenEnabled(presetId) returns (address) {\n        // Init data must never be empty here, because all presets have mandatory init params.\n        if (initData.length == 0) {\n            revert EmptyPresetData();\n        }\n\n        // Deploy warper preset implementation proxy.\n        address warper = _presets[presetId].implementation.clone();\n\n        // Initialize warper.\n        warper.functionCall(initData);\n        emit WarperPresetDeployed(presetId, warper);\n\n        return warper;\n    }\n\n    /**\n     * @inheritdoc IWarperPresetFactory\n     */\n    function presetEnabled(bytes32 presetId) external view presetIsRegistered(presetId) returns (bool) {\n        return _presets[presetId].enabled;\n    }\n\n    /**\n     * @inheritdoc IWarperPresetFactory\n     */\n    function presets() external view returns (WarperPreset[] memory) {\n        uint256 length = _presetIds.length();\n        WarperPreset[] memory warperPresets = new WarperPreset[](length);\n        for (uint256 i = 0; i < length; i++) {\n            warperPresets[i] = _presets[_presetIds.at(i)];\n        }\n        return warperPresets;\n    }\n\n    /**\n     * @inheritdoc IWarperPresetFactory\n     */\n    function preset(bytes32 presetId) external view presetIsRegistered(presetId) returns (WarperPreset memory) {\n        return _presets[presetId];\n    }\n\n    /**\n     * @inheritdoc UUPSUpgradeable\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyAdmin {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @inheritdoc AccessControlledUpgradeable\n     */\n    function _acl() internal view virtual override returns (IACL) {\n        return _aclContract;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/acl/AccessControlledUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\n\nimport \"./Roles.sol\";\nimport \"./IACL.sol\";\n\n/**\n * @title Modifier provider for contracts that want to interact with the ACL contract.\n */\nabstract contract AccessControlledUpgradeable is ContextUpgradeable {\n    /**\n     * @dev Modifier to make a function callable by the admin account.\n     */\n    modifier onlyAdmin() {\n        _acl().checkRole(Roles.ADMIN, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable by a supervisor account.\n     */\n    modifier onlySupervisor() {\n        _acl().checkRole(Roles.SUPERVISOR, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev return the IACL address\n     */\n    function _acl() internal view virtual returns (IACL);\n}\n"
    },
    "contracts/warper/WarperPresetFactoryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../acl/IACL.sol\";\nimport \"./WarperPresetFactoryStorage.sol\";\nimport \"./IWarperPresetFactory.sol\";\n\nabstract contract WarperPresetFactoryStorage {\n    /**\n     * @dev The ACL contract address.\n     */\n    IACL internal _aclContract;\n\n    /**\n     * @dev Mapping presetId to preset struct.\n     */\n    mapping(bytes32 => IWarperPresetFactory.WarperPreset) internal _presets;\n\n    /**\n     * @dev Registered presets.\n     */\n    EnumerableSetUpgradeable.Bytes32Set internal _presetIds;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/acl/Roles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title Different role definitions used by the ACL contract.\n */\nlibrary Roles {\n    /**\n     * @dev This maps directly to the OpenZeppelins AccessControl DEFAULT_ADMIN\n     */\n    bytes32 public constant ADMIN = 0x00;\n    bytes32 public constant SUPERVISOR = keccak256(\"SUPERVISOR_ROLE\");\n}\n"
    },
    "contracts/metahub/MetahubStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n// Libraries\nimport \"../accounting/Accounts.sol\";\nimport \"../universe/IUniverseRegistry.sol\";\nimport \"../asset/Assets.sol\";\nimport \"../warper/Warpers.sol\";\nimport \"../listing/Listings.sol\";\nimport \"./Protocol.sol\";\n\nimport \"../acl/IACL.sol\";\n\nabstract contract MetahubStorage {\n    /**\n     * @dev ACL contract.\n     */\n    IACL internal _aclContract;\n\n    /**\n     * @dev Protocol configuration.\n     */\n    Protocol.Config internal _protocolConfig;\n\n    /**\n     * @dev Account registry contains the data about participants' accounts and their current balances.\n     */\n    Accounts.Registry internal _accountRegistry;\n\n    /**\n     * @dev Universe registry contains the data about all registered universes and their settings.\n     */\n    IUniverseRegistry internal _universeRegistry;\n\n    /**\n     * @dev Asset registry contains the data about all registered assets and supported asset classes.\n     */\n    Assets.Registry internal _assetRegistry;\n\n    /**\n     * @dev Warper manager contains the data about all registered warpers.\n     */\n    IWarperManager internal _warperManager;\n\n    /**\n     * @dev Listing registry contains the data about all listings.\n     */\n    Listings.Registry internal _listingRegistry;\n\n    /**\n     * @dev Renting registry contains the data about all rentals.\n     */\n    Rentings.Registry internal _rentingRegistry;\n}\n"
    },
    "contracts/universe/UniverseRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../acl/IACL.sol\";\nimport \"./UniverseToken.sol\";\nimport \"./IUniverseRegistry.sol\";\n\n/**\n * @title Universe Registry storage contract.\n */\nabstract contract UniverseRegistryStorage {\n    struct Universe {\n        string name;\n        uint16 rentalFeePercent;\n    }\n\n    /**\n     * @dev ACL contract address.\n     */\n    IACL internal _aclContract;\n\n    /**\n     * @dev Universe token address.\n     */\n    IUniverseToken internal _universeToken;\n\n    /**\n     * @dev Universe token base URI.\n     */\n    string internal _baseURI;\n\n    /**\n     * @dev Mapping from token ID to the Universe structure.\n     */\n    mapping(uint256 => Universe) internal _universes;\n}\n"
    },
    "contracts/universe/UniverseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\nimport \"./IUniverseToken.sol\";\nimport \"./IUniverseRegistry.sol\";\n\n/**\n * @title Universe token contract.\n */\ncontract UniverseToken is IUniverseToken, ERC721 {\n    using Counters for Counters.Counter;\n\n    /**\n     * @dev Thrown when the message sender doesn't match the registries address.\n     */\n    error CallerIsNotRegistry();\n\n    /**\n     * @dev Registry.\n     */\n    IUniverseRegistry private immutable _registry;\n\n    /**\n     * @dev Token ID counter.\n     */\n    Counters.Counter private _tokenIdTracker;\n\n    /**\n     * @dev Modifier to make a function callable only by the registry contract.\n     */\n    modifier onlyRegistry() {\n        if (_msgSender() != address(_registry)) revert CallerIsNotRegistry();\n        _;\n    }\n\n    /**\n     * @dev UniverseToken constructor.\n     * @param registry Universe registry.\n     */\n    constructor(IUniverseRegistry registry) ERC721(\"IQVerse\", \"IQV\") {\n        _registry = registry;\n    }\n\n    /**\n     * @inheritdoc IUniverseToken\n     */\n    function mint(address to) external onlyRegistry returns (uint256 tokenId) {\n        _tokenIdTracker.increment();\n        tokenId = _tokenIdTracker.current();\n        _safeMint(to, tokenId);\n    }\n\n    /**\n     * @inheritdoc IUniverseToken\n     */\n    function currentId() external view returns (uint256) {\n        return _tokenIdTracker.current();\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) returns (bool) {\n        return interfaceId == type(IUniverseToken).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc ERC721\n     */\n    function _baseURI() internal view override returns (string memory) {\n        return _registry.universeTokenBaseURI();\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "contracts/universe/IUniverseToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721Metadata.sol\";\n\ninterface IUniverseToken is IERC721Metadata {\n    /**\n     * @dev Mints new token and transfers it to `to` address.\n     * @param to Universe owner address.\n     * @return Minted token ID.\n     */\n    function mint(address to) external returns (uint256);\n\n    /**\n     * @dev Returns current token ID.\n     */\n    function currentId() external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "contracts/mocks/SolidityInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport \"../universe/IUniverseToken.sol\";\nimport \"../warper/mechanics/asset-rentability/IAssetRentabilityMechanics.sol\";\nimport \"../warper/mechanics/availability-period/IAvailabilityPeriodMechanics.sol\";\nimport \"../warper/mechanics/rental-fee-premium/IRentalFeePremiumMechanics.sol\";\nimport \"../warper/mechanics/rental-period/IRentalPeriodMechanics.sol\";\nimport \"../warper/mechanics/renting-hook/IRentingHookMechanics.sol\";\nimport \"../warper/ERC721/IERC721Warper.sol\";\n\ncontract SolidityInterfaces {\n    struct Interface {\n        string name;\n        bytes4 id;\n    }\n\n    Interface[] internal _list;\n\n    constructor() {\n        _list.push(Interface(\"IUniverseToken\", type(IUniverseToken).interfaceId));\n        _list.push(Interface(\"IERC721\", type(IERC721).interfaceId));\n        _list.push(Interface(\"IAssetRentabilityMechanics\", type(IAssetRentabilityMechanics).interfaceId));\n        _list.push(Interface(\"IAvailabilityPeriodMechanics\", type(IAvailabilityPeriodMechanics).interfaceId));\n        _list.push(Interface(\"IRentalFeePremiumMechanics\", type(IRentalFeePremiumMechanics).interfaceId));\n        _list.push(Interface(\"IRentalPeriodMechanics\", type(IRentalPeriodMechanics).interfaceId));\n        _list.push(Interface(\"IRentingHookMechanics\", type(IRentingHookMechanics).interfaceId));\n        _list.push(Interface(\"IWarper\", type(IWarper).interfaceId));\n        _list.push(Interface(\"IERC721Warper\", type(IERC721Warper).interfaceId));\n    }\n\n    function list() external view returns (Interface[] memory) {\n        return _list;\n    }\n}\n"
    },
    "contracts/warper/mechanics/asset-rentability/IAssetRentabilityMechanics.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\ninterface IAssetRentabilityMechanics {\n    /**\n     * @dev Thrown when the asset renting is rejected by warper due to the `reason`.\n     */\n    error AssetIsNotRentable(string reason);\n\n    /**\n     * Returns information if an asset is rentable.\n     * @param renter The address of the renter.\n     * @param tokenId The token ID.\n     * @param amount The token amount.\n     * @return isRentable True if asset is rentable.\n     * @return errorMessage The reason of the asset not being rentable.\n     */\n    function __isRentableAsset(\n        address renter,\n        uint256 tokenId,\n        uint256 amount\n    ) external view returns (bool isRentable, string memory errorMessage);\n}\n"
    },
    "contracts/warper/mechanics/availability-period/IAvailabilityPeriodMechanics.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\ninterface IAvailabilityPeriodMechanics {\n    /**\n     * @dev Thrown when the current time is not withing the warper availability period.\n     */\n    error WarperIsNotAvailableForRenting(\n        uint256 currentTime,\n        uint32 availabilityPeriodStart,\n        uint32 availabilityPeriodEnd\n    );\n\n    /**\n     * @dev Returns warper availability period starting time.\n     * @return Unix timestamp after which the warper is rentable.\n     */\n    function __availabilityPeriodStart() external view returns (uint32);\n\n    /**\n     * @dev Returns warper availability period ending time.\n     * @return Unix timestamp after which the warper is NOT rentable.\n     */\n    function __availabilityPeriodEnd() external view returns (uint32);\n\n    /**\n     * @dev Returns warper availability period.\n     * @return availabilityPeriodStart Unix timestamp after which the warper is rentable.\n     * @return availabilityPeriodEnd Unix timestamp after which the warper is NOT rentable.\n     */\n    function __availabilityPeriodRange()\n        external\n        view\n        returns (uint32 availabilityPeriodStart, uint32 availabilityPeriodEnd);\n}\n"
    },
    "contracts/warper/mechanics/rental-fee-premium/IRentalFeePremiumMechanics.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\ninterface IRentalFeePremiumMechanics {\n    /**\n     * @dev Calculate extra premiums.\n     * @param renter The renter address.\n     * @param tokenId The token ID to calculate the extra premium for.\n     * @param amount The token amount.\n     * @param rentalPeriod The rental period in seconds.\n     * @param universeFee The current universe fee.\n     * @param listerFee The current lister fee.\n     * @return universePremium The universe premium price to add.\n     * @return listerPremium The lister premium price to add.\n     */\n    function __calculatePremiums(\n        address renter,\n        uint256 tokenId,\n        uint256 amount,\n        uint32 rentalPeriod,\n        uint256 universeFee,\n        uint256 listerFee\n    ) external view returns (uint256 universePremium, uint256 listerPremium);\n}\n"
    },
    "contracts/warper/mechanics/rental-period/IRentalPeriodMechanics.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\ninterface IRentalPeriodMechanics {\n    /**\n     * @dev Thrown when the requested rental period is not withing the warper allowed rental period range.\n     */\n    error WarperRentalPeriodIsOutOfRange(uint32 requestedRentalPeriod, uint32 minRentalPeriod, uint32 maxRentalPeriod);\n\n    /**\n     * @dev Returns warper minimal rental period.\n     * @return Time is seconds.\n     */\n    function __minRentalPeriod() external view returns (uint32);\n\n    /**\n     * @dev Returns warper maximal rental period.\n     * @return Time is seconds.\n     */\n    function __maxRentalPeriod() external view returns (uint32);\n\n    /**\n     * @dev Returns warper rental period range.\n     * @return minRentalPeriod The minimal amount of time the warper can be rented for.\n     * @return maxRentalPeriod The maximal amount of time the warper can be rented for.\n     */\n    function __rentalPeriodRange() external view returns (uint32 minRentalPeriod, uint32 maxRentalPeriod);\n}\n"
    },
    "contracts/listing/strategies/fixed-price/IFixedPriceListingController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../IListingController.sol\";\n\ninterface IFixedPriceListingController is IListingController {\n    /**\n     * @dev Decodes listing strategy params.\n     * @param params Encoded listing strategy params.\n     * @return baseRate Asset renting base rate (base tokens per second).\n     */\n    function decodeStrategyParams(Listings.Params memory params) external pure returns (uint256 baseRate);\n}\n"
    },
    "contracts/listing/strategies/fixed-price/FixedPriceListingController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"../../../acl/AccessControlledUpgradeable.sol\";\nimport \"../../ListingController.sol\";\n\nimport \"./IFixedPriceListingController.sol\";\nimport \"./FixedPriceListingControllerStorage.sol\";\n\ncontract FixedPriceListingController is\n    IFixedPriceListingController,\n    UUPSUpgradeable,\n    AccessControlledUpgradeable,\n    ListingController,\n    FixedPriceListingControllerStorage\n{\n    /**\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() initializer {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Contract initializer.\n     * @param acl ACL contract address.\n     */\n    function initialize(address acl) external initializer {\n        __UUPSUpgradeable_init();\n        _aclContract = IACL(acl);\n    }\n\n    /**\n     * @inheritdoc IListingController\n     */\n    function calculateRentalFee(Listings.Params calldata strategyParams, Rentings.Params calldata rentingParams)\n        external\n        pure\n        returns (uint256)\n    {\n        uint256 baseRate = decodeStrategyParams(strategyParams);\n        return rentingParams.rentalPeriod * baseRate;\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view override(ListingController, IERC165) returns (bool) {\n        return interfaceId == type(IFixedPriceListingController).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IListingController\n     */\n    function strategyId() public pure override(ListingController, IListingController) returns (bytes4) {\n        return Listings.FIXED_PRICE;\n    }\n\n    /**\n     * @inheritdoc IFixedPriceListingController\n     */\n    function decodeStrategyParams(Listings.Params memory params)\n        public\n        pure\n        compatibleStrategy(params.strategy)\n        returns (uint256 baseRate)\n    {\n        return abi.decode(params.data, (uint256));\n    }\n\n    /**\n     * @inheritdoc UUPSUpgradeable\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyAdmin {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @inheritdoc AccessControlledUpgradeable\n     */\n    function _acl() internal view override returns (IACL) {\n        return _aclContract;\n    }\n}\n"
    },
    "contracts/listing/ListingController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"./IListingController.sol\";\n\nabstract contract ListingController is IListingController, ERC165 {\n    /**\n     * @dev Modifier to check strategy compatibility.\n     */\n    modifier compatibleStrategy(bytes4 checkedStrategyId) {\n        if (checkedStrategyId != strategyId()) revert ListingStrategyMismatch(checkedStrategyId, strategyId());\n        _;\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceId == type(IListingController).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IListingController\n     */\n    function strategyId() public pure virtual returns (bytes4);\n}\n"
    },
    "contracts/listing/strategies/fixed-price/FixedPriceListingControllerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../../acl/IACL.sol\";\n\nabstract contract FixedPriceListingControllerStorage {\n    /**\n     * @dev ACL contract.\n     */\n    IACL internal _aclContract;\n}\n"
    },
    "contracts/listing/strategies/fixed-price-with-reward/FixedPriceWithRewardListingController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"../../../acl/AccessControlledUpgradeable.sol\";\nimport \"../../ListingController.sol\";\n\nimport \"./IFixedPriceWithRewardListingController.sol\";\nimport \"./FixedPriceWithRewardListingControllerStorage.sol\";\n\ncontract FixedPriceWithRewardListingController is\n    IFixedPriceWithRewardListingController,\n    UUPSUpgradeable,\n    AccessControlledUpgradeable,\n    ListingController,\n    FixedPriceWithRewardListingControllerStorage\n{\n    /**\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() initializer {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Contract initializer.\n     * @param acl ACL contract address.\n     */\n    function initialize(address acl) external initializer {\n        __UUPSUpgradeable_init();\n        _aclContract = IACL(acl);\n    }\n\n    /**\n     * @inheritdoc IListingController\n     */\n    function calculateRentalFee(Listings.Params calldata strategyParams, Rentings.Params calldata rentingParams)\n        external\n        pure\n        returns (uint256)\n    {\n        (uint256 baseRate, ) = decodeStrategyParams(strategyParams);\n        return rentingParams.rentalPeriod * baseRate;\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view override(ListingController, IERC165) returns (bool) {\n        return\n            interfaceId == type(IFixedPriceWithRewardListingController).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IListingController\n     */\n    function strategyId() public pure override(ListingController, IListingController) returns (bytes4) {\n        return Listings.FIXED_PRICE_WITH_REWARD;\n    }\n\n    /**\n     * @inheritdoc IFixedPriceWithRewardListingController\n     */\n    function decodeStrategyParams(Listings.Params memory params)\n        public\n        pure\n        compatibleStrategy(params.strategy)\n        returns (uint256 baseRate, uint16 baseRewardPercent)\n    {\n        return abi.decode(params.data, (uint256, uint16));\n    }\n\n    /**\n     * @inheritdoc UUPSUpgradeable\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyAdmin {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @inheritdoc AccessControlledUpgradeable\n     */\n    function _acl() internal view override returns (IACL) {\n        return _aclContract;\n    }\n}\n"
    },
    "contracts/listing/strategies/fixed-price-with-reward/IFixedPriceWithRewardListingController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../IListingController.sol\";\n\ninterface IFixedPriceWithRewardListingController is IListingController {\n    /**\n     * @dev Decodes listing strategy params.\n     * @param params Encoded listing strategy params.\n     * @return baseRate Asset renting base rate (base tokens per second).\n     * @return baseRewardPercent Asset renting base reward percent.\n     */\n    function decodeStrategyParams(Listings.Params memory params)\n        external\n        pure\n        returns (uint256 baseRate, uint16 baseRewardPercent);\n}\n"
    },
    "contracts/listing/strategies/fixed-price-with-reward/FixedPriceWithRewardListingControllerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../../acl/IACL.sol\";\n\nabstract contract FixedPriceWithRewardListingControllerStorage {\n    /**\n     * @dev ACL contract.\n     */\n    IACL internal _aclContract;\n}\n"
    },
    "contracts/warper/WarperManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable no-empty-blocks\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../acl/AccessControlledUpgradeable.sol\";\nimport \"./IWarperManager.sol\";\nimport \"./WarperManagerStorage.sol\";\n\ncontract WarperManager is\n    IWarperManager,\n    Initializable,\n    UUPSUpgradeable,\n    AccessControlledUpgradeable,\n    WarperManagerStorage\n{\n    using Warpers for Warpers.Registry;\n    using Warpers for Warpers.Warper;\n    using Assets for Assets.Asset;\n    using Assets for Assets.Registry;\n\n    /**\n     * @dev Metahub initialization params.\n     * @param warperPresetFactory Warper preset factory address.\n     * @param assetClassRegistry\n     * @param universeRegistry\n     * @param acl\n     */\n    struct WarperManagerInitParams {\n        IWarperPresetFactory warperPresetFactory;\n        IAssetClassRegistry assetClassRegistry;\n        IUniverseRegistry universeRegistry;\n        IACL acl;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by the warpers admin (universe owner).\n     */\n    modifier onlyWarperAdmin(address warper) {\n        _checkWarperAdmin(warper, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev Modifier to make sure that the warper has been registered beforehand.\n     */\n    modifier onlyRegisteredWarper(address warper) {\n        _warperRegistry.checkRegisteredWarper(warper);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by the universe owner.\n     */\n    modifier onlyUniverseOwner(uint256 universeId) {\n        _universeRegistry.checkUniverseOwner(universeId, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by the universe owner.\n     */\n    modifier whileMetahub(uint256 universeId) {\n        _universeRegistry.checkUniverseOwner(universeId, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev Metahub initializer.\n     * @param params Initialization params.\n     */\n    function initialize(WarperManagerInitParams calldata params) external initializer {\n        __UUPSUpgradeable_init();\n\n        _aclContract = params.acl;\n\n        _warperRegistry.presetFactory = params.warperPresetFactory;\n        _assetClassRegistry = params.assetClassRegistry;\n        _universeRegistry = params.universeRegistry;\n    }\n\n    /**\n     * @dev Set Metahub post-initialization to avoid circular dependencies.\n     */\n    function setMetahub(IMetahub metahub_) external onlyAdmin {\n        _metahub = metahub_;\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function registerWarper(address warper, WarperRegistrationParams calldata params)\n        external\n        onlyUniverseOwner(params.universeId)\n    {\n        (bytes4 assetClass, address original) = _warperRegistry.registerWarper(warper, params, _assetClassRegistry);\n\n        _metahub.registerAsset(assetClass, original);\n\n        emit WarperRegistered(params.universeId, warper, original, assetClass);\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function deregisterWarper(address warper) external onlyWarperAdmin(warper) {\n        _warperRegistry.remove(warper);\n        emit WarperDeregistered(warper);\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function pauseWarper(address warper) external onlyWarperAdmin(warper) {\n        _warperRegistry.warpers[warper].pause();\n        emit WarperPaused(warper);\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function unpauseWarper(address warper) external onlyWarperAdmin(warper) {\n        _warperRegistry.warpers[warper].unpause();\n        emit WarperUnpaused(warper);\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function setWarperController(address[] calldata warpers, address controller) external onlyAdmin {\n        for (uint256 i = 0; i < warpers.length; i++) {\n            address warper = warpers[i];\n            _warperRegistry.checkRegisteredWarper(warper);\n            IWarperController(controller).checkCompatibleWarper(warper);\n            _warperRegistry.warpers[warper].controller = IWarperController(controller);\n        }\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function warperPresetFactory() external view returns (address) {\n        return address(_warperRegistry.presetFactory);\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function metahub() external view returns (address) {\n        return address(_metahub);\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function universeWarperCount(uint256 universeId) external view returns (uint256) {\n        return _warperRegistry.universeWarperCount(universeId);\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function universeWarpers(\n        uint256 universeId,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (address[] memory, Warpers.Warper[] memory) {\n        return _warperRegistry.universeWarpers(universeId, offset, limit);\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function assetWarperCount(address original) external view returns (uint256) {\n        return _warperRegistry.assetWarperCount(original);\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function assetWarpers(\n        address original,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (address[] memory, Warpers.Warper[] memory) {\n        return _warperRegistry.assetWarpers(original, offset, limit);\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function isWarperAdmin(address warper, address account) external view onlyRegisteredWarper(warper) returns (bool) {\n        return _universeRegistry.isUniverseOwner(_warperRegistry.warpers[warper].universeId, account);\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function warperInfo(address warper) external view onlyRegisteredWarper(warper) returns (Warpers.Warper memory) {\n        return _warperRegistry.warpers[warper];\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function checkSupportedAsset(address asset) external view {\n        return _warperRegistry.checkSupportedAsset(asset);\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function checkRegisteredWarper(address warper) external view {\n        return _warperRegistry.checkRegisteredWarper(warper);\n    }\n\n    /**\n     * @inheritdoc IWarperManager\n     */\n    function warperController(address warper) external view onlyRegisteredWarper(warper) returns (address) {\n        return address(_warperRegistry.warpers[warper].controller);\n    }\n\n    /**\n     * @inheritdoc UUPSUpgradeable\n     * @dev Checks whether the caller is authorized to upgrade the Metahub implementation.\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyAdmin {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Reverts if the warpers universe owner is not the provided account address.\n     * @param warper Warpers address.\n     * @param account The address that's expected to be the warpers universe owner.\n     */\n    function _checkWarperAdmin(address warper, address account) internal view {\n        _universeRegistry.checkUniverseOwner(_warperRegistry.warpers[warper].universeId, account);\n    }\n\n    /**\n     * @inheritdoc AccessControlledUpgradeable\n     */\n    function _acl() internal view override returns (IACL) {\n        return _aclContract;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/listing/ListingStrategyRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\nimport \"../acl/AccessControlledUpgradeable.sol\";\nimport \"./IListingStrategyRegistry.sol\";\nimport \"./ListingStrategyRegistryStorage.sol\";\n\ncontract ListingStrategyRegistry is\n    IListingStrategyRegistry,\n    UUPSUpgradeable,\n    AccessControlledUpgradeable,\n    ListingStrategyRegistryStorage\n{\n    using ERC165CheckerUpgradeable for address;\n\n    /**\n     * @dev Modifier to make a function callable only for the registered listing strategy.\n     */\n    modifier onlyRegisteredStrategy(bytes4 strategyId) {\n        checkRegisteredListingStrategy(strategyId);\n        _;\n    }\n\n    /**\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() initializer {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Contract initializer.\n     * @param acl ACL contract address.\n     */\n    function initialize(address acl) external initializer {\n        __UUPSUpgradeable_init();\n        _aclContract = IACL(acl);\n    }\n\n    /**\n     * @inheritdoc IListingStrategyRegistry\n     */\n    function registerListingStrategy(bytes4 strategyId, StrategyConfig calldata config) external onlyAdmin {\n        _checkValidListingController(strategyId, config.controller);\n        if (isRegisteredListingStrategy(strategyId)) {\n            revert ListingStrategyIsAlreadyRegistered(strategyId);\n        }\n\n        _strategies[strategyId] = config;\n        emit ListingStrategyRegistered(strategyId, config.controller);\n    }\n\n    /**\n     * @inheritdoc IListingStrategyRegistry\n     */\n    function setListingController(bytes4 strategyId, address controller)\n        external\n        onlySupervisor\n        onlyRegisteredStrategy(strategyId)\n    {\n        _checkValidListingController(strategyId, controller);\n        _strategies[strategyId].controller = controller;\n        emit ListingStrategyControllerChanged(strategyId, controller);\n    }\n\n    /**\n     * @inheritdoc IListingStrategyRegistry\n     */\n    function listingController(bytes4 strategyId) external view onlyRegisteredStrategy(strategyId) returns (address) {\n        return _strategies[strategyId].controller;\n    }\n\n    /**\n     * @inheritdoc IListingStrategyRegistry\n     */\n    function listingStrategy(bytes4 strategyId)\n        external\n        view\n        onlyRegisteredStrategy(strategyId)\n        returns (StrategyConfig memory)\n    {\n        return _strategies[strategyId];\n    }\n\n    /**\n     * @inheritdoc IListingStrategyRegistry\n     */\n    function isRegisteredListingStrategy(bytes4 strategyId) public view returns (bool) {\n        return _strategies[strategyId].controller != address(0);\n    }\n\n    /**\n     * @inheritdoc IListingStrategyRegistry\n     */\n    function checkRegisteredListingStrategy(bytes4 strategyId) public view {\n        if (!isRegisteredListingStrategy(strategyId)) revert UnregisteredListingStrategy(strategyId);\n    }\n\n    /**\n     * @inheritdoc UUPSUpgradeable\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyAdmin {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Reverts if provided address is not a valid listing controller.\n     * @param strategyId Listing strategy ID.\n     * @param controller Listing controller address.\n     */\n    function _checkValidListingController(bytes4 strategyId, address controller) internal view {\n        if (!controller.supportsInterface(type(IListingController).interfaceId))\n            revert InvalidListingControllerInterface();\n\n        bytes4 contractStrategyId = IListingController(controller).strategyId();\n        if (contractStrategyId != strategyId) revert ListingStrategyMismatch(contractStrategyId, strategyId);\n    }\n\n    /**\n     * @inheritdoc AccessControlledUpgradeable\n     */\n    function _acl() internal view override returns (IACL) {\n        return _aclContract;\n    }\n}\n"
    },
    "contracts/listing/ListingStrategyRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../acl/IACL.sol\";\nimport \"./IListingStrategyRegistry.sol\";\n\nabstract contract ListingStrategyRegistryStorage {\n    /**\n     * @dev ACL contract.\n     */\n    IACL internal _aclContract;\n\n    /**\n     * @dev Mapping from listing strategy ID to the listing strategy configuration.\n     */\n    mapping(bytes4 => IListingStrategyRegistry.StrategyConfig) internal _strategies;\n}\n"
    },
    "contracts/asset/AssetController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"./IAssetController.sol\";\n\nabstract contract AssetController is IAssetController, ERC165 {\n    /**\n     * The fallback function is needed to ensure forward compatibility with Metahub.\n     * When introducing a new version of controller with additional external functions,\n     * it must be safe to call the those new functions on previous generation of controllers and it must not cause\n     * the transaction revert.\n     */\n    fallback() external {\n        // solhint-disable-previous-line no-empty-blocks, payable-fallback\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IAssetController).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/asset/ERC721/ERC721AssetController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n\nimport \"../Assets.sol\";\nimport \"../utils/DelegateContext.sol\";\nimport \"./ERC721AssetVault.sol\";\nimport \"../AssetController.sol\";\n\n/**\n * @title Asset controller for the ERC721 tokens\n */\ncontract ERC721AssetController is AssetController, DelegateContext {\n    using Assets for Assets.AssetId;\n\n    /**\n     * @dev Thrown when the asset value is invalid for ERC721 token standard.\n     */\n    error InvalidERC721Value(uint256 value);\n\n    /**\n     * @inheritdoc IAssetController\n     */\n    function assetClass() public pure returns (bytes4) {\n        return Assets.ERC721;\n    }\n\n    /**\n     * @inheritdoc IAssetController\n     */\n    function transferAssetToVault(\n        Assets.Asset memory asset,\n        address assetOwner,\n        address vault\n    ) external onlyDelegatecall {\n        _transferAsset(asset, assetOwner, vault, \"\");\n    }\n\n    /**\n     * @inheritdoc IAssetController\n     */\n    function returnAssetFromVault(Assets.Asset memory asset, address vault) external onlyDelegatecall {\n        _validateAsset(asset);\n        // Decode asset ID to extract identification data.\n        (address token, uint256 tokenId) = _decodeAssetId(asset.id);\n        IERC721AssetVault(vault).returnToOwner(token, tokenId);\n    }\n\n    /**\n     * @inheritdoc IAssetController\n     */\n    function transfer(\n        Assets.Asset memory asset,\n        address from,\n        address to,\n        bytes memory data\n    ) external onlyDelegatecall {\n        _transferAsset(asset, from, to, data);\n    }\n\n    /**\n     * @inheritdoc IAssetController\n     */\n    function collectionId(Assets.AssetId memory assetId) external pure returns (bytes32) {\n        if (assetId.class != assetClass()) revert AssetClassMismatch(assetId.class, assetClass());\n        return _collectionId(assetId.token());\n    }\n\n    /**\n     * @dev Calculates collection ID.\n     * Foe ERC721 tokens, the collection ID is calculated by hashing the contract address itself.\n     */\n    function _collectionId(address token) internal pure returns (bytes32) {\n        return keccak256(abi.encode(token));\n    }\n\n    /**\n     * @dev Executes asset transfer.\n     */\n    function _transferAsset(\n        Assets.Asset memory asset,\n        address from,\n        address to,\n        bytes memory data\n    ) internal {\n        // Make user the asset is valid before decoding and transferring.\n        _validateAsset(asset);\n\n        // Decode asset ID to extract identification data, required for transfer.\n        (address token, uint256 tokenId) = _decodeAssetId(asset.id);\n\n        // Execute safe transfer.\n        IERC721(token).safeTransferFrom(from, to, tokenId, data);\n        emit AssetTransfer(asset, from, to, data);\n    }\n\n    /**\n     * @dev Decodes asset ID and extracts identification data.\n     * @param id Asset ID structure.\n     * @return token Token contract address.\n     * @return tokenId Token ID.\n     */\n    function _decodeAssetId(Assets.AssetId memory id) internal pure returns (address token, uint256 tokenId) {\n        return abi.decode(id.data, (address, uint256));\n    }\n\n    /**\n     * @dev Encodes asset ID.\n     * @param token Token contract address.\n     * @param tokenId Token ID.\n     * @return Asset ID structure.\n     */\n    function _encodeAssetId(address token, uint256 tokenId) internal pure returns (Assets.AssetId memory) {\n        return Assets.AssetId(assetClass(), abi.encode(token, tokenId));\n    }\n\n    /**\n     * @dev Reverts if the asset params are not valid.\n     * @param asset Asset structure.\n     */\n    function _validateAsset(Assets.Asset memory asset) internal pure {\n        // Ensure correct class.\n        if (asset.id.class != assetClass()) revert AssetClassMismatch(asset.id.class, assetClass());\n        // Ensure correct value, must be 1 for NFT.\n        if (asset.value != 1) revert InvalidERC721Value(asset.value);\n    }\n}\n"
    },
    "contracts/asset/utils/DelegateContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nabstract contract DelegateContext {\n    /**\n     * @dev Thrown when a function is called directly and not through a delegatecall.\n     */\n    error FunctionMustBeCalledThroughDelegatecall();\n\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call.\n     */\n    modifier onlyDelegatecall() {\n        if (address(this) == __self) revert FunctionMustBeCalledThroughDelegatecall();\n        _;\n    }\n}\n"
    },
    "contracts/asset/ERC721/ERC721AssetVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\nimport \"../AssetVault.sol\";\nimport \"../Assets.sol\";\nimport \"./IERC721AssetVault.sol\";\n\ncontract ERC721AssetVault is IERC721AssetVault, AssetVault {\n    /**\n     * @dev Vault inventory\n     * Mapping token address -> token ID -> owner.\n     */\n    mapping(address => mapping(uint256 => address)) private _inventory;\n\n    /**\n     * @dev Constructor.\n     * @param operator First operator account.\n     * @param acl ACL contract address\n     */\n    constructor(address operator, address acl) AssetVault(operator, acl) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @inheritdoc IERC721Receiver\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata\n    ) external whenAssetDepositAllowed(operator) returns (bytes4) {\n        // Associate received asset with the original owner address.\n        // Here message sender is a token address.\n        _inventory[_msgSender()][tokenId] = from;\n\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @inheritdoc IERC721AssetVault\n     */\n    function returnToOwner(address token, uint256 tokenId) external whenAssetReturnAllowed {\n        // Check if the asset is registered and the original asset owner is known.\n        address owner = _inventory[token][tokenId];\n        if (owner == address(0)) revert AssetNotFound();\n\n        // Return asset to the owner.\n        delete _inventory[token][tokenId];\n        IERC721(token).transferFrom(address(this), owner, tokenId);\n    }\n\n    /**\n     * @inheritdoc IAssetVault\n     */\n    function assetClass() external pure returns (bytes4) {\n        return Assets.ERC721;\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(AssetVault, IERC165) returns (bool) {\n        return interfaceId == type(IERC721AssetVault).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/asset/AssetVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../acl/AccessControlled.sol\";\nimport \"./IAssetVault.sol\";\n\n/**\n * @dev During the normal operation time, only Metahub contract is allowed to initiate asset return to the original\n * asset owner. In case of emergency, the vault admin can switch vault to recovery mode, therefore allowing anyone to\n * initiate asset return.\n *\n * NOTE: There is no way to transfer asset from the vault to an arbitrary address. The asset can only be returned to\n * the rightful owner.\n *\n * Warning: All tokens transferred to the vault contract directly (not by Metahub contract) will be lost forever!!!\n *\n */\nabstract contract AssetVault is IAssetVault, AccessControlled, Pausable, ERC165 {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @dev Vault recovery mode state.\n     */\n    bool private _recovery;\n\n    /**\n     * @dev Metahub address.\n     */\n    address private _metahub;\n\n    /**\n     * @dev ACL contract.\n     */\n    IACL private _aclContract;\n\n    /**\n     * @dev Modifier to check asset deposit possibility.\n     */\n    modifier whenAssetDepositAllowed(address operator) {\n        if (operator == _metahub && !paused() && !_recovery) _;\n        else revert AssetDepositIsNotAllowed();\n    }\n\n    /**\n     * @dev Modifier to check asset return possibility.\n     */\n    modifier whenAssetReturnAllowed() {\n        if ((_msgSender() == _metahub && !paused()) || _recovery) _;\n        else revert AssetReturnIsNotAllowed();\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the vault is not in recovery mode.\n     */\n    modifier whenNotRecovery() {\n        if (_recovery) revert VaultIsInRecoveryMode();\n        _;\n    }\n\n    /**\n     * @dev Constructor.\n     * @param metahubContract Metahub contract address.\n     * @param aclContract ACL contract address.\n     */\n    constructor(address metahubContract, address aclContract) {\n        _recovery = false;\n\n        _metahub = metahubContract;\n        _aclContract = IACL(aclContract);\n    }\n\n    /**\n     * @inheritdoc IAssetVault\n     */\n    function pause() external onlySupervisor whenNotRecovery {\n        _pause();\n    }\n\n    /**\n     * @inheritdoc IAssetVault\n     */\n    function unpause() external onlySupervisor whenNotRecovery {\n        _unpause();\n    }\n\n    /**\n     * @inheritdoc IAssetVault\n     */\n    function switchToRecoveryMode() external onlyAdmin whenNotRecovery {\n        _recovery = true;\n        emit RecoveryModeActivated(_msgSender());\n    }\n\n    /**\n     * @inheritdoc IAssetVault\n     */\n    function withdrawERC20Tokens(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) external override onlyAdmin {\n        token.safeTransfer(to, amount);\n    }\n\n    /**\n     * @inheritdoc IAssetVault\n     */\n    function metahub() external view returns (address) {\n        return _metahub;\n    }\n\n    /**\n     * @inheritdoc IAssetVault\n     */\n    function isRecovery() external view returns (bool) {\n        return _recovery;\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IAssetVault).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc AccessControlled\n     */\n    function _acl() internal view override returns (IACL) {\n        return _aclContract;\n    }\n}\n"
    },
    "contracts/asset/ERC721/IERC721AssetVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721Receiver.sol\";\nimport \"../IAssetVault.sol\";\n\ninterface IERC721AssetVault is IAssetVault, IERC721Receiver {\n    /**\n     * @dev Transfers the asset to the original owner, registered upon deposit.\n     * NOTE: The asset is always returns to the owner. There is no way to send the `asset` to an arbitrary address.\n     * @param token Token address.\n     * @param tokenId Token ID.\n     */\n    function returnToOwner(address token, uint256 tokenId) external;\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/acl/AccessControlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport \"./Roles.sol\";\nimport \"./IACL.sol\";\n\n/**\n * @title Modifier provider for contracts that want to interact with the ACL contract.\n */\nabstract contract AccessControlled is Context {\n    /**\n     * @dev Modifier to make a function callable by the admin account.\n     */\n    modifier onlyAdmin() {\n        _acl().checkRole(Roles.ADMIN, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable by a supervisor account.\n     */\n    modifier onlySupervisor() {\n        _acl().checkRole(Roles.SUPERVISOR, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev return the IACL address\n     */\n    function _acl() internal view virtual returns (IACL);\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/warper/ERC721/ERC721WarperController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable code-complexity\npragma solidity ^0.8.13;\n\nimport \"../../asset/ERC721/ERC721AssetController.sol\";\nimport \"../../accounting/Accounts.sol\";\nimport \"../../renting/IRentingManager.sol\";\nimport \"../mechanics/availability-period/IAvailabilityPeriodMechanics.sol\";\nimport \"../mechanics/rental-period/IRentalPeriodMechanics.sol\";\nimport \"../mechanics/asset-rentability/IAssetRentabilityMechanics.sol\";\nimport \"../mechanics/rental-fee-premium/IRentalFeePremiumMechanics.sol\";\nimport \"../mechanics/renting-hook/IRentingHookMechanics.sol\";\nimport \"./IERC721WarperController.sol\";\nimport \"./IERC721Warper.sol\";\n\ncontract ERC721WarperController is IERC721WarperController, ERC721AssetController {\n    using Assets for Assets.Asset;\n\n    /**\n     * @inheritdoc IWarperController\n     * @dev Needs to be called with `delegatecall` from Metahub,\n     * otherwise warpers will reject the call.\n     */\n    function warp(\n        Assets.Asset calldata asset,\n        address warper,\n        address to\n    ) external onlyDelegatecall returns (bytes32 warpedCollectionId, Assets.Asset memory warpedAsset) {\n        _validateAsset(asset);\n        (address original, uint256 tokenId) = _decodeAssetId(asset.id);\n        // Make sure the correct warper is used for the asset.\n        if (original != IWarper(warper).__original()) revert InvalidAssetForWarper(warper, original);\n\n        // Encode warped asset. The tokenId of the warped asset is identical to the original one,\n        // but the address is changed to warper contract.\n        warpedAsset = Assets.Asset(_encodeAssetId(warper, tokenId), asset.value);\n        warpedCollectionId = _collectionId(warper);\n\n        // If the warped asset has never been rented before, create new instance, otherwise transfer existing one.\n        if (rentalStatus(address(this), warper, tokenId) == Rentings.RentalStatus.NONE) {\n            IERC721Warper(warper).mint(to, tokenId, new bytes(0));\n        } else {\n            _transferAsset(warpedAsset, address(this), to, new bytes(0));\n        }\n    }\n\n    /**\n     * @inheritdoc IWarperController\n     */\n    function executeRentingHooks(\n        uint256 rentalId,\n        Rentings.Agreement calldata rentalAgreement,\n        Accounts.RentalEarnings calldata rentalEarnings\n    ) external onlyDelegatecall {\n        _validateAsset(rentalAgreement.warpedAsset);\n        (address warper, uint256 tokenId) = _decodeAssetId(rentalAgreement.warpedAsset.id);\n        if (IWarper(warper).supportsInterface(type(IRentingHookMechanics).interfaceId)) {\n            (bool success, string memory errorMessage) = IRentingHookMechanics(warper).__onRent(\n                rentalId,\n                tokenId,\n                rentalAgreement.warpedAsset.value,\n                rentalAgreement,\n                rentalEarnings\n            );\n            if (!success) revert IRentingHookMechanics.RentingHookError(errorMessage);\n        }\n    }\n\n    /**\n     * @inheritdoc IWarperController\n     */\n    function checkCompatibleWarper(address warper) external view {\n        if (!isCompatibleWarper(warper)) revert IncompatibleWarperInterface();\n    }\n\n    /**\n     * @inheritdoc IWarperController\n     */\n    function validateRentingParams(Assets.Asset calldata asset, Rentings.Params calldata rentingParams) external view {\n        _validateAsset(asset);\n\n        // Ensure the warped asset is not rented.\n        address warper = rentingParams.warper;\n        (, uint256 tokenId) = _decodeAssetId(asset.id);\n        if (rentalStatus(IWarper(warper).__metahub(), warper, tokenId) == Rentings.RentalStatus.RENTED) {\n            revert AlreadyRented();\n        }\n\n        // Analyse warper functionality by checking the supported mechanics.\n        bytes4[] memory mechanics = new bytes4[](3);\n        mechanics[0] = type(IAvailabilityPeriodMechanics).interfaceId;\n        mechanics[1] = type(IRentalPeriodMechanics).interfaceId;\n        mechanics[2] = type(IAssetRentabilityMechanics).interfaceId;\n        bool[] memory supportedMechanics = IWarper(warper).__supportedInterfaces(mechanics);\n\n        // Handle availability period mechanics.\n        if (supportedMechanics[0]) {\n            (uint32 start, uint32 end) = IAvailabilityPeriodMechanics(warper).__availabilityPeriodRange();\n            if (block.timestamp < start || (block.timestamp + rentingParams.rentalPeriod) > end) {\n                revert IAvailabilityPeriodMechanics.WarperIsNotAvailableForRenting(block.timestamp, start, end);\n            }\n        }\n\n        // Handle rental period mechanics.\n        if (supportedMechanics[1]) {\n            (uint32 min, uint32 max) = IRentalPeriodMechanics(warper).__rentalPeriodRange();\n            if (rentingParams.rentalPeriod < min || rentingParams.rentalPeriod > max) {\n                revert IRentalPeriodMechanics.WarperRentalPeriodIsOutOfRange(rentingParams.rentalPeriod, min, max);\n            }\n        }\n\n        // Handle asset rentability mechanics.\n        if (supportedMechanics[2]) {\n            (bool isRentable, string memory errorMessage) = IAssetRentabilityMechanics(warper).__isRentableAsset(\n                rentingParams.renter,\n                tokenId,\n                asset.value\n            );\n            if (!isRentable) revert IAssetRentabilityMechanics.AssetIsNotRentable(errorMessage);\n        }\n    }\n\n    /**\n     * @inheritdoc IWarperController\n     */\n    function calculatePremiums(\n        Assets.Asset calldata asset,\n        Rentings.Params calldata rentingParams,\n        uint256 universeFee,\n        uint256 listerFee\n    ) external view virtual returns (uint256 universePremium, uint256 listerPremium) {\n        _validateAsset(asset);\n        if (IWarper(rentingParams.warper).supportsInterface(type(IRentalFeePremiumMechanics).interfaceId)) {\n            (, uint256 tokenId) = _decodeAssetId(asset.id);\n            return\n                IRentalFeePremiumMechanics(rentingParams.warper).__calculatePremiums(\n                    rentingParams.renter,\n                    tokenId,\n                    asset.value,\n                    rentingParams.rentalPeriod,\n                    universeFee,\n                    listerFee\n                );\n        }\n        return (0, 0);\n    }\n\n    /**\n     * @inheritdoc IERC721WarperController\n     */\n    function rentalBalance(\n        address metahub,\n        address warper,\n        address renter\n    ) external view returns (uint256) {\n        return IRentingManager(metahub).collectionRentedValue(_collectionId(warper), renter);\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(AssetController, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(IERC721WarperController).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IWarperController\n     */\n    function isCompatibleWarper(address warper) public view returns (bool) {\n        return IWarper(warper).supportsInterface(type(IERC721Warper).interfaceId);\n    }\n\n    /**\n     * @inheritdoc IERC721WarperController\n     */\n    function rentalStatus(\n        address metahub,\n        address warper,\n        uint256 tokenId\n    ) public view returns (Rentings.RentalStatus) {\n        return IRentingManager(metahub).assetRentalStatus(_encodeAssetId(warper, tokenId));\n    }\n}\n"
    },
    "contracts/warper/mechanics/rental-period/IConfigurableRentalPeriodExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\nimport \"./IRentalPeriodMechanics.sol\";\n\ninterface IConfigurableRentalPeriodExtension is IRentalPeriodMechanics {\n    /**\n     * @dev Thrown when the the min rental period is not strictly lesser than max rental period\n     */\n    error InvalidMinRentalPeriod();\n\n    /**\n     * @dev Thrown when the max rental period is not greater or equal than min rental period\n     */\n    error InvalidMaxRentalPeriod();\n\n    /**\n     * @dev Sets warper min rental period.\n     * @param minRentalPeriod New min rental period value.\n     */\n    function __setMinRentalPeriod(uint32 minRentalPeriod) external;\n\n    /**\n     * @dev Sets warper max rental period.\n     * @param maxRentalPeriod New max rental period value.\n     */\n    function __setMaxRentalPeriod(uint32 maxRentalPeriod) external;\n}\n"
    },
    "contracts/warper/mechanics/rental-period/ConfigurableRentalPeriodExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore, func-name-mixedcase, ordering\npragma solidity ^0.8.13;\n\nimport \"../../Warper.sol\";\nimport \"./IConfigurableRentalPeriodExtension.sol\";\n\nabstract contract ConfigurableRentalPeriodExtension is IConfigurableRentalPeriodExtension, Warper {\n    /**\n     * @dev Warper rental period.\n     * @dev It contains both - the min and max values (uint32) - in a concatenated form.\n     */\n    bytes32 private constant _RENTAL_PERIOD_SLOT = bytes32(uint256(keccak256(\"iq.warper.params.rentalPeriod\")) - 1);\n\n    uint256 private constant _MAX_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000;\n    uint256 private constant _MIN_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFF;\n    uint256 private constant _MAX_PERIOD_BITSHIFT = 0;\n    uint256 private constant _MIN_PERIOD_BITSHIFT = 32;\n\n    /**\n     * @dev Extension initializer.\n     */\n    function _ConfigurableRentalPeriodExtension_init() internal onlyInitializingWarper {\n        // Store default values.\n        _setRentalPeriods(0, type(uint32).max);\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(Warper) returns (bool) {\n        return\n            interfaceId == type(IConfigurableRentalPeriodExtension).interfaceId ||\n            interfaceId == type(IRentalPeriodMechanics).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc IConfigurableRentalPeriodExtension\n     */\n    function __setMinRentalPeriod(uint32 minRentalPeriod) external virtual onlyWarperAdmin {\n        (, uint32 maxRentalPeriod) = _rentalPeriods();\n        if (minRentalPeriod > maxRentalPeriod) revert InvalidMinRentalPeriod();\n\n        _setRentalPeriods(minRentalPeriod, maxRentalPeriod);\n    }\n\n    /**\n     * @inheritdoc IConfigurableRentalPeriodExtension\n     */\n    function __setMaxRentalPeriod(uint32 maxRentalPeriod) external virtual onlyWarperAdmin {\n        (uint32 minRentalPeriod, ) = _rentalPeriods();\n        if (minRentalPeriod > maxRentalPeriod) revert InvalidMaxRentalPeriod();\n\n        _setRentalPeriods(minRentalPeriod, maxRentalPeriod);\n    }\n\n    /**\n     * @inheritdoc IRentalPeriodMechanics\n     */\n    function __minRentalPeriod() external view virtual returns (uint32) {\n        (uint32 minRentalPeriod, ) = _rentalPeriods();\n        return minRentalPeriod;\n    }\n\n    /**\n     * @inheritdoc IRentalPeriodMechanics\n     */\n    function __maxRentalPeriod() external view virtual override returns (uint32) {\n        (, uint32 maxRentalPeriod) = _rentalPeriods();\n        return maxRentalPeriod;\n    }\n\n    /**\n     * @inheritdoc IRentalPeriodMechanics\n     */\n    function __rentalPeriodRange() external view returns (uint32 minRentalPeriod, uint32 maxRentalPeriod) {\n        (minRentalPeriod, maxRentalPeriod) = _rentalPeriods();\n    }\n\n    /**\n     * @dev Stores warper rental period.\n     */\n    function _setRentalPeriods(uint32 minRentalPeriod, uint32 maxRentalPeriod) internal {\n        uint256 data = (0 & _MAX_PERIOD_MASK) | (uint256(maxRentalPeriod) << _MAX_PERIOD_BITSHIFT);\n        data = (data & _MIN_PERIOD_MASK) | (uint256(minRentalPeriod) << _MIN_PERIOD_BITSHIFT);\n\n        StorageSlot.getUint256Slot(_RENTAL_PERIOD_SLOT).value = data;\n    }\n\n    /**\n     * @dev Returns warper rental periods.\n     */\n    function _rentalPeriods() internal view returns (uint32 minRentalPeriod, uint32 maxRentalPeriod) {\n        uint256 data = StorageSlot.getUint256Slot(_RENTAL_PERIOD_SLOT).value;\n        minRentalPeriod = uint32((data & ~_MIN_PERIOD_MASK) >> _MIN_PERIOD_BITSHIFT);\n        maxRentalPeriod = uint32((data & ~_MAX_PERIOD_MASK) >> _MAX_PERIOD_BITSHIFT);\n    }\n}\n"
    },
    "contracts/warper/ERC721/presets/ERC721PresetConfigurable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\nimport \"../ERC721Warper.sol\";\nimport \"../../IWarperPreset.sol\";\nimport \"../../mechanics/availability-period/ConfigurableAvailabilityPeriodExtension.sol\";\nimport \"../../mechanics/rental-period/ConfigurableRentalPeriodExtension.sol\";\n\ncontract ERC721PresetConfigurable is\n    IWarperPreset,\n    ERC721Warper,\n    ConfigurableAvailabilityPeriodExtension,\n    ConfigurableRentalPeriodExtension\n{\n    /**\n     * @inheritdoc IWarperPreset\n     */\n    function __initialize(bytes memory config) public virtual warperInitializer {\n        // Decode config\n        (address original, address metahub) = abi.decode(config, (address, address));\n        _Warper_init(original, metahub);\n        _ConfigurableAvailabilityPeriodExtension_init();\n        _ConfigurableRentalPeriodExtension_init();\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC721Warper, ConfigurableAvailabilityPeriodExtension, ConfigurableRentalPeriodExtension, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IWarperPreset).interfaceId ||\n            ERC721Warper.supportsInterface(interfaceId) ||\n            ConfigurableAvailabilityPeriodExtension.supportsInterface(interfaceId) ||\n            ConfigurableRentalPeriodExtension.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc ERC721Warper\n     */\n    function _validateOriginal(address original) internal virtual override(ERC721Warper, Warper) {\n        return ERC721Warper._validateOriginal(original);\n    }\n}\n"
    },
    "contracts/warper/mechanics/availability-period/ConfigurableAvailabilityPeriodExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore, func-name-mixedcase, ordering\npragma solidity ^0.8.13;\n\nimport \"../../Warper.sol\";\nimport \"./IConfigurableAvailabilityPeriodExtension.sol\";\n\nabstract contract ConfigurableAvailabilityPeriodExtension is IConfigurableAvailabilityPeriodExtension, Warper {\n    /**\n     * @dev Warper availability period.\n     */\n    bytes32 private constant _AVAILABILITY_PERIOD_SLOT =\n        bytes32(uint256(keccak256(\"iq.warper.params.availabilityPeriod\")) - 1);\n\n    uint256 private constant _MAX_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000;\n    uint256 private constant _MIN_PERIOD_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFF;\n    uint256 private constant _MAX_PERIOD_BITSHIFT = 0;\n    uint256 private constant _MIN_PERIOD_BITSHIFT = 32;\n\n    /**\n     * Extension initializer.\n     */\n    function _ConfigurableAvailabilityPeriodExtension_init() internal onlyInitializingWarper {\n        _setAvailabilityPeriods(0, type(uint32).max);\n    }\n\n    /**\n     * @inheritdoc IConfigurableAvailabilityPeriodExtension\n     */\n    function __setAvailabilityPeriodStart(uint32 availabilityPeriodStart) external virtual onlyWarperAdmin {\n        (, uint32 availabilityPeriodEnd) = _availabilityPeriods();\n        if (availabilityPeriodStart >= availabilityPeriodEnd) revert InvalidAvailabilityPeriodStart();\n\n        _setAvailabilityPeriods(availabilityPeriodStart, availabilityPeriodEnd);\n    }\n\n    /**\n     * @inheritdoc IConfigurableAvailabilityPeriodExtension\n     */\n    function __setAvailabilityPeriodEnd(uint32 availabilityPeriodEnd) external virtual onlyWarperAdmin {\n        (uint32 availabilityPeriodStart, ) = _availabilityPeriods();\n        if (availabilityPeriodStart >= availabilityPeriodEnd) revert InvalidAvailabilityPeriodEnd();\n\n        _setAvailabilityPeriods(availabilityPeriodStart, availabilityPeriodEnd);\n    }\n\n    /**\n     * @inheritdoc IAvailabilityPeriodMechanics\n     */\n    function __availabilityPeriodStart() external view virtual returns (uint32) {\n        (uint32 availabilityPeriodStart, ) = _availabilityPeriods();\n        return availabilityPeriodStart;\n    }\n\n    /**\n     * @inheritdoc IAvailabilityPeriodMechanics\n     */\n    function __availabilityPeriodEnd() external view virtual returns (uint32) {\n        (, uint32 availabilityPeriodEnd) = _availabilityPeriods();\n        return availabilityPeriodEnd;\n    }\n\n    /**\n     * @inheritdoc IAvailabilityPeriodMechanics\n     */\n    function __availabilityPeriodRange()\n        external\n        view\n        virtual\n        returns (uint32 availabilityPeriodStart, uint32 availabilityPeriodEnd)\n    {\n        (availabilityPeriodStart, availabilityPeriodEnd) = _availabilityPeriods();\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(Warper) returns (bool) {\n        return\n            interfaceId == type(IConfigurableAvailabilityPeriodExtension).interfaceId ||\n            interfaceId == type(IAvailabilityPeriodMechanics).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Stores warper availability period.\n     */\n    function _setAvailabilityPeriods(uint32 availabilityPeriodStart, uint32 availabilityPeriodEnd) internal {\n        uint256 data = (0 & _MAX_PERIOD_MASK) | (uint256(availabilityPeriodEnd) << _MAX_PERIOD_BITSHIFT);\n        data = (data & _MIN_PERIOD_MASK) | (uint256(availabilityPeriodStart) << _MIN_PERIOD_BITSHIFT);\n\n        StorageSlot.getUint256Slot(_AVAILABILITY_PERIOD_SLOT).value = data;\n    }\n\n    /**\n     * @dev Returns warper availability period.\n     */\n    function _availabilityPeriods()\n        internal\n        view\n        returns (uint32 availabilityPeriodStart, uint32 availabilityPeriodEnd)\n    {\n        uint256 data = StorageSlot.getUint256Slot(_AVAILABILITY_PERIOD_SLOT).value;\n        availabilityPeriodStart = uint32((data & ~_MIN_PERIOD_MASK) >> _MIN_PERIOD_BITSHIFT);\n        availabilityPeriodEnd = uint32((data & ~_MAX_PERIOD_MASK) >> _MAX_PERIOD_BITSHIFT);\n    }\n}\n"
    },
    "contracts/warper/mechanics/availability-period/IConfigurableAvailabilityPeriodExtension.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity ^0.8.13;\n\nimport \"./IAvailabilityPeriodMechanics.sol\";\n\ninterface IConfigurableAvailabilityPeriodExtension is IAvailabilityPeriodMechanics {\n    /**\n     * @dev Thrown when the availability period start time is not strictly lesser than the end time\n     */\n    error InvalidAvailabilityPeriodStart();\n\n    /**\n     * @dev Thrown when the availability period end time is not greater or equal than the start time\n     */\n    error InvalidAvailabilityPeriodEnd();\n\n    /**\n     * @dev Sets warper availability period starting time.\n     * @param availabilityPeriodStart Unix timestamp after which the warper is rentable.\n     */\n    function __setAvailabilityPeriodStart(uint32 availabilityPeriodStart) external;\n\n    /**\n     * @dev Sets warper availability period ending time.\n     * @param availabilityPeriodEnd Unix timestamp after which the warper is NOT rentable.\n     */\n    function __setAvailabilityPeriodEnd(uint32 availabilityPeriodEnd) external;\n}\n"
    },
    "contracts/mocks/WarperExtendingPreset.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable private-vars-leading-underscore\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../warper/ERC721/presets/ERC721PresetConfigurable.sol\";\n\ncontract WarperExtendingPreset is ERC721PresetConfigurable, UUPSUpgradeable, OwnableUpgradeable {\n    uint8 public initValue;\n\n    function __initialize(bytes calldata config) public virtual override initializer warperInitializer {\n        super.__initialize(config);\n        __Ownable_init();\n\n        (, , uint8 _initValue) = abi.decode(config, (address, address, uint8));\n        initValue = _initValue;\n    }\n\n    function _authorizeUpgrade(address) internal override onlyOwner {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    // NOTE: override because we inherit both - OZ Upgradeable and non upgradeable context\n    function _msgData() internal view virtual override(Context, ContextUpgradeable) returns (bytes calldata) {\n        return ContextUpgradeable._msgData();\n    }\n\n    // NOTE: override because we inherit both - OZ Upgradeable and non upgradeable context\n    function _msgSender() internal view virtual override(Context, ContextUpgradeable) returns (address) {\n        return ContextUpgradeable._msgSender();\n    }\n}\n"
    },
    "contracts/universe/UniverseRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\nimport \"../acl/AccessControlledUpgradeable.sol\";\nimport \"./IUniverseRegistry.sol\";\nimport \"./UniverseToken.sol\";\nimport \"./UniverseRegistryStorage.sol\";\n\n/**\n * @title Universe Registry contract.\n */\ncontract UniverseRegistry is IUniverseRegistry, UUPSUpgradeable, AccessControlledUpgradeable, UniverseRegistryStorage {\n    /**\n     * @dev Modifier to make a function callable only by the universe owner.\n     */\n    modifier onlyUniverseOwner(uint256 universeId) {\n        _checkUniverseOwner(universeId, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if the universe name is valid.\n     */\n    modifier onlyValidUniverseName(string memory universeNameToCheck) {\n        if (bytes(universeNameToCheck).length == 0) revert EmptyUniverseName();\n        _;\n    }\n\n    /**\n     * @dev Modifier to check that the universe has been registered.\n     */\n    modifier onlyRegisteredUniverse(uint256 universeId) {\n        _checkUniverseRegistered(universeId);\n        _;\n    }\n\n    /**\n     * @dev Constructor that gets called for the implementation contract.\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() initializer {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev UniverseRegistry initializer.\n     * @param acl Address of the ACL contract.\n     */\n    function initialize(address acl) external initializer {\n        __UUPSUpgradeable_init();\n\n        _aclContract = IACL(acl);\n\n        _universeToken = new UniverseToken(this);\n    }\n\n    /**\n     * @inheritdoc IUniverseRegistry\n     */\n    function setUniverseTokenBaseURI(string calldata baseURI) external onlySupervisor {\n        _baseURI = baseURI;\n    }\n\n    /**\n     * @inheritdoc IUniverseRegistry\n     */\n    function createUniverse(UniverseParams calldata params)\n        external\n        onlyValidUniverseName(params.name)\n        returns (uint256)\n    {\n        uint256 universeId = _universeToken.mint(_msgSender());\n        _universes[universeId] = Universe({name: params.name, rentalFeePercent: params.rentalFeePercent});\n\n        emit UniverseCreated(universeId, params.name);\n\n        return universeId;\n    }\n\n    /**\n     * @inheritdoc IUniverseRegistry\n     */\n    function setUniverseName(uint256 universeId, string memory name)\n        external\n        onlyRegisteredUniverse(universeId)\n        onlyValidUniverseName(name)\n        onlyUniverseOwner(universeId)\n    {\n        _universes[universeId].name = name;\n\n        emit UniverseNameChanged(universeId, name);\n    }\n\n    /**\n     * @inheritdoc IUniverseRegistry\n     */\n    function setUniverseRentalFeePercent(uint256 universeId, uint16 rentalFeePercent)\n        external\n        onlyRegisteredUniverse(universeId)\n        onlyUniverseOwner(universeId)\n    {\n        _universes[universeId].rentalFeePercent = rentalFeePercent;\n\n        emit UniverseRentalFeeChanged(universeId, rentalFeePercent);\n    }\n\n    /**\n     * @inheritdoc IUniverseRegistry\n     */\n    function universe(uint256 universeId)\n        external\n        view\n        onlyRegisteredUniverse(universeId)\n        returns (string memory name, uint16 rentalFeePercent)\n    {\n        name = _universes[universeId].name;\n        rentalFeePercent = _universes[universeId].rentalFeePercent;\n    }\n\n    /**\n     * @inheritdoc IUniverseRegistry\n     */\n    function universeToken() external view returns (address) {\n        return address(_universeToken);\n    }\n\n    /**\n     * @inheritdoc IUniverseRegistry\n     */\n    function universeTokenBaseURI() external view returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @inheritdoc IUniverseRegistry\n     */\n    function universeRentalFeePercent(uint256 universeId)\n        external\n        view\n        onlyRegisteredUniverse(universeId)\n        returns (uint16 rentalFeePercent)\n    {\n        return _universes[universeId].rentalFeePercent;\n    }\n\n    /**\n     * @inheritdoc IUniverseRegistry\n     */\n    function universeName(uint256 universeId) external view onlyRegisteredUniverse(universeId) returns (string memory) {\n        return _universes[universeId].name;\n    }\n\n    /**\n     * @inheritdoc IUniverseRegistry\n     */\n    function checkUniverseOwner(uint256 universeId, address account) external view onlyRegisteredUniverse(universeId) {\n        _checkUniverseOwner(universeId, account);\n    }\n\n    /**\n     * @inheritdoc IUniverseRegistry\n     */\n    function universeOwner(uint256 universeId) external view onlyRegisteredUniverse(universeId) returns (address) {\n        return _universeToken.ownerOf(universeId);\n    }\n\n    /**\n     * @inheritdoc IUniverseRegistry\n     */\n    function isUniverseOwner(uint256 universeId, address account)\n        external\n        view\n        onlyRegisteredUniverse(universeId)\n        returns (bool)\n    {\n        return _isUniverseOwner(universeId, account);\n    }\n\n    /**\n     * @inheritdoc UUPSUpgradeable\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyAdmin {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @inheritdoc AccessControlledUpgradeable\n     */\n    function _acl() internal view override returns (IACL) {\n        return _aclContract;\n    }\n\n    /**\n     * @dev Revert if the passed account is not the owner of the universe.\n     */\n    function _checkUniverseOwner(uint256 universeId, address account) internal view {\n        if (!_isUniverseOwner(universeId, account)) revert AccountIsNotUniverseOwner(account);\n    }\n\n    /**\n     * @dev Revert if the universe has been registered properly.\n     */\n    function _checkUniverseRegistered(uint256 universeId) internal view {\n        if (!_isValidUniverseName(universeId)) revert QueryForNonexistentUniverse(universeId);\n    }\n\n    /**\n     * @dev Return `true` if the universe name is valid.\n     */\n    function _isValidUniverseName(uint256 universeId) internal view returns (bool) {\n        return bytes(_universes[universeId].name).length != 0;\n    }\n\n    /**\n     * @dev Return `true` if the account is the owner of the universe.\n     */\n    function _isUniverseOwner(uint256 universeId, address account) internal view returns (bool) {\n        return _universeToken.ownerOf(universeId) == account;\n    }\n}\n"
    },
    "contracts/metahub/Metahub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"../acl/AccessControlledUpgradeable.sol\";\nimport \"./IMetahub.sol\";\nimport \"./MetahubStorage.sol\";\n\ncontract Metahub is IMetahub, Initializable, UUPSUpgradeable, AccessControlledUpgradeable, MetahubStorage {\n    using Address for address;\n    using Accounts for Accounts.Account;\n    using Accounts for Accounts.Registry;\n    using Assets for Assets.Asset;\n    using Assets for Assets.Registry;\n    using Listings for Listings.Listing;\n    using Listings for Listings.Registry;\n    using Rentings for Rentings.Registry;\n    using Warpers for Warpers.Warper;\n    using Warpers for Warpers.Registry;\n\n    /**\n     * @dev Metahub initialization params.\n     * @param warperManager Warper manager contract address.\n     * @param listingStrategyRegistry Listing strategy registry contract address.\n     * @param universeRegistry Universe registry contract address.\n     * @param assetClassRegistry Asset class registry contract address.\n     * @param acl Protocol access control contract address.\n     * @param baseToken Protocol base token (ERC20) address.\n     * @param rentalFeePercent Default protocol rental fee percentage.\n     */\n    struct MetahubInitParams {\n        IWarperManager warperManager;\n        IListingStrategyRegistry listingStrategyRegistry;\n        IUniverseRegistry universeRegistry;\n        IAssetClassRegistry assetClassRegistry;\n        IACL acl;\n        IERC20Upgradeable baseToken;\n        uint16 rentalFeePercent;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by the universe owner.\n     */\n    modifier onlyUniverseOwner(uint256 universeId) {\n        _universeRegistry.checkUniverseOwner(universeId, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by the WarperManager contract.\n     */\n    modifier onlyWarperManager() {\n        if (_msgSender() != address(_warperManager)) revert CallerIsNotWarperManager();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by the asset lister (original owner).\n     */\n    modifier onlyLister(uint256 listingId) {\n        if (_msgSender() != _listingRegistry.listings[listingId].lister) revert CallerIsNotAssetLister();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make sure the function is called for the active listing.\n     */\n    modifier listed(uint256 listingId) {\n        _listingRegistry.checkListed(listingId);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make sure the function is called for a listing that has been registered.\n     */\n    modifier listingExists(uint256 listingId) {\n        _listingRegistry.checkRegisteredListing(listingId);\n        _;\n    }\n\n    /**\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() initializer {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Metahub initializer.\n     * @param params Initialization params.\n     */\n    function initialize(MetahubInitParams calldata params) external initializer {\n        __UUPSUpgradeable_init();\n\n        _aclContract = params.acl;\n        _protocolConfig = Protocol.Config({baseToken: params.baseToken, rentalFeePercent: params.rentalFeePercent});\n\n        _warperManager = params.warperManager;\n        _universeRegistry = params.universeRegistry;\n        _assetRegistry.classRegistry = params.assetClassRegistry;\n        _listingRegistry.strategyRegistry = params.listingStrategyRegistry;\n    }\n\n    /**\n     * @inheritdoc IProtocolConfigManager\n     */\n    function setProtocolRentalFeePercent(uint16 rentalFeePercent) external onlyAdmin {\n        _protocolConfig.rentalFeePercent = rentalFeePercent;\n        emit ProtocolRentalFeeChanged(rentalFeePercent);\n    }\n\n    /**\n     * @inheritdoc IListingManager\n     */\n    function listAsset(\n        Assets.Asset calldata asset,\n        Listings.Params calldata params,\n        uint32 maxLockPeriod,\n        bool immediatePayout\n    ) external returns (uint256 listingId, uint256 listingGroupId) {\n        // Check that asset is supported.\n        _warperManager.checkSupportedAsset(asset.token());\n\n        // Check that listing strategy is supported.\n        _listingRegistry.checkSupportedListingStrategy(params.strategy);\n\n        // Register listing.\n        Listings.Listing memory listing = Listings.Listing({\n            asset: asset,\n            params: params,\n            lister: _msgSender(),\n            maxLockPeriod: maxLockPeriod,\n            lockedTill: 0,\n            immediatePayout: immediatePayout,\n            delisted: false,\n            paused: false,\n            groupId: 0\n        });\n\n        (listingId, listingGroupId) = _listingRegistry.register(listing);\n\n        // Transfer asset from lister account to the vault.\n        _assetRegistry.transferAssetToVault(asset, _msgSender());\n\n        emit AssetListed(\n            listingId,\n            listingGroupId,\n            listing.lister,\n            listing.asset,\n            listing.params,\n            listing.maxLockPeriod\n        );\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function registerAsset(bytes4 assetClass, address original) external onlyWarperManager {\n        // Register the original asset if it is seen for the first time.\n        if (!_assetRegistry.isRegisteredAsset(original)) {\n            _assetRegistry.registerAsset(assetClass, original);\n        }\n    }\n\n    /**\n     * @inheritdoc IListingManager\n     */\n    function delistAsset(uint256 listingId) external listed(listingId) onlyLister(listingId) {\n        Listings.Listing storage listing = _listingRegistry.listings[listingId];\n        listing.delisted = true;\n        emit AssetDelisted(listingId, listing.lister, listing.lockedTill);\n    }\n\n    /**\n     * @inheritdoc IListingManager\n     */\n    function withdrawAsset(uint256 listingId) external onlyLister(listingId) {\n        Listings.Listing memory listing = _listingRegistry.listings[listingId];\n        // Check whether the asset can be returned to the owner.\n        if (uint32(block.timestamp) < listing.lockedTill) revert AssetIsLocked();\n\n        // Delete listing record.\n        _listingRegistry.remove(listingId);\n\n        // Transfer asset from the vault to the original owner.\n        _assetRegistry.returnAssetFromVault(listing.asset);\n\n        emit AssetWithdrawn(listingId, listing.lister, listing.asset);\n    }\n\n    /**\n     * @inheritdoc IListingManager\n     */\n    function pauseListing(uint256 listingId) external listed(listingId) onlyLister(listingId) {\n        _listingRegistry.listings[listingId].pause();\n        emit ListingPaused(listingId);\n    }\n\n    /**\n     * @inheritdoc IListingManager\n     */\n    function unpauseListing(uint256 listingId) external listed(listingId) onlyLister(listingId) {\n        _listingRegistry.listings[listingId].unpause();\n        emit ListingUnpaused(listingId);\n    }\n\n    /**\n     * @inheritdoc IPaymentManager\n     */\n    function withdrawProtocolFunds(\n        address token,\n        uint256 amount,\n        address to\n    ) external onlyAdmin {\n        _accountRegistry.protocol.withdraw(token, amount, to);\n    }\n\n    /**\n     * @inheritdoc IPaymentManager\n     */\n    function withdrawUniverseFunds(\n        uint256 universeId,\n        address token,\n        uint256 amount,\n        address to\n    ) external onlyUniverseOwner(universeId) {\n        _accountRegistry.universes[universeId].withdraw(token, amount, to);\n    }\n\n    /**\n     * @inheritdoc IPaymentManager\n     */\n    function withdrawFunds(\n        address token,\n        uint256 amount,\n        address to\n    ) external {\n        _accountRegistry.users[_msgSender()].withdraw(token, amount, to);\n    }\n\n    /**\n     * @inheritdoc IRentingManager\n     */\n    function rent(Rentings.Params calldata rentingParams, uint256 maxPaymentAmount) external returns (uint256) {\n        // Validate renting parameters.\n        Rentings.validateRentingParams(rentingParams, _protocolConfig, _listingRegistry, _warperManager);\n\n        // Warp the asset and deliver to to the renter.\n        (bytes32 warpedCollectionId, Assets.Asset memory warpedAsset) = _warpListedAsset(\n            rentingParams.listingId,\n            rentingParams.warper,\n            rentingParams.renter\n        );\n\n        // Register new rental agreement.\n        uint32 blockTimestamp = uint32(block.timestamp);\n        Listings.Params storage listingParams = _listingRegistry.listings[rentingParams.listingId].params;\n        Rentings.Agreement memory rentalAgreement = Rentings.Agreement({\n            warpedAsset: warpedAsset,\n            collectionId: warpedCollectionId,\n            listingId: rentingParams.listingId,\n            renter: rentingParams.renter,\n            startTime: blockTimestamp,\n            endTime: blockTimestamp + rentingParams.rentalPeriod,\n            listingParams: listingParams\n        });\n\n        // Register new rental agreement.\n        uint256 rentalId = _rentingRegistry.register(rentalAgreement);\n\n        // Update listing lock time.\n        _listingRegistry.listings[rentingParams.listingId].addLock(rentalAgreement.endTime);\n\n        // Clean up x2 expired rental agreements.\n        _rentingRegistry.deleteExpiredUserRentalAgreements(rentingParams.renter, warpedCollectionId, 2);\n\n        // Handle rental payments.\n        Accounts.RentalEarnings memory rentalEarnings = _handleRentalPayment(\n            rentingParams,\n            _msgSender(),\n            maxPaymentAmount\n        );\n\n        // Execute rental hook.\n        _executeWarperRentalHook(rentingParams.warper, rentalId, rentalAgreement, rentalEarnings);\n\n        emit AssetRented(\n            rentalId,\n            rentalAgreement.renter,\n            rentalAgreement.listingId,\n            rentalAgreement.warpedAsset,\n            rentalAgreement.startTime,\n            rentalAgreement.endTime\n        );\n\n        return rentalId;\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function assetClassController(bytes4 assetClass) external view returns (address) {\n        return _assetRegistry.assetClassController(assetClass);\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function supportedAssetCount() external view returns (uint256) {\n        return _assetRegistry.assetCount();\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function supportedAssets(uint256 offset, uint256 limit)\n        external\n        view\n        returns (address[] memory, Assets.AssetConfig[] memory)\n    {\n        return _assetRegistry.supportedAssets(offset, limit);\n    }\n\n    /**\n     * @inheritdoc IAssetManager\n     */\n    function isWarperAdmin(address warper, address account) external view returns (bool) {\n        return _warperManager.isWarperAdmin(warper, account);\n    }\n\n    /**\n     * @inheritdoc IRentingManager\n     */\n    function estimateRent(Rentings.Params calldata rentingParams) external view returns (Rentings.RentalFees memory) {\n        Rentings.validateRentingParams(rentingParams, _protocolConfig, _listingRegistry, _warperManager);\n        return\n            Rentings.calculateRentalFees(\n                rentingParams,\n                _protocolConfig,\n                _listingRegistry,\n                _warperManager,\n                _universeRegistry\n            );\n    }\n\n    /**\n     * @inheritdoc IProtocolConfigManager\n     */\n    function protocolRentalFeePercent() external view returns (uint16) {\n        return _protocolConfig.rentalFeePercent;\n    }\n\n    /**\n     * @inheritdoc IProtocolConfigManager\n     */\n    function baseToken() external view returns (address) {\n        return address(_protocolConfig.baseToken);\n    }\n\n    /**\n     * @inheritdoc IProtocolConfigManager\n     */\n    function warperController(address warper) external view returns (address) {\n        return _warperManager.warperController(warper);\n    }\n\n    /**\n     * @inheritdoc IRentingManager\n     */\n    function rentalAgreementInfo(uint256 rentalId) external view returns (Rentings.Agreement memory) {\n        return _rentingRegistry.agreements[rentalId];\n    }\n\n    /**\n     * @inheritdoc IRentingManager\n     */\n    function userRentalCount(address renter) external view returns (uint256) {\n        return _rentingRegistry.userRentalCount(renter);\n    }\n\n    /**\n     * @inheritdoc IRentingManager\n     */\n    function userRentalAgreements(\n        address renter,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Rentings.Agreement[] memory) {\n        return _rentingRegistry.userRentalAgreements(renter, offset, limit);\n    }\n\n    /**\n     * @inheritdoc IRentingManager\n     */\n    function collectionRentedValue(bytes32 warpedCollectionId, address renter) external view returns (uint256) {\n        return _rentingRegistry.collectionRentedValue(renter, warpedCollectionId);\n    }\n\n    /**\n     * @inheritdoc IRentingManager\n     */\n    function assetRentalStatus(Assets.AssetId calldata warpedAssetId) external view returns (Rentings.RentalStatus) {\n        return _rentingRegistry.assetRentalStatus(warpedAssetId);\n    }\n\n    /**\n     * @inheritdoc IListingManager\n     */\n    function listingInfo(uint256 listingId) external view listingExists(listingId) returns (Listings.Listing memory) {\n        return _listingRegistry.listings[listingId];\n    }\n\n    /**\n     * @inheritdoc IListingManager\n     */\n    function listingCount() external view returns (uint256) {\n        return _listingRegistry.listingCount();\n    }\n\n    /**\n     * @inheritdoc IListingManager\n     */\n    function listings(uint256 offset, uint256 limit)\n        external\n        view\n        returns (uint256[] memory, Listings.Listing[] memory)\n    {\n        return _listingRegistry.allListings(offset, limit);\n    }\n\n    /**\n     * @inheritdoc IListingManager\n     */\n    function userListingCount(address lister) external view returns (uint256) {\n        return _listingRegistry.userListingCount(lister);\n    }\n\n    /**\n     * @inheritdoc IListingManager\n     */\n    function userListings(\n        address lister,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Listings.Listing[] memory) {\n        return _listingRegistry.userListings(lister, offset, limit);\n    }\n\n    /**\n     * @inheritdoc IListingManager\n     */\n    function assetListingCount(address original) external view returns (uint256) {\n        return _listingRegistry.assetListingCount(original);\n    }\n\n    /**\n     * @inheritdoc IListingManager\n     */\n    function assetListings(\n        address original,\n        uint256 offset,\n        uint256 limit\n    ) external view returns (uint256[] memory, Listings.Listing[] memory) {\n        return _listingRegistry.assetListings(original, offset, limit);\n    }\n\n    /**\n     * @inheritdoc IListingManager\n     */\n    function listingController(bytes4 strategyId) external view returns (address) {\n        return _listingRegistry.strategyRegistry.listingController(strategyId);\n    }\n\n    /**\n     * @inheritdoc IPaymentManager\n     */\n    function protocolBalance(address token) external view returns (uint256) {\n        return _accountRegistry.protocol.balance(token);\n    }\n\n    /**\n     * @inheritdoc IPaymentManager\n     */\n    function protocolBalances() external view returns (Accounts.Balance[] memory) {\n        return _accountRegistry.protocol.balances();\n    }\n\n    /**\n     * @inheritdoc IPaymentManager\n     */\n    function universeBalance(uint256 universeId, address token) external view returns (uint256) {\n        return _accountRegistry.universes[universeId].balance(token);\n    }\n\n    /**\n     * @inheritdoc IPaymentManager\n     */\n    function universeBalances(uint256 universeId) external view returns (Accounts.Balance[] memory) {\n        return _accountRegistry.universes[universeId].balances();\n    }\n\n    /**\n     * @inheritdoc IPaymentManager\n     */\n    function balance(address account, address token) external view returns (uint256) {\n        return _accountRegistry.users[account].balance(token);\n    }\n\n    /**\n     * @inheritdoc IPaymentManager\n     */\n    function balances(address account) external view returns (Accounts.Balance[] memory) {\n        return _accountRegistry.users[account].balances();\n    }\n\n    /**\n     * @inheritdoc UUPSUpgradeable\n     * @dev Checks whether the caller is authorized to upgrade the Metahub implementation.\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyAdmin {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Finds the listed asset and warps it, using corresponding warper controller.\n     * @param listingId Listing ID.\n     * @param warper Warper address.\n     * @param renter Renter address.\n     * @return collectionId Warped collection ID.\n     * @return warpedAsset Warped asset structure.\n     */\n    function _warpListedAsset(\n        uint256 listingId,\n        address warper,\n        address renter\n    ) internal returns (bytes32 collectionId, Assets.Asset memory warpedAsset) {\n        Assets.Asset memory asset = _listingRegistry.listings[listingId].asset;\n        address controller = _warperManager.warperController(warper);\n        (collectionId, warpedAsset) = abi.decode(\n            controller.functionDelegateCall(\n                abi.encodeWithSelector(IWarperController.warp.selector, asset, warper, renter)\n            ),\n            (bytes32, Assets.Asset)\n        );\n    }\n\n    /**\n     * @dev Handles all rental payments.\n     */\n    function _handleRentalPayment(\n        Rentings.Params calldata rentingParams,\n        address payer,\n        uint256 maxPaymentAmount\n    ) internal returns (Accounts.RentalEarnings memory rentalEarnings) {\n        // Get precise estimation.\n        Rentings.RentalFees memory fees = Rentings.calculateRentalFees(\n            rentingParams,\n            _protocolConfig,\n            _listingRegistry,\n            _warperManager,\n            _universeRegistry\n        );\n\n        rentalEarnings = _accountRegistry.handleRentalPayment(\n            rentingParams,\n            fees,\n            payer,\n            maxPaymentAmount,\n            _warperManager,\n            _listingRegistry\n        );\n\n        // Emit events\n        for (uint256 i = 0; i < rentalEarnings.userEarnings.length; i++) {\n            Accounts.UserEarning memory userEarning = rentalEarnings.userEarnings[i];\n            emit UserEarned(userEarning.account, userEarning.earningType, userEarning.token, userEarning.value);\n        }\n\n        emit UniverseEarned(\n            rentalEarnings.universeId,\n            rentalEarnings.universeEarningToken,\n            rentalEarnings.universeEarningValue\n        );\n        emit ProtocolEarned(rentalEarnings.protocolEarningToken, rentalEarnings.protocolEarningValue);\n    }\n\n    /**\n     * @dev Executes warper rental hook using the corresponding controller.\n     * @param warper Warper address.\n     * @param rentalId Rental Agreement ID.\n     * @param rentalAgreement Newly registered rental agreement details.\n     * @param rentalEarnings The rental earnings breakdown.\n     */\n    function _executeWarperRentalHook(\n        address warper,\n        uint256 rentalId,\n        Rentings.Agreement memory rentalAgreement,\n        Accounts.RentalEarnings memory rentalEarnings\n    ) internal {\n        address controller = _warperManager.warperController(warper);\n\n        controller.functionDelegateCall(\n            abi.encodeWithSelector(\n                IWarperController.executeRentingHooks.selector,\n                rentalId,\n                rentalAgreement,\n                rentalEarnings\n            )\n        );\n    }\n\n    /**\n     * @inheritdoc AccessControlledUpgradeable\n     */\n    function _acl() internal view override returns (IACL) {\n        return _aclContract;\n    }\n}\n"
    },
    "contracts/mocks/MetahubV2Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../metahub/Metahub.sol\";\n\ncontract MetahubV2Mock is Metahub {\n    function version() external pure returns (string memory) {\n        return \"V2\";\n    }\n}\n"
    },
    "contracts/asset/AssetClassRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\n\nimport \"../acl/AccessControlledUpgradeable.sol\";\nimport \"./AssetClassRegistryStorage.sol\";\n\ncontract AssetClassRegistry is\n    IAssetClassRegistry,\n    UUPSUpgradeable,\n    AccessControlledUpgradeable,\n    AssetClassRegistryStorage\n{\n    using ERC165CheckerUpgradeable for address;\n\n    /**\n     * @dev Modifier to make a function callable only for the registered asset class.\n     */\n    modifier onlyRegisteredAssetClass(bytes4 assetClass) {\n        checkRegisteredAssetClass(assetClass);\n        _;\n    }\n\n    /**\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() initializer {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev AssetClassRegistry initializer.\n     * @param acl ACL contract address.\n     */\n    function initialize(address acl) external initializer {\n        __UUPSUpgradeable_init();\n        _aclContract = IACL(acl);\n    }\n\n    /**\n     * @inheritdoc IAssetClassRegistry\n     */\n    function registerAssetClass(bytes4 assetClass, ClassConfig calldata config) external onlyAdmin {\n        _checkValidAssetController(assetClass, config.controller);\n        _checkValidAssetVault(assetClass, config.vault);\n\n        // Check if not already registered.\n        if (isRegisteredAssetClass(assetClass)) revert AssetClassIsAlreadyRegistered(assetClass);\n\n        _classes[assetClass] = config;\n        emit AssetClassRegistered(assetClass, config.controller, config.vault);\n    }\n\n    /**\n     * @inheritdoc IAssetClassRegistry\n     */\n    function setAssetClassVault(bytes4 assetClass, address vault)\n        external\n        onlyAdmin\n        onlyRegisteredAssetClass(assetClass)\n    {\n        _checkValidAssetVault(assetClass, vault);\n        _classes[assetClass].vault = vault;\n        emit AssetClassVaultChanged(assetClass, vault);\n    }\n\n    /**\n     * @inheritdoc IAssetClassRegistry\n     */\n    function setAssetClassController(bytes4 assetClass, address controller)\n        external\n        onlyAdmin\n        onlyRegisteredAssetClass(assetClass)\n    {\n        _checkValidAssetController(assetClass, controller);\n        _classes[assetClass].controller = controller;\n        emit AssetClassControllerChanged(assetClass, controller);\n    }\n\n    /**\n     * @inheritdoc IAssetClassRegistry\n     */\n    function assetClassConfig(bytes4 assetClass)\n        external\n        view\n        onlyRegisteredAssetClass(assetClass)\n        returns (ClassConfig memory)\n    {\n        return _classes[assetClass];\n    }\n\n    /**\n     * @inheritdoc IAssetClassRegistry\n     */\n    function isRegisteredAssetClass(bytes4 assetClass) public view returns (bool) {\n        // The registered asset must have controller.\n        return address(_classes[assetClass].controller) != address(0);\n    }\n\n    /**\n     * @inheritdoc IAssetClassRegistry\n     */\n    function checkRegisteredAssetClass(bytes4 assetClass) public view {\n        if (!isRegisteredAssetClass(assetClass)) revert UnregisteredAssetClass(assetClass);\n    }\n\n    /**\n     * @inheritdoc UUPSUpgradeable\n     */\n    function _authorizeUpgrade(address newImplementation) internal override onlyAdmin {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Reverts if provided address is not a valid asset controller address.\n     * @param assetClass Asset class ID.\n     * @param controller Asset controller address.\n     */\n    function _checkValidAssetController(bytes4 assetClass, address controller) internal view {\n        if (!controller.supportsInterface(type(IAssetController).interfaceId)) revert InvalidAssetControllerInterface();\n        bytes4 contractAssetClass = IAssetController(controller).assetClass();\n        if (contractAssetClass != assetClass) revert AssetClassMismatch(contractAssetClass, assetClass);\n    }\n\n    /**\n     * @dev Reverts if provided address is not a valid asset vault address.\n     * @param assetClass Asset class ID.\n     * @param vault Asset vault address.\n     */\n    function _checkValidAssetVault(bytes4 assetClass, address vault) internal view {\n        if (!vault.supportsInterface(type(IAssetVault).interfaceId)) revert InvalidAssetVaultInterface();\n        bytes4 contractAssetClass = IAssetVault(vault).assetClass();\n        if (contractAssetClass != assetClass) revert AssetClassMismatch(contractAssetClass, assetClass);\n    }\n\n    /**\n     * @inheritdoc AccessControlledUpgradeable\n     */\n    function _acl() internal view override returns (IACL) {\n        return _aclContract;\n    }\n}\n"
    },
    "contracts/asset/AssetClassRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../acl/IACL.sol\";\nimport \"./IAssetClassRegistry.sol\";\n\nabstract contract AssetClassRegistryStorage {\n    /**\n     * @dev ACL contract.\n     */\n    IACL internal _aclContract;\n\n    /**\n     * @dev Mapping from asset class ID to the asset class configuration.\n     */\n    mapping(bytes4 => IAssetClassRegistry.ClassConfig) internal _classes;\n}\n"
    },
    "contracts/mocks/ERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e/contracts/mocks/ERC721ReceiverMock.sol\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721Receiver.sol\";\n\ncontract ERC721ReceiverMock is IERC721Receiver {\n    enum Error {\n        NONE,\n        REVERT_WITH_MESSAGE,\n        REVERT_WITHOUT_MESSAGE,\n        PANIC\n    }\n\n    bytes4 private immutable _retval;\n    Error private immutable _error;\n\n    event Received(address operator, address from, uint256 tokenId, bytes data);\n\n    constructor(bytes4 retval, Error error) {\n        _retval = retval;\n        _error = error;\n    }\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes memory data\n    ) public override returns (bytes4) {\n        if (_error == Error.REVERT_WITH_MESSAGE) {\n            revert(\"ERC721ReceiverMock: reverting\");\n        } else if (_error == Error.REVERT_WITHOUT_MESSAGE) {\n            revert();\n        } else if (_error == Error.PANIC) {\n            uint256 a = uint256(0) / uint256(0);\n            a;\n        }\n        emit Received(operator, from, tokenId, data); // NOTE: The original version has `gasLeft()` call here as well\n        return _retval;\n    }\n}\n"
    },
    "contracts/mocks/ERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract ERC721Mock is ERC721 {\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function mint(address to, uint256 tokenId) public {\n        _mint(to, tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/mocks/ERC721WarperControllerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/interfaces/IERC721.sol\";\n\nimport \"../warper/ERC721/ERC721WarperController.sol\";\n\ncontract ERC721WarperControllerMock is ERC721WarperController {\n    uint256 internal _universePremium;\n    uint256 internal _listerPremium;\n\n    function setPremiums(uint256 universePremium, uint256 listerPremium) external {\n        _universePremium = universePremium;\n        _listerPremium = listerPremium;\n    }\n\n    function calculatePremiums(\n        Assets.Asset calldata,\n        Rentings.Params calldata,\n        uint256,\n        uint256\n    ) external view override returns (uint256, uint256) {\n        return (_universePremium, _listerPremium);\n    }\n}\n"
    },
    "contracts/acl/ACL.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\n\nimport \"./IACL.sol\";\nimport \"./AccessControlledUpgradeable.sol\";\nimport \"./Roles.sol\";\n\n/**\n * @title Access Control List contract\n */\ncontract ACL is IACL, AccessControlEnumerableUpgradeable, AccessControlledUpgradeable, UUPSUpgradeable {\n    /**\n     * @dev Constructor that gets called for the implementation contract.\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor() initializer {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev ACL initializer.\n     */\n    function initialize() external initializer {\n        __AccessControlEnumerable_init();\n        __UUPSUpgradeable_init();\n\n        if (Roles.ADMIN != DEFAULT_ADMIN_ROLE) revert RolesContractIncorrectlyConfigured();\n\n        _grantRole(Roles.ADMIN, msg.sender);\n        _grantRole(Roles.SUPERVISOR, msg.sender);\n    }\n\n    /**\n     * @inheritdoc IACL\n     */\n    function checkRole(bytes32 role, address account) external view {\n        _checkRole(role, account);\n    }\n\n    /**\n     * @inheritdoc IACL\n     */\n    function adminRole() external pure override returns (bytes32) {\n        return Roles.ADMIN;\n    }\n\n    /**\n     * @inheritdoc IACL\n     */\n    function supervisorRole() external pure override returns (bytes32) {\n        return Roles.SUPERVISOR;\n    }\n\n    /**\n     * @inheritdoc UUPSUpgradeable\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyAdmin {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @inheritdoc AccessControlEnumerableUpgradeable\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        if (Roles.ADMIN == role && getRoleMemberCount(role) == 1) revert CannotRemoveLastAdmin();\n\n        super._revokeRole(role, account);\n    }\n\n    /**\n     * @inheritdoc AccessControlledUpgradeable\n     */\n    function _acl() internal view virtual override returns (IACL) {\n        return IACL(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    uint8 internal _decimals;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals_,\n        uint256 totalSupply\n    ) ERC20(name, symbol) {\n        _decimals = decimals_;\n        _mint(msg.sender, totalSupply);\n    }\n\n    function mint(address to, uint256 amount) public {\n        _mint(to, amount);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/mocks/ERC721InternalTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n/**\n * @notice An NFT contract used for internal testing purposes.\n */\ncontract ERC721InternalTest is ERC721 {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdTracker;\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    constructor(string memory name, string memory symbol) ERC721(name, symbol) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function mint(string memory newTokenURI) public {\n        _mint(msg.sender, _tokenIdTracker.current());\n        _tokenURIs[_tokenIdTracker.current()] = newTokenURI;\n        _tokenIdTracker.increment();\n    }\n\n    function setTokenURI(uint256 tokenId, string memory newTokenURI) public {\n        _tokenURIs[tokenId] = newTokenURI;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        return _tokenURIs[tokenId];\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/mocks/ERC721AssetVaultMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n\ncontract ERC721AssetVaultMock is ERC721Holder {\n    // solhint-disable-previous-line no-empty-blocks\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "contracts/imports/Imports.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n// Importing `ERC1967Proxy` so we can access it from our deploy scripts\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}