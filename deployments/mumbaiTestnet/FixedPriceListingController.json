{
  "address": "0x7F2Ff7A3d9F7C39f3c78F7B0B1facfDEB82B556E",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "provided",
          "type": "bytes4"
        },
        {
          "internalType": "bytes4",
          "name": "required",
          "type": "bytes4"
        }
      ],
      "name": "ListingStrategyMismatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes4",
              "name": "strategy",
              "type": "bytes4"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Listings.Params",
          "name": "strategyParams",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "listingId",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "warper",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "renter",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "rentalPeriod",
              "type": "uint32"
            },
            {
              "internalType": "address",
              "name": "paymentToken",
              "type": "address"
            }
          ],
          "internalType": "struct Rentings.Params",
          "name": "rentingParams",
          "type": "tuple"
        }
      ],
      "name": "calculateRentalFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "strategyId",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x10d34fc47bf9ad9921adf1bf097ac8ebb51b59c74c3a8ef38d8be48dc286b033",
  "receipt": {
    "to": null,
    "from": "0xE6747a55c7d6ce24064Ea1CA3ddB76dcCdFbBaBc",
    "contractAddress": "0x7F2Ff7A3d9F7C39f3c78F7B0B1facfDEB82B556E",
    "transactionIndex": 22,
    "gasUsed": "270597",
    "logsBloom": "0x00000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000040800002000000000000000100000000004000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000080000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100040000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x58bc3015e04e4fd5d1ecb19a20a9735ed00a3419f89af91efa98f8b97773f3c1",
    "transactionHash": "0x10d34fc47bf9ad9921adf1bf097ac8ebb51b59c74c3a8ef38d8be48dc286b033",
    "logs": [
      {
        "transactionIndex": 22,
        "blockNumber": 26282897,
        "transactionHash": "0x10d34fc47bf9ad9921adf1bf097ac8ebb51b59c74c3a8ef38d8be48dc286b033",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000e6747a55c7d6ce24064ea1ca3ddb76dccdfbbabc",
          "0x000000000000000000000000be188d6641e8b680743a4815dfa0f6208038960f"
        ],
        "data": "0x000000000000000000000000000000000000000000000000000965f000e59c000000000000000000000000000000000000000000000000000489da5cdf86e7bf000000000000000000000000000000000000000000001564c8bec05c5ba4521e0000000000000000000000000000000000000000000000000480746cdea14bbf000000000000000000000000000000000000000000001564c8c8264c5c89ee1e",
        "logIndex": 44,
        "blockHash": "0x58bc3015e04e4fd5d1ecb19a20a9735ed00a3419f89af91efa98f8b97773f3c1"
      }
    ],
    "blockNumber": 26282897,
    "cumulativeGasUsed": "3357695",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "12166c16def6b1b843a72b9a268c7133",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"provided\",\"type\":\"bytes4\"},{\"internalType\":\"bytes4\",\"name\":\"required\",\"type\":\"bytes4\"}],\"name\":\"ListingStrategyMismatch\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"strategy\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Listings.Params\",\"name\":\"strategyParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"listingId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"warper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"renter\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"rentalPeriod\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"internalType\":\"struct Rentings.Params\",\"name\":\"rentingParams\",\"type\":\"tuple\"}],\"name\":\"calculateRentalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategyId\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"ListingStrategyMismatch(bytes4,bytes4)\":[{\"details\":\"Thrown when the listing strategy ID does not match the required one.\",\"params\":{\"provided\":\"Provided listing strategy ID.\",\"required\":\"Required listing strategy ID.\"}}]},\"kind\":\"dev\",\"methods\":{\"calculateRentalFee((bytes4,bytes),(uint256,address,address,uint32,address))\":{\"details\":\"Calculates rental fee based on renting params and implemented listing strategy.\",\"params\":{\"listingParams\":\"Listing strategy params.\",\"rentingParams\":\"Renting params.\"},\"returns\":{\"_0\":\"Rental fee.\"}},\"strategyId()\":{\"details\":\"Returns implemented strategy ID.\",\"returns\":{\"_0\":\"Listing strategy ID.\"}},\"supportsInterface(bytes4)\":{\"details\":\"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/listing/strategies/FixedPriceListingController.sol\":\"FixedPriceListingController\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x6777f3fccb5dab95a9088ef62c41bee0198fd92e50d7c94f0e3733788af4079e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary CountersUpgradeable {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\",\"keccak256\":\"0x798741e231b22b81e2dd2eddaaf8832dee4baf5cd8e2dbaa5c1dd12a1c053c4d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x0004699ba89fa356eb0d58d815b42dcf52eccd2765e95256631b838bce2556bc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xd04b0f06e0666f29cf7cccc82894de541e19bb30a765b107b1e40bb7fe5f7d7a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/asset/Assets.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"./IAssetController.sol\\\";\\nimport \\\"./IAssetVault.sol\\\";\\nimport \\\"./IAssetClassRegistry.sol\\\";\\n\\nlibrary Assets {\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n    using Address for address;\\n    using Assets for Registry;\\n    using Assets for Asset;\\n\\n    /*\\n     * @dev This is the list of asset class identifiers to be used across the system.\\n     */\\n    bytes4 public constant ERC721 = bytes4(keccak256(\\\"ERC721\\\"));\\n    bytes4 public constant ERC1155 = bytes4(keccak256(\\\"ERC1155\\\"));\\n\\n    bytes32 public constant ASSET_ID_TYPEHASH = keccak256(\\\"AssetId(bytes4 class,bytes data)\\\");\\n\\n    bytes32 public constant ASSET_TYPEHASH =\\n        keccak256(\\\"Asset(AssetId id,uint256 value)AssetId(bytes4 class,bytes data)\\\");\\n\\n    /**\\n     * @dev Thrown when the asset class is not registered or deprecated.\\n     * @param assetClass Asset class ID.\\n     */\\n    error UnsupportedAssetClass(bytes4 assetClass);\\n\\n    /**\\n     * @dev Thrown upon attempting to register an asset twice.\\n     * @param asset Duplicate asset address.\\n     */\\n    error AssetIsAlreadyRegistered(address asset);\\n\\n    /**\\n     * @dev Communicates asset identification information.\\n     * The structure designed to be token-standard agnostic,\\n     * so the layout of `data` might vary for different token standards.\\n     * For example, in case of ERC721 token, the `data` will contain contract address and tokenId.\\n     * @param class Asset class ID\\n     * @param data Asset identification data.\\n     */\\n    struct AssetId {\\n        bytes4 class;\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Calculates Asset ID hash\\n     */\\n    function hash(AssetId memory assetId) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(ASSET_ID_TYPEHASH, assetId.class, keccak256(assetId.data)));\\n    }\\n\\n    /**\\n     * @dev Extracts token contract address from the Asset ID structure.\\n     * The address is the common attribute for all assets regardless of their asset class.\\n     */\\n    function token(AssetId memory self) internal pure returns (address) {\\n        return abi.decode(self.data, (address));\\n    }\\n\\n    /**\\n     * @dev Uniformed structure to describe arbitrary asset (token) and its value.\\n     * @param id Asset ID structure.\\n     * @param value Asset value (amount).\\n     */\\n    struct Asset {\\n        AssetId id;\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Calculates Asset hash\\n     */\\n    function hash(Asset memory asset) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(ASSET_TYPEHASH, hash(asset.id), asset.value));\\n    }\\n\\n    /**\\n     * @dev Extracts token contract address from the Asset structure.\\n     * The address is the common attribute for all assets regardless of their asset class.\\n     */\\n    function token(Asset memory self) internal pure returns (address) {\\n        return abi.decode(self.id.data, (address));\\n    }\\n\\n    /**\\n     * @dev Original asset data.\\n     * @param controller Asset controller.\\n     * @param vault Asset vault.\\n     */\\n    struct AssetConfig {\\n        IAssetController controller;\\n        IAssetVault vault;\\n    }\\n\\n    /**\\n     * @dev Asset registry.\\n     * @param classRegistry Asset class registry contract.\\n     * @param assetIndex Set of registered asset addresses.\\n     * @param assets Mapping from asset address to the asset configuration.\\n     */\\n    struct Registry {\\n        IAssetClassRegistry classRegistry;\\n        EnumerableSetUpgradeable.AddressSet assetIndex;\\n        mapping(address => AssetConfig) assets;\\n    }\\n\\n    /**\\n     * @dev Registers new asset.\\n     */\\n    function registerAsset(\\n        Registry storage self,\\n        bytes4 assetClass,\\n        address asset\\n    ) external {\\n        if (!self.assetIndex.add(asset)) revert AssetIsAlreadyRegistered(asset);\\n\\n        IAssetClassRegistry.ClassConfig memory assetClassConfig = self.classRegistry.assetClassConfig(assetClass);\\n        self.assets[asset].vault = IAssetVault(assetClassConfig.vault);\\n        self.assets[asset].controller = IAssetController(assetClassConfig.controller);\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings.\\n     */\\n    function supportedAssets(\\n        Registry storage self,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory) {\\n        uint256 indexSize = self.assetIndex.length();\\n        if (offset >= indexSize) return new address[](0);\\n\\n        if (limit > indexSize - offset) {\\n            limit = indexSize - offset;\\n        }\\n\\n        address[] memory assets = new address[](limit);\\n        for (uint256 i = 0; i < limit; i++) {\\n            assets[i] = self.assetIndex.at(offset + i);\\n        }\\n        return assets;\\n    }\\n\\n    /**\\n     * @dev Transfers an asset to the vault using associated controller.\\n     */\\n    function transferAssetToVault(\\n        Registry storage self,\\n        Assets.Asset memory asset,\\n        address from\\n    ) external {\\n        // Extract token address from asset struct and check whether the asset is supported.\\n        address assetToken = asset.token();\\n\\n        // Transfer asset to the class asset specific vault.\\n        address assetController = address(self.assets[assetToken].controller);\\n        address assetVault = address(self.assets[assetToken].vault);\\n        assetController.functionDelegateCall(\\n            abi.encodeWithSelector(IAssetController.transferAssetToVault.selector, asset, from, assetVault)\\n        );\\n    }\\n\\n    /**\\n     * @dev Transfers an asset from the vault using associated controller.\\n     */\\n    function returnAssetFromVault(Registry storage self, Assets.Asset memory asset) external {\\n        address assetToken = asset.token();\\n        address assetController = address(self.assets[assetToken].controller);\\n        address assetVault = address(self.assets[assetToken].vault);\\n\\n        assetController.functionDelegateCall(\\n            abi.encodeWithSelector(IAssetController.returnAssetFromVault.selector, asset, assetVault)\\n        );\\n    }\\n\\n    function assetCount(Registry storage self) internal view returns (uint256) {\\n        return self.assetIndex.length();\\n    }\\n\\n    /**\\n     * @dev Checks asset registration by address.\\n     */\\n    function isRegisteredAsset(Registry storage self, address asset) internal view returns (bool) {\\n        return self.assetIndex.contains(asset);\\n    }\\n\\n    /**\\n     * @dev Reverts if asset class is not supported.\\n     * @param assetClass Asset class ID.\\n     */\\n    function checkSupportedAssetClass(Registry storage self, bytes4 assetClass) internal view {\\n        if (!self.classRegistry.isRegisteredAssetClass(assetClass)) revert UnsupportedAssetClass(assetClass);\\n    }\\n\\n    /**\\n     * @dev Returns controller for asset class.\\n     * @param assetClass Asset class ID.\\n     */\\n    function assetClassController(Registry storage self, bytes4 assetClass) internal view returns (address) {\\n        return self.classRegistry.assetClassConfig(assetClass).controller;\\n    }\\n}\\n\",\"keccak256\":\"0x8cbc15637148ec7d7d2fe91be30c05a5acc078a68dec427c3630df81f104ebd6\",\"license\":\"MIT\"},\"contracts/asset/IAssetClassRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./IAssetController.sol\\\";\\nimport \\\"./IAssetVault.sol\\\";\\n\\ninterface IAssetClassRegistry {\\n    /**\\n     * @dev Thrown when the asset class supported by contract does not match the required one.\\n     * @param provided Provided class ID.\\n     * @param required Required class ID.\\n     */\\n    error AssetClassMismatch(bytes4 provided, bytes4 required);\\n\\n    /**\\n     * @dev Thrown upon attempting to register an asset class twice.\\n     * @param assetClass Duplicate asset class ID.\\n     */\\n    error AssetClassIsAlreadyRegistered(bytes4 assetClass);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with unregistered asset class.\\n     * @param assetClass Asset class ID.\\n     */\\n    error UnregisteredAssetClass(bytes4 assetClass);\\n\\n    /**\\n     * @dev Thrown when the asset controller contract does not implement the required interface.\\n     */\\n    error InvalidAssetControllerInterface();\\n\\n    /**\\n     * @dev Thrown when the vault contract does not implement the required interface.\\n     */\\n    error InvalidAssetVaultInterface();\\n\\n    /**\\n     * @dev Emitted when the new asset class is registered.\\n     * @param assetClass Asset class ID.\\n     * @param controller Controller address.\\n     * @param vault Vault address.\\n     */\\n    event AssetClassRegistered(bytes4 indexed assetClass, address indexed controller, address indexed vault);\\n\\n    /**\\n     * @dev Emitted when the asset class controller is changed.\\n     * @param assetClass Asset class ID.\\n     * @param newController New controller address.\\n     */\\n    event AssetClassControllerChanged(bytes4 indexed assetClass, address indexed newController);\\n\\n    /**\\n     * @dev Emitted when the asset class vault is changed.\\n     * @param assetClass Asset class ID.\\n     * @param newVault New vault address.\\n     */\\n    event AssetClassVaultChanged(bytes4 indexed assetClass, address indexed newVault);\\n\\n    /**\\n     * @dev Asset class configuration.\\n     * @param vault Asset class vault.\\n     * @param controller Asset class controller.\\n     */\\n    struct ClassConfig {\\n        address vault;\\n        address controller;\\n    }\\n\\n    /**\\n     * @dev Registers new asset class.\\n     * @param assetClass Asset class ID.\\n     * @param config Asset class initial configuration.\\n     */\\n    function registerAssetClass(bytes4 assetClass, ClassConfig calldata config) external;\\n\\n    /**\\n     * @dev Sets asset class vault.\\n     * @param assetClass Asset class ID.\\n     * @param vault Asset class vault address.\\n     */\\n    function setAssetClassVault(bytes4 assetClass, address vault) external;\\n\\n    /**\\n     * @dev Sets asset class controller.\\n     * @param assetClass Asset class ID.\\n     * @param controller Asset class controller address.\\n     */\\n    function setAssetClassController(bytes4 assetClass, address controller) external;\\n\\n    /**\\n     * @dev Returns asset class configuration.\\n     * @param assetClass Asset class ID.\\n     * @return Asset class configuration.\\n     */\\n    function assetClassConfig(bytes4 assetClass) external view returns (ClassConfig memory);\\n\\n    /**\\n     * @dev Checks asset class registration.\\n     * @param assetClass Asset class ID.\\n     */\\n    function isRegisteredAssetClass(bytes4 assetClass) external view returns (bool);\\n\\n    /**\\n     * @dev Reverts if asset class is not registered.\\n     * @param assetClass Asset class ID.\\n     */\\n    function checkRegisteredAssetClass(bytes4 assetClass) external view;\\n}\\n\",\"keccak256\":\"0x791149d58a1753825558861d216ab2e9b0760987c6192b5c329b132a8d834ae1\",\"license\":\"MIT\"},\"contracts/asset/IAssetController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"./Assets.sol\\\";\\n\\ninterface IAssetController is IERC165 {\\n    /**\\n     * @dev Thrown when the asset has invalid class for specific operation.\\n     * @param provided Provided class ID.\\n     * @param required Required class ID.\\n     */\\n    error AssetClassMismatch(bytes4 provided, bytes4 required);\\n\\n    /**\\n     * @dev Emitted when asset is transferred.\\n     * @param asset Asset being transferred.\\n     * @param from Asset sender.\\n     * @param to Asset recipient.\\n     * @param data Auxiliary data.\\n     */\\n    event AssetTransfer(Assets.Asset asset, address indexed from, address indexed to, bytes data);\\n\\n    /**\\n     * @dev Returns controller asset class.\\n     * @return Asset class ID.\\n     */\\n    function assetClass() external pure returns (bytes4);\\n\\n    /**\\n     * @dev Transfers asset.\\n     * Emits a {AssetTransfer} event.\\n     * @param asset Asset being transferred.\\n     * @param from Asset sender.\\n     * @param to Asset recipient.\\n     * @param data Auxiliary data.\\n     */\\n    function transfer(\\n        Assets.Asset memory asset,\\n        address from,\\n        address to,\\n        bytes memory data\\n    ) external;\\n\\n    /**\\n     * @dev Transfers asset from owner to the vault contract.\\n     * @param asset Asset being transferred.\\n     * @param assetOwner Original asset owner address.\\n     * @param vault Asset vault contract address.\\n     */\\n    function transferAssetToVault(\\n        Assets.Asset memory asset,\\n        address assetOwner,\\n        address vault\\n    ) external;\\n\\n    /**\\n     * @dev Transfers asset from the vault contract to the original owner.\\n     * @param asset Asset being transferred.\\n     * @param vault Asset vault contract address.\\n     */\\n    function returnAssetFromVault(Assets.Asset memory asset, address vault) external;\\n\\n    /**\\n     * @dev Decodes asset ID structure and returns collection identifier.\\n     * The collection ID is byte32 value which is calculated based on the asset class.\\n     * For example, ERC721 collection can be identified by address only,\\n     * but for ERC1155 it should be calculated based on address and token ID.\\n     * @return Collection ID.\\n     */\\n    function collectionId(Assets.AssetId memory assetId) external pure returns (bytes32);\\n}\\n\",\"keccak256\":\"0x54937de22824b9758e92253812167e820af4badc567eca38b2152d9d33a6e68d\",\"license\":\"MIT\"},\"contracts/asset/IAssetVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\n\\ninterface IAssetVault is IERC165 {\\n    /**\\n     * @dev Thrown when the asset is not is found among vault inventory.\\n     */\\n    error AssetNotFound();\\n\\n    /**\\n     * @dev Thrown when the function is called on the vault in recovery mode.\\n     */\\n    error VaultIsInRecoveryMode();\\n\\n    /**\\n     * @dev Thrown when the asset return is not allowed, due to the vault state or the caller permissions.\\n     */\\n    error AssetReturnIsNotAllowed();\\n\\n    /**\\n     * @dev Thrown when the asset deposit is not allowed, due to the vault state or the caller permissions.\\n     */\\n    error AssetDepositIsNotAllowed();\\n\\n    /**\\n     * @dev Emitted when the vault is switched to recovery mode by `account`.\\n     */\\n    event RecoveryModeActivated(address account);\\n\\n    /**\\n     * @dev Activates asset recovery mode.\\n     * Emits a {RecoveryModeActivated} event.\\n     */\\n    function switchToRecoveryMode() external;\\n\\n    /**\\n     * @dev Pauses the vault.\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @dev Unpauses the vault.\\n     */\\n    function unpause() external;\\n\\n    /**\\n     * @dev Returns vault asset class.\\n     * @return Asset class ID.\\n     */\\n    function assetClass() external pure returns (bytes4);\\n\\n    /**\\n     * @dev Returns the Metahub address.\\n     */\\n    function metahub() external view returns (address);\\n\\n    /**\\n     * @dev Returns vault recovery mode flag state.\\n     * @return True when the vault is in recovery mode.\\n     */\\n    function isRecovery() external view returns (bool);\\n}\\n\",\"keccak256\":\"0xb40edb1c017bd69088a8e7ade46127ae932d1f497ea6e36e5ed75a269ce6eb3b\",\"license\":\"MIT\"},\"contracts/listing/IListingController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"./Listings.sol\\\";\\nimport \\\"../renting/Rentings.sol\\\";\\n\\ninterface IListingController is IERC165 {\\n    /**\\n     * @dev Thrown when the listing strategy ID does not match the required one.\\n     * @param provided Provided listing strategy ID.\\n     * @param required Required listing strategy ID.\\n     */\\n    error ListingStrategyMismatch(bytes4 provided, bytes4 required);\\n\\n    /**\\n     * @dev Returns implemented strategy ID.\\n     * @return Listing strategy ID.\\n     */\\n    function strategyId() external pure returns (bytes4);\\n\\n    /**\\n     * @dev Calculates rental fee based on renting params and implemented listing strategy.\\n     * @param listingParams Listing strategy params.\\n     * @param rentingParams Renting params.\\n     * @return Rental fee.\\n     */\\n    function calculateRentalFee(Listings.Params calldata listingParams, Rentings.Params calldata rentingParams)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\",\"keccak256\":\"0x4c11cc5107243b27b514587f3ee61fae92dac30580e77a4c68e5668f17edb5f7\",\"license\":\"MIT\"},\"contracts/listing/IListingStrategyRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"./Listings.sol\\\";\\nimport \\\"./IListingController.sol\\\";\\n\\ninterface IListingStrategyRegistry {\\n    /**\\n     * @dev Thrown when listing controller does not implement the required interface.\\n     */\\n    error InvalidListingControllerInterface();\\n\\n    /**\\n     * @dev Thrown when the listing cannot be processed by the specific controller due to the listing strategy ID\\n     * mismatch.\\n     * @param provided Provided listing strategy ID.\\n     * @param required Required listing strategy ID.\\n     */\\n    error ListingStrategyMismatch(bytes4 provided, bytes4 required);\\n\\n    /**\\n     * @dev Thrown upon attempting to register a listing strategy twice.\\n     * @param strategyId Duplicate listing strategy ID.\\n     */\\n    error ListingStrategyIsAlreadyRegistered(bytes4 strategyId);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with unregistered listing strategy.\\n     * @param strategyId Listing strategy ID.\\n     */\\n    error UnregisteredListingStrategy(bytes4 strategyId);\\n\\n    /**\\n     * @dev Emitted when the new listing strategy is registered.\\n     * @param strategyId Listing strategy ID.\\n     * @param controller Controller address.\\n     */\\n    event ListingStrategyRegistered(bytes4 indexed strategyId, address indexed controller);\\n\\n    /**\\n     * @dev Emitted when the listing strategy controller is changed.\\n     * @param strategyId Listing strategy ID.\\n     * @param newController Controller address.\\n     */\\n    event ListingStrategyControllerChanged(bytes4 indexed strategyId, address indexed newController);\\n\\n    /**\\n     * @dev Listing strategy information.\\n     * @param controller Listing controller address.\\n     */\\n    struct StrategyConfig {\\n        address controller;\\n    }\\n\\n    /**\\n     * @dev Registers new listing strategy.\\n     * @param strategyId Listing strategy ID.\\n     * @param config Listing strategy configuration.\\n     */\\n    function registerListingStrategy(bytes4 strategyId, StrategyConfig calldata config) external;\\n\\n    /**\\n     * @dev Sets listing strategy controller.\\n     * @param strategyId Listing strategy ID.\\n     * @param controller Listing controller address.\\n     */\\n    function setListingController(bytes4 strategyId, address controller) external;\\n\\n    /**\\n     * @dev Returns listing strategy configuration.\\n     * @param strategyId Listing strategy ID.\\n     * @return Listing strategy information.\\n     */\\n    function listingStrategy(bytes4 strategyId) external view returns (StrategyConfig memory);\\n\\n    /**\\n     * @dev Returns listing strategy controller.\\n     * @param strategyId Listing strategy ID.\\n     * @return Listing controller address.\\n     */\\n    function listingController(bytes4 strategyId) external view returns (address);\\n\\n    /**\\n     * @dev Checks listing strategy registration.\\n     * @param strategyId Listing strategy ID.\\n     */\\n    function isRegisteredListingStrategy(bytes4 strategyId) external view returns (bool);\\n\\n    /**\\n     * @dev Reverts if listing strategy is not registered.\\n     * @param strategyId Listing strategy ID.\\n     */\\n    function checkRegisteredListingStrategy(bytes4 strategyId) external view;\\n}\\n\",\"keccak256\":\"0xd97861afe17f1485470b4ca44fe2cbedbe407c859aa7068df0936e63dc8de661\",\"license\":\"MIT\"},\"contracts/listing/ListingController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"./IListingController.sol\\\";\\n\\nabstract contract ListingController is IListingController, ERC165 {\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IListingController).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\",\"keccak256\":\"0xc2c5b070ca0f6e589683afb575cb13260601e116877a68124e196e37d2172032\",\"license\":\"MIT\"},\"contracts/listing/Listings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\n\\nimport \\\"../asset/Assets.sol\\\";\\nimport \\\"./IListingController.sol\\\";\\nimport \\\"./IListingStrategyRegistry.sol\\\";\\n\\nlibrary Listings {\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\\n    using Listings for Registry;\\n    using Listings for Listing;\\n    using Assets for Assets.Asset;\\n\\n    /**\\n     * @dev Thrown when the `listingId` is invalid or the asset has been delisted.\\n     */\\n    error NotListed(uint256 listingId);\\n\\n    /**\\n     * @dev Thrown when the operation is not allowed due to the listing being paused.\\n     */\\n    error ListingIsPaused();\\n\\n    /**\\n     * @dev Thrown when the operation is not allowed due to the listing not being paused.\\n     */\\n    error ListingIsNotPaused();\\n\\n    /**\\n     * @dev Thrown when attempting to lock the listed asset for the period longer than the lister allowed.\\n     */\\n    error InvalidLockPeriod(uint32 period);\\n\\n    /**\\n     * @dev Thrown when the listing strategy is not registered or deprecated.\\n     * @param strategyId Unsupported listing strategy ID.\\n     */\\n    error UnsupportedListingStrategy(bytes4 strategyId);\\n\\n    /*\\n     * @dev Listing strategy identifiers to be used across the system:\\n     */\\n    bytes4 public constant FIXED_PRICE = bytes4(keccak256(\\\"FIXED_PRICE\\\"));\\n\\n    /**\\n     * @dev Listing params.\\n     * The layout of `data` might vary for different listing strategies.\\n     * For example, in case of FIXED_PRICE strategy, the `data` might contain only base rate,\\n     * and for more advanced auction strategies it might include period, min bid step etc.\\n     * @param strategy Listing strategy ID\\n     * @param data Listing strategy data.\\n     */\\n    struct Params {\\n        bytes4 strategy;\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Listing structure.\\n     * @param asset Listed asset structure.\\n     * @param params Listing strategy parameters.\\n     * @param lister Lister account address.\\n     * @param maxLockPeriod The maximum amount of time the asset owner can wait before getting the asset back.\\n     * @param lockedTill The earliest possible time when the asset can be returned to the owner.\\n     * @param immediatePayout Indicates whether the rental fee must be transferred to the lister on every renting.\\n     * If FALSE, the rental fees get accumulated until withdrawn manually.\\n     * @param delisted Indicates whether the asset is delisted.\\n     * @param paused Indicates whether the listing is paused.\\n     */\\n    struct Listing {\\n        Assets.Asset asset;\\n        Params params;\\n        address lister;\\n        uint32 maxLockPeriod;\\n        uint32 lockedTill;\\n        bool immediatePayout;\\n        bool delisted;\\n        bool paused;\\n    }\\n\\n    /**\\n     * @dev Puts the listing on pause.\\n     */\\n    function pause(Listing storage self) internal {\\n        if (self.paused) revert ListingIsPaused();\\n\\n        self.paused = true;\\n    }\\n\\n    /**\\n     * @dev Lifts the listing pause.\\n     */\\n    function unpause(Listing storage self) internal {\\n        if (!self.paused) revert ListingIsNotPaused();\\n\\n        self.paused = false;\\n    }\\n\\n    /**\\n     * Determines whether the listing is active.\\n     */\\n    function listed(Listing storage self) internal view returns (bool) {\\n        return self.lister != address(0) && !self.delisted;\\n    }\\n\\n    /**\\n     * @dev Reverts if the listing is paused.\\n     */\\n    function checkNotPaused(Listing storage self) internal view {\\n        if (self.paused) revert ListingIsPaused();\\n    }\\n\\n    /*\\n     * @dev Validates lock period.\\n     */\\n    function isValidLockPeriod(Listing storage self, uint32 lockPeriod) internal view returns (bool) {\\n        return (lockPeriod > 0 && lockPeriod <= self.maxLockPeriod);\\n    }\\n\\n    /**\\n     * @dev Reverts if the lock period is not valid.\\n     */\\n    function checkValidLockPeriod(Listing storage self, uint32 lockPeriod) internal view {\\n        if (!self.isValidLockPeriod(lockPeriod)) revert InvalidLockPeriod(lockPeriod);\\n    }\\n\\n    /**\\n     * @dev Extends listing lock time.\\n     * Does not modify the state if current lock time is larger.\\n     */\\n    function addLock(Listing storage self, uint32 unlockTimestamp) internal {\\n        // Listing is already locked till later time, no need to extend locking period.\\n        if (self.lockedTill >= unlockTimestamp) return;\\n        // Extend listing lock.\\n        self.lockedTill = unlockTimestamp;\\n    }\\n\\n    /**\\n     * @dev Listing related data associated with the specific account.\\n     * @param listingIndex The set of listing IDs.\\n     */\\n    struct ListerInfo {\\n        EnumerableSetUpgradeable.UintSet listingIndex;\\n    }\\n    /**\\n     * @dev Listing related data associated with the specific account.\\n     * @param listingIndex The set of listing IDs.\\n     */\\n    struct AssetInfo {\\n        EnumerableSetUpgradeable.UintSet listingIndex;\\n    }\\n\\n    /**\\n     * @dev Listing registry.\\n     * @param idTracker Listing ID tracker (incremental counter).\\n     * @param strategyRegistry Listing strategy registry contract.\\n     * @param listingIndex The global set of registered listing IDs.\\n     * @param listings Mapping from listing ID to the listing info.\\n     * @param listers Mapping from lister address to the lister info.\\n     */\\n    struct Registry {\\n        CountersUpgradeable.Counter idTracker;\\n        IListingStrategyRegistry strategyRegistry;\\n        EnumerableSetUpgradeable.UintSet listingIndex;\\n        mapping(uint256 => Listing) listings;\\n        mapping(address => ListerInfo) listers;\\n        mapping(address => AssetInfo) assets;\\n    }\\n\\n    /**\\n     * @dev Registers new listing.\\n     * @return listingId New listing ID.\\n     */\\n    function register(Registry storage self, Listing memory listing) external returns (uint256 listingId) {\\n        // Generate new listing ID.\\n        self.idTracker.increment();\\n        listingId = self.idTracker.current();\\n        // Store new listing record.\\n        self.listings[listingId] = listing;\\n        // Add new listing ID to the global index.\\n        self.listingIndex.add(listingId);\\n        // Add user listing data.\\n        self.listers[listing.lister].listingIndex.add(listingId);\\n        // Add asset listing data.\\n        self.assets[listing.asset.token()].listingIndex.add(listingId);\\n    }\\n\\n    /**\\n     * @dev Removes listing data.\\n     * @param listingId The ID of the listing to be deleted.\\n     */\\n    function remove(Registry storage self, uint256 listingId) external {\\n        address lister = self.listings[listingId].lister;\\n        address original = self.listings[listingId].asset.token();\\n\\n        // Remove the listing ID from the global index.\\n        self.listingIndex.remove(listingId);\\n        // Remove user listing data.\\n        self.listers[lister].listingIndex.remove(listingId);\\n        // Delete asset.\\n        self.assets[original].listingIndex.remove(listingId);\\n        // Delete listing.\\n        delete self.listings[listingId];\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings.\\n     */\\n    function allListings(\\n        Registry storage self,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Listing[] memory) {\\n        return self.paginateIndexedListings(self.listingIndex, offset, limit);\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings for the particular lister account.\\n     */\\n    function userListings(\\n        Registry storage self,\\n        address lister,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Listing[] memory) {\\n        return self.paginateIndexedListings(self.listers[lister].listingIndex, offset, limit);\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings for the original asset.\\n     */\\n    function assetListings(\\n        Registry storage self,\\n        address original,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Listing[] memory) {\\n        return self.paginateIndexedListings(self.assets[original].listingIndex, offset, limit);\\n    }\\n\\n    /**\\n     * @dev Checks listing registration by ID.\\n     * @param listingId Listing ID.\\n     */\\n    function isRegisteredListing(Registry storage self, uint256 listingId) internal view returns (bool) {\\n        return self.listings[listingId].lister != address(0);\\n    }\\n\\n    /**\\n     * @dev Reverts if listing strategy is not supported.\\n     * @param strategyId Listing strategy ID.\\n     */\\n    function checkSupportedListingStrategy(Registry storage self, bytes4 strategyId) internal view {\\n        if (!self.strategyRegistry.isRegisteredListingStrategy(strategyId))\\n            revert UnsupportedListingStrategy(strategyId);\\n    }\\n\\n    /**\\n     * @dev Returns listing controller for strategy.\\n     * @param strategyId Listing strategy ID.\\n     */\\n    function listingController(Registry storage self, bytes4 strategyId) internal view returns (IListingController) {\\n        return IListingController(self.strategyRegistry.listingController(strategyId));\\n    }\\n\\n    /**\\n     * @dev Reverts if listing is not registered or has been already delisted.\\n     * @param listingId Listing ID.\\n     */\\n    function checkListed(Registry storage self, uint256 listingId) internal view {\\n        if (!self.listings[listingId].listed()) revert NotListed(listingId);\\n    }\\n\\n    /**\\n     * @dev Returns the number of currently registered listings.\\n     */\\n    function listingCount(Registry storage self) internal view returns (uint256) {\\n        return self.listingIndex.length();\\n    }\\n\\n    /**\\n     * @dev Returns the number of currently registered listings for a particular lister account.\\n     */\\n    function userListingCount(Registry storage self, address lister) internal view returns (uint256) {\\n        return self.listers[lister].listingIndex.length();\\n    }\\n\\n    /**\\n     * @dev Returns the number of currently registered listings for a particular original asset.\\n     */\\n    function assetListingCount(Registry storage self, address original) internal view returns (uint256) {\\n        return self.assets[original].listingIndex.length();\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listing using provided index reference.\\n     */\\n    function paginateIndexedListings(\\n        Registry storage self,\\n        EnumerableSetUpgradeable.UintSet storage listingIndex,\\n        uint256 offset,\\n        uint256 limit\\n    ) internal view returns (uint256[] memory, Listing[] memory) {\\n        uint256 indexSize = listingIndex.length();\\n        if (offset >= indexSize) return (new uint256[](0), new Listing[](0));\\n\\n        if (limit > indexSize - offset) {\\n            limit = indexSize - offset;\\n        }\\n\\n        Listing[] memory listings = new Listing[](limit);\\n        uint256[] memory listingIds = new uint256[](limit);\\n        for (uint256 i = 0; i < limit; i++) {\\n            listingIds[i] = listingIndex.at(offset + i);\\n            listings[i] = self.listings[listingIds[i]];\\n        }\\n\\n        return (listingIds, listings);\\n    }\\n}\\n\",\"keccak256\":\"0x4963d5c2969c24e3568c295b9cdd9455e8469297bbbd8a788efc10311c0eb9c1\",\"license\":\"MIT\"},\"contracts/listing/strategies/FixedPriceListingController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"../IListingController.sol\\\";\\nimport \\\"../Listings.sol\\\";\\nimport \\\"../ListingController.sol\\\";\\n\\ncontract FixedPriceListingController is ListingController {\\n    /**\\n     * @inheritdoc IListingController\\n     */\\n    function calculateRentalFee(Listings.Params calldata strategyParams, Rentings.Params calldata rentingParams)\\n        external\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 baseRate = _decodeStrategyParams(strategyParams);\\n        return rentingParams.rentalPeriod * baseRate;\\n    }\\n\\n    /**\\n     * @inheritdoc IListingController\\n     */\\n    function strategyId() public pure returns (bytes4) {\\n        return Listings.FIXED_PRICE;\\n    }\\n\\n    /**\\n     * @dev Decodes listing strategy params.\\n     * @param params Encoded listing strategy params.\\n     * @return baseRate Asset renting base rate (base tokens per second).\\n     */\\n    function _decodeStrategyParams(Listings.Params memory params) internal pure returns (uint256 baseRate) {\\n        _checkStrategy(params.strategy);\\n        return abi.decode(params.data, (uint256));\\n    }\\n\\n    /**\\n     * @dev Reverts if strategy is not compatible.\\n     * @param checkedStrategyId Strategy ID.\\n     */\\n    function _checkStrategy(bytes4 checkedStrategyId) internal pure {\\n        if (checkedStrategyId != strategyId()) revert ListingStrategyMismatch(checkedStrategyId, strategyId());\\n    }\\n}\\n\",\"keccak256\":\"0x994ef816f7b35f2a6177d49ba540ee59ca328e79042b253951c3246f8627fa7c\",\"license\":\"MIT\"},\"contracts/metahub/Protocol.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nlibrary Protocol {\\n    /**\\n     * @dev Thrown when the provided token does not match with the configured base token.\\n     */\\n    error BaseTokenMismatch();\\n\\n    /**\\n     * @dev Protocol configuration.\\n     * @param baseToken ERC20 contract. Used as the price denominator.\\n     * @param rentalFeePercent The fixed part of the total rental fee paid to protocol.\\n     */\\n    struct Config {\\n        IERC20Upgradeable baseToken;\\n        uint16 rentalFeePercent;\\n    }\\n\\n    /**\\n     * @dev Reverts if the `token` does not match the base one.\\n     */\\n    function checkBaseToken(Config storage self, address token) internal view {\\n        if (token != address(self.baseToken)) revert BaseTokenMismatch();\\n    }\\n}\\n\",\"keccak256\":\"0xc1af6f1b39d9f846aa6cc58f01c24957439b43be00ec7a2c0d3b720f9917f278\",\"license\":\"MIT\"},\"contracts/renting/Rentings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"../asset/Assets.sol\\\";\\nimport \\\"../metahub/Protocol.sol\\\";\\nimport \\\"../listing/Listings.sol\\\";\\nimport \\\"../warper/Warpers.sol\\\";\\nimport \\\"../universe/IUniverseRegistry.sol\\\";\\n\\nlibrary Rentings {\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\\n    using Rentings for RenterInfo;\\n    using Rentings for Agreement;\\n    using Rentings for Registry;\\n    using Assets for Assets.AssetId;\\n    using Protocol for Protocol.Config;\\n    using Listings for Listings.Registry;\\n    using Listings for Listings.Listing;\\n    using Warpers for Warpers.Registry;\\n    using Warpers for Warpers.Warper;\\n\\n    /**\\n     * @dev Thrown when a rental agreement is being registered for a specific warper ID,\\n     * while the previous rental agreement for this warper is still effective.\\n     */\\n    error RentalAgreementConflict(uint256 conflictingRentalId);\\n\\n    /**\\n     * @dev Thrown when attempting to delete effective rental agreement data (before expiration).\\n     */\\n    error CannotDeleteEffectiveRentalAgreement(uint256 rentalId);\\n\\n    /**\\n     * @dev Warper rental status.\\n     * NONE - means the warper had never been minted.\\n     * AVAILABLE - can be rented.\\n     * RENTED - currently rented.\\n     */\\n    enum RentalStatus {\\n        NONE,\\n        AVAILABLE,\\n        RENTED\\n    }\\n\\n    /**\\n     * @dev Defines the maximal allowed number of cycles when looking for expired rental agreements.\\n     */\\n    uint256 private constant _GC_CYCLES = 20;\\n\\n    /**\\n     * @dev Rental fee breakdown.\\n     */\\n    struct RentalFees {\\n        uint256 total;\\n        uint256 protocolFee;\\n        uint256 listerBaseFee;\\n        uint256 listerPremium;\\n        uint256 universeBaseFee;\\n        uint256 universePremium;\\n    }\\n\\n    /**\\n     * @dev Renting parameters structure.\\n     * It is used to encode all the necessary information to estimate and/or fulfill a particular renting request.\\n     * @param listingId Listing ID. Also allows to identify the asset being rented.\\n     * @param warper Warper address.\\n     * @param renter Renter address.\\n     * @param rentalPeriod Desired period of asset renting.\\n     * @param paymentToken The token address which renter offers as a mean of payment.\\n     */\\n    struct Params {\\n        uint256 listingId;\\n        address warper;\\n        address renter;\\n        uint32 rentalPeriod;\\n        address paymentToken;\\n    }\\n\\n    /**\\n     * @dev Rental agreement information.\\n     * @param warpedAsset Rented asset.\\n     * @param collectionId Warped collection ID.\\n     * @param listingId The corresponding ID of the original asset listing.\\n     * @param renter The renter account address.\\n     * @param startTime The rental agreement staring time. This is the timestamp after which the `renter`\\n     * considered to be an warped asset owner.\\n     * @param endTime The rental agreement ending time. After this timestamp, the rental agreement is terminated\\n     * and the `renter` is no longer the owner of the warped asset.\\n     */\\n    struct Agreement {\\n        Assets.Asset warpedAsset;\\n        bytes32 collectionId;\\n        uint256 listingId;\\n        address renter;\\n        uint32 startTime;\\n        uint32 endTime;\\n    }\\n\\n    function isEffective(Agreement storage self) internal view returns (bool) {\\n        return self.endTime > uint32(block.timestamp);\\n    }\\n\\n    function duration(Agreement memory self) internal pure returns (uint32) {\\n        return self.endTime - self.startTime;\\n    }\\n\\n    /**\\n     * @dev Describes user specific renting information.\\n     * @param rentalIndex Renter's set of rental agreement IDs.\\n     * @param collectionRentalIndex Mapping from collection ID to the set of rental IDs.\\n     */\\n    struct RenterInfo {\\n        EnumerableSetUpgradeable.UintSet rentalIndex;\\n        mapping(bytes32 => EnumerableSetUpgradeable.UintSet) collectionRentalIndex;\\n    }\\n\\n    /**\\n     * @dev Describes asset specific renting information.\\n     * @param latestRentalId Holds the most recent rental agreement ID.\\n     */\\n    struct AssetInfo {\\n        uint256 latestRentalId; // NOTE: This must never be deleted during cleanup.\\n    }\\n\\n    /**\\n     * @dev Renting registry.\\n     * @param idTracker Rental agreement ID tracker (incremental counter).\\n     * @param agreements Mapping from rental ID to the rental agreement details.\\n     * @param renters Mapping from renter address to the user specific renting info.\\n     * @param assets Mapping from asset ID (byte32) to the asset specific renting info.\\n     */\\n    struct Registry {\\n        CountersUpgradeable.Counter idTracker;\\n        mapping(uint256 => Agreement) agreements;\\n        mapping(address => RenterInfo) renters;\\n        mapping(bytes32 => AssetInfo) assets;\\n    }\\n\\n    /**\\n     * @dev Returns the number of currently registered rental agreements for particular renter account.\\n     */\\n    function userRentalCount(Registry storage self, address renter) internal view returns (uint256) {\\n        return self.renters[renter].rentalIndex.length();\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered rental agreements for particular renter account.\\n     */\\n    function userRentalAgreements(\\n        Registry storage self,\\n        address renter,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Rentings.Agreement[] memory) {\\n        EnumerableSetUpgradeable.UintSet storage userRentalIndex = self.renters[renter].rentalIndex;\\n        uint256 indexSize = userRentalIndex.length();\\n        if (offset >= indexSize) return (new uint256[](0), new Rentings.Agreement[](0));\\n\\n        if (limit > indexSize - offset) {\\n            limit = indexSize - offset;\\n        }\\n\\n        Rentings.Agreement[] memory agreements = new Rentings.Agreement[](limit);\\n        uint256[] memory rentalIds = new uint256[](limit);\\n        for (uint256 i = 0; i < limit; i++) {\\n            rentalIds[i] = userRentalIndex.at(offset + i);\\n            agreements[i] = self.agreements[rentalIds[i]];\\n        }\\n\\n        return (rentalIds, agreements);\\n    }\\n\\n    /**\\n     * @dev Finds expired user rental agreements associated with `collectionId` and deletes them.\\n     * Deletes only first N entries defined by `toBeRemoved` param.\\n     * The total number of cycles is capped by GC_CYCLES constant.\\n     */\\n    function deleteExpiredUserRentalAgreements(\\n        Registry storage self,\\n        address renter,\\n        bytes32 collectionId,\\n        uint256 toBeRemoved\\n    ) external {\\n        EnumerableSetUpgradeable.UintSet storage rentalIndex = self.renters[renter].collectionRentalIndex[collectionId];\\n        uint256 rentalCount = rentalIndex.length();\\n        if (rentalCount == 0 || toBeRemoved == 0) return;\\n\\n        uint256 maxCycles = rentalCount < _GC_CYCLES ? rentalCount : _GC_CYCLES;\\n        uint256 removed = 0;\\n\\n        for (uint256 i = 0; i < maxCycles; i++) {\\n            uint256 rentalId = rentalIndex.at(i);\\n\\n            if (!self.agreements[rentalId].isEffective()) {\\n                // Warning: we are iterating an array that we are also modifying!\\n                _removeRentalAgreement(self, rentalId);\\n                removed += 1;\\n                maxCycles -= 1; // This is so we account for reduced `rentalCount`.\\n\\n                // Stop iterating if we have cleaned up enough desired items.\\n                if (removed == toBeRemoved) break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs new rental agreement registration.\\n     */\\n    function register(Registry storage self, Agreement memory agreement) external returns (uint256 rentalId) {\\n        // Make sure the there is no active rentals for the warper ID.\\n        bytes32 assetId = agreement.warpedAsset.id.hash();\\n        uint256 latestRentalId = self.assets[assetId].latestRentalId;\\n        if (latestRentalId != 0 && self.agreements[latestRentalId].isEffective()) {\\n            revert RentalAgreementConflict(latestRentalId);\\n        }\\n\\n        // Generate new rental ID.\\n        self.idTracker.increment();\\n        rentalId = self.idTracker.current();\\n\\n        // Save new rental agreement.\\n        self.agreements[rentalId] = agreement;\\n\\n        // Update warper latest rental ID.\\n        self.assets[assetId].latestRentalId = rentalId;\\n\\n        // Update user rental data.\\n        self.renters[agreement.renter].rentalIndex.add(rentalId);\\n        self.renters[agreement.renter].collectionRentalIndex[agreement.collectionId].add(rentalId);\\n    }\\n\\n    /**\\n     * @dev Safely removes expired rental data from the registry.\\n     */\\n    function removeExpiredRentalAgreement(Registry storage self, uint256 rentalId) external {\\n        if (self.agreements[rentalId].isEffective()) revert CannotDeleteEffectiveRentalAgreement(rentalId);\\n        _removeRentalAgreement(self, rentalId);\\n    }\\n\\n    /**\\n     * @dev Removes rental data from the registry.\\n     */\\n    function _removeRentalAgreement(Registry storage self, uint256 rentalId) private {\\n        address renter = self.agreements[rentalId].renter;\\n        bytes32 collectionId = self.agreements[rentalId].collectionId;\\n\\n        // Remove user rental data.\\n        self.renters[renter].rentalIndex.remove(rentalId);\\n        self.renters[renter].collectionRentalIndex[collectionId].remove(rentalId);\\n\\n        // Delete rental agreement.\\n        delete self.agreements[rentalId];\\n    }\\n\\n    /**\\n     * @dev Finds all effective rental agreements from specific collection.\\n     * Returns the total value rented by `renter`.\\n     */\\n    function collectionRentedValue(\\n        Registry storage self,\\n        address renter,\\n        bytes32 collectionId\\n    ) external view returns (uint256 value) {\\n        EnumerableSetUpgradeable.UintSet storage rentalIndex = self.renters[renter].collectionRentalIndex[collectionId];\\n        uint256 length = rentalIndex.length();\\n        for (uint256 i = 0; i < length; i++) {\\n            Agreement storage agreement = self.agreements[rentalIndex.at(i)];\\n            if (agreement.isEffective()) {\\n                value += agreement.warpedAsset.value;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns asset rental status based on latest rental agreement.\\n     */\\n    function assetRentalStatus(Registry storage self, Assets.AssetId memory assetId)\\n        external\\n        view\\n        returns (RentalStatus)\\n    {\\n        uint256 latestRentalId = self.assets[assetId.hash()].latestRentalId;\\n        if (latestRentalId == 0) return RentalStatus.NONE;\\n\\n        return self.agreements[latestRentalId].isEffective() ? RentalStatus.RENTED : RentalStatus.AVAILABLE;\\n    }\\n\\n    /**\\n     * @dev Main renting request validation function.\\n     */\\n    function validateRentingParams(\\n        Params calldata params,\\n        Protocol.Config storage protocolConfig,\\n        Listings.Registry storage listingRegistry,\\n        Warpers.Registry storage warperRegistry\\n    ) external view {\\n        // Validate from the protocol perspective.\\n        protocolConfig.checkBaseToken(params.paymentToken);\\n\\n        // Validate from the listing perspective.\\n        listingRegistry.checkListed(params.listingId);\\n        Listings.Listing storage listing = listingRegistry.listings[params.listingId];\\n        listing.checkNotPaused();\\n        listing.checkValidLockPeriod(params.rentalPeriod);\\n\\n        // Validate from the warper perspective.\\n        warperRegistry.checkRegisteredWarper(params.warper);\\n        Warpers.Warper storage warper = warperRegistry.warpers[params.warper];\\n        warper.checkCompatibleAsset(listing.asset);\\n        warper.checkNotPaused();\\n        warper.controller.validateRentingParams(listing.asset, params);\\n    }\\n\\n    /**\\n     * @dev Performs rental fee calculation and returns the fee breakdown.\\n     */\\n    function calculateRentalFees(\\n        Params calldata rentingParams,\\n        Protocol.Config storage protocolConfig,\\n        Listings.Registry storage listingRegistry,\\n        Warpers.Registry storage warperRegistry,\\n        IUniverseRegistry universeRegistry\\n    ) external view returns (RentalFees memory fees) {\\n        // Calculate lister base fee.\\n        Listings.Listing storage listing = listingRegistry.listings[rentingParams.listingId];\\n        Listings.Params memory listingParams = listing.params;\\n        // Resolve listing controller to calculate lister fee based on selected listing strategy.\\n        IListingController listingController = listingRegistry.listingController(listingParams.strategy);\\n        fees.listerBaseFee = listingController.calculateRentalFee(listingParams, rentingParams);\\n\\n        // Calculate universe base fee.\\n        Warpers.Warper storage warper = warperRegistry.warpers[rentingParams.warper];\\n        uint16 universeRentalFeePercent = universeRegistry.universeRentalFeePercent(warper.universeId);\\n        fees.universeBaseFee = (fees.listerBaseFee * universeRentalFeePercent) / 10_000;\\n\\n        // Calculate protocol fee.\\n        fees.protocolFee = (fees.listerBaseFee * protocolConfig.rentalFeePercent) / 10_000;\\n\\n        // Calculate warper premiums.\\n        (uint256 universePremium, uint256 listerPremium) = warper.controller.calculatePremiums(\\n            listing.asset,\\n            rentingParams,\\n            fees.universeBaseFee,\\n            fees.listerBaseFee\\n        );\\n        fees.listerPremium = listerPremium;\\n        fees.universePremium = universePremium;\\n\\n        // Calculate TOTAL rental fee.\\n        fees.total += fees.listerBaseFee + listerPremium;\\n        fees.total += fees.universeBaseFee + universePremium;\\n        fees.total += fees.protocolFee;\\n    }\\n}\\n\",\"keccak256\":\"0x7e9dd37e7eb41e22a2fbe4d0fc0edd63e7d2fc2bd37f22160470c639d48d7296\",\"license\":\"MIT\"},\"contracts/universe/IUniverseRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IUniverseRegistry {\\n    /**\\n     * @dev Thrown when a check is made where the given account must also be the universe owner.\\n     */\\n    error AccountIsNotUniverseOwner(address account);\\n\\n    /**\\n     * @dev Thrown when a the supplied universe name is empty.\\n     */\\n    error EmptyUniverseName();\\n\\n    /**\\n     * @dev Thrown when trying to read universe data for a universe is not registered.\\n     */\\n    error QueryForNonexistentUniverse(uint256 universeId);\\n\\n    /**\\n     * @dev Emitted when a universe is created.\\n     * @param universeId Universe ID.\\n     * @param name Universe name.\\n     */\\n    event UniverseCreated(uint256 indexed universeId, string name);\\n\\n    /**\\n     * @dev Emitted when a universe name is changed.\\n     * @param universeId Universe ID.\\n     * @param name The newly set name.\\n     */\\n    event UniverseNameChanged(uint256 indexed universeId, string name);\\n\\n    /**\\n     * @dev Emitted when universe rental fee is changed.\\n     * @param universeId Universe ID.\\n     * @param rentalFeePercent The newly rental fee.\\n     */\\n    event UniverseRentalFeeChanged(uint256 indexed universeId, uint16 rentalFeePercent);\\n\\n    /**\\n     * @dev Updates the universe token base URI.\\n     * @param baseURI New base URI. Must include a trailing slash (\\\"/\\\").\\n     */\\n    function setUniverseTokenBaseURI(string calldata baseURI) external;\\n\\n    /**\\n     * @dev The universe properties & initial configuration params.\\n     * @param name The universe name.\\n     * @param rentalFeePercent The base percentage of the rental fee which the universe charges for using its warpers.\\n     */\\n    struct UniverseParams {\\n        string name;\\n        uint16 rentalFeePercent;\\n    }\\n\\n    /**\\n     * @dev Creates new Universe. This includes minting new universe NFT,\\n     * where the caller of this method becomes the universe owner.\\n     * @param params The universe properties & initial configuration params.\\n     * @return Universe ID (universe token ID).\\n     */\\n    function createUniverse(UniverseParams calldata params) external returns (uint256);\\n\\n    /**\\n     * @dev Update the universe name.\\n     * @param universeId The unique identifier for the universe.\\n     * @param universeName The universe name to set.\\n     */\\n    function setUniverseName(uint256 universeId, string memory universeName) external;\\n\\n    /**\\n     * @dev Update the universe rental fee percent.\\n     * @param universeId The unique identifier for the universe.\\n     * @param rentalFeePercent The universe rental fee percent.\\n     */\\n    function setUniverseRentalFeePercent(uint256 universeId, uint16 rentalFeePercent) external;\\n\\n    /**\\n     * @dev Returns Universe owner address.\\n     * @param universeId Universe ID.\\n     * @return Universe owner.\\n     */\\n    function universeOwner(uint256 universeId) external view returns (address);\\n\\n    /**\\n     * @dev Returns Universe rental fee percent.\\n     * @param universeId Universe ID.\\n     * @return universe fee percent.\\n     */\\n    function universeRentalFeePercent(uint256 universeId) external view returns (uint16);\\n\\n    /**\\n     * @dev Returns name.\\n     * @param universeId Universe ID.\\n     * @return universe name.\\n     */\\n    function universeName(uint256 universeId) external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Universe token address.\\n     */\\n    function universeToken() external view returns (address);\\n\\n    /**\\n     * @dev Returns the Universe token base URI.\\n     */\\n    function universeTokenBaseURI() external view returns (string memory);\\n\\n    /**\\n     * @dev Aggregate and return Universe data.\\n     * @param universeId Universe-specific ID.\\n     * @return name The name of the universe.\\n     * @param rentalFeePercent The base percentage of the rental fee which the universe charges for using its warpers.\\n     */\\n    function universe(uint256 universeId) external view returns (string memory name, uint16 rentalFeePercent);\\n\\n    /**\\n     * @dev Reverts if the universe owner is not the provided account address.\\n     * @param universeId Universe ID.\\n     * @param account The address of the expected owner.\\n     */\\n    function checkUniverseOwner(uint256 universeId, address account) external view;\\n\\n    /**\\n     * @dev Returns `true` if the universe owner is the supplied account address.\\n     * @param universeId Universe ID.\\n     * @param account The address of the expected owner.\\n     */\\n    function isUniverseOwner(uint256 universeId, address account) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x1f45f0c2617fcd93577ca148c6bdbff8b493219a54646e84709154b73c0f16c2\",\"license\":\"MIT\"},\"contracts/warper/IWarper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable private-vars-leading-underscore\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\n\\ninterface IWarper is IERC165 {\\n    /**\\n     * @dev Returns the original asset address.\\n     */\\n    function __original() external view returns (address);\\n\\n    /**\\n     * @dev Returns the Metahub address.\\n     */\\n    function __metahub() external view returns (address);\\n\\n    /**\\n     * @dev Returns the warper asset class ID.\\n     */\\n    function __assetClass() external view returns (bytes4);\\n\\n    /**\\n     * @dev Validates if a warper supports multiple interfaces at once.\\n     * @return an array of `bool` flags in order as the `interfaceIds` were passed.\\n     */\\n    function __supportedInterfaces(bytes4[] memory interfaceIds) external view returns (bool[] memory);\\n}\\n\",\"keccak256\":\"0xc42dfdd79bef10aa493c477d481b2f3a6d38f553fbffdd808c43d52a8dda28d7\",\"license\":\"MIT\"},\"contracts/warper/IWarperController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"../asset/Assets.sol\\\";\\nimport \\\"../renting/Rentings.sol\\\";\\nimport \\\"../asset/IAssetController.sol\\\";\\nimport \\\"./IWarper.sol\\\";\\n\\ninterface IWarperController is IAssetController {\\n    /**\\n     * @dev Thrown if warper interface is not compatible with the controller.\\n     */\\n    error IncompatibleWarperInterface();\\n\\n    /**\\n     * @dev Thrown upon attempting to use the warper with an asset different from the one expected by the warper.\\n     */\\n    error InvalidAssetForWarper(address warper, address asset);\\n\\n    /**\\n     * @dev Thrown upon attempting to rent a warped asset which is already rented.\\n     */\\n    error AlreadyRented();\\n\\n    /**\\n     * @dev Takes an existing asset and then mints a warper token representing it.\\n     *      Used in Metahub->Warper communication.\\n     * @param asset The asset that must be warped.\\n     * @param warper Warper contract to used for warping.\\n     * @param to The account which will receive the warped asset.\\n     * @return collectionId Warped collection ID.\\n     * @return warpedAsset Warper asset structure.\\n     */\\n    function warp(\\n        Assets.Asset calldata asset,\\n        address warper,\\n        address to\\n    ) external returns (bytes32 collectionId, Assets.Asset memory warpedAsset);\\n\\n    /**\\n     * @dev Validates that the warper interface is supported by the current WarperController.\\n     * @param warper Warper whose interface we must validate.\\n     * @return bool - `true` if warper is supported.\\n     */\\n    function isCompatibleWarper(address warper) external view returns (bool);\\n\\n    /**\\n     * @dev Reverts if provided warper is not compatible with the controller.\\n     */\\n    function checkCompatibleWarper(address warper) external view;\\n\\n    /**\\n     * @dev Validates renting params taking into account various warper mechanics.\\n     * Throws an error if the specified asset cannot be rented with particular renting parameters.\\n     * @param asset Asset being rented.\\n     * @param rentingParams Renting parameters.\\n     */\\n    function validateRentingParams(Assets.Asset calldata asset, Rentings.Params calldata rentingParams) external view;\\n\\n    /**\\n     * @dev Calculates the universe and/or lister premiums.\\n     * Those are extra amounts that should be added the the resulting rental fee paid by renter.\\n     * @param asset Asset being rented.\\n     * @param rentingParams Renting parameters.\\n     * @param universeFee The current value of the universe fee component.\\n     * @param listerFee The current value of the lister fee component.\\n     * @return universePremium The universe premium amount.\\n     * @return listerPremium The lister premium amount.\\n     */\\n    function calculatePremiums(\\n        Assets.Asset calldata asset,\\n        Rentings.Params calldata rentingParams,\\n        uint256 universeFee,\\n        uint256 listerFee\\n    ) external view returns (uint256 universePremium, uint256 listerPremium);\\n}\\n\",\"keccak256\":\"0x7751c32ba6ffda927fea94a97515fc2b7b4a9e9ba67e55b70f9bd1cce775c981\",\"license\":\"MIT\"},\"contracts/warper/IWarperPresetFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface IWarperPresetFactory {\\n    // TODO Docs\\n    error InvalidWarperPresetInterface();\\n    error DuplicateWarperPresetId(bytes32 presetId);\\n    error DisabledWarperPreset(bytes32 presetId);\\n    error EnabledWarperPreset(bytes32 presetId);\\n    error WarperPresetNotRegistered(bytes32 presetId);\\n\\n    /**\\n     * @dev Thrown when the provided preset initialization data is empty.\\n     */\\n    error EmptyPresetData();\\n\\n    struct WarperPreset {\\n        bytes32 id;\\n        address implementation;\\n        bool enabled;\\n    }\\n\\n    /**\\n     * @dev Emitted when new warper preset is added.\\n     */\\n    event WarperPresetAdded(bytes32 indexed presetId, address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when a warper preset is disabled.\\n     */\\n    event WarperPresetDisabled(bytes32 indexed presetId);\\n\\n    /**\\n     * @dev Emitted when a warper preset is enabled.\\n     */\\n    event WarperPresetEnabled(bytes32 indexed presetId);\\n\\n    /**\\n     * @dev Emitted when a warper preset is enabled.\\n     */\\n    event WarperPresetRemoved(bytes32 indexed presetId);\\n\\n    /**\\n     * @dev Emitted when a warper preset is deployed.\\n     */\\n    event WarperPresetDeployed(bytes32 indexed presetId, address indexed warper);\\n\\n    /**\\n     * @dev Stores the association between `presetId` and `implementation` address.\\n     * NOTE: Warper `implementation` must be deployed beforehand.\\n     * @param presetId Warper preset id.\\n     * @param implementation Warper implementation address.\\n     */\\n    function addPreset(bytes32 presetId, address implementation) external;\\n\\n    /**\\n     * @dev Removes the association between `presetId` and its implementation.\\n     * @param presetId Warper preset id.\\n     */\\n    function removePreset(bytes32 presetId) external;\\n\\n    /**\\n     * @dev Enables warper preset, which makes it deployable.\\n     * @param presetId Warper preset id.\\n     */\\n    function enablePreset(bytes32 presetId) external;\\n\\n    /**\\n     * @dev Disable warper preset, which makes non-deployable.\\n     * @param presetId Warper preset id.\\n     */\\n    function disablePreset(bytes32 presetId) external;\\n\\n    /**\\n     * @dev Deploys a new warper from the preset identified by `presetId`.\\n     * @param presetId Warper preset id.\\n     * @param initData Warper initialization payload.\\n     * @return Deployed warper address.\\n     */\\n    function deployPreset(bytes32 presetId, bytes calldata initData) external returns (address);\\n\\n    /**\\n     * @dev Checks whether warper preset is enabled and available for deployment.\\n     * @param presetId Warper preset id.\\n     */\\n    function presetEnabled(bytes32 presetId) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the list of all registered warper presets.\\n     */\\n    function presets() external view returns (WarperPreset[] memory);\\n\\n    /**\\n     * @dev Returns the warper preset details.\\n     * @param presetId Warper preset id.\\n     */\\n    function preset(bytes32 presetId) external view returns (WarperPreset memory);\\n}\\n\",\"keccak256\":\"0x8f8b1275a6cbfdded6003f10f33b6a6e03ae6f4aaa225e0c10fa6d7148c32eb4\",\"license\":\"MIT\"},\"contracts/warper/Warpers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\n\\nimport \\\"./IWarperController.sol\\\";\\nimport \\\"./IWarperPresetFactory.sol\\\";\\nimport \\\"../asset/Assets.sol\\\";\\n\\nlibrary Warpers {\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n    using Warpers for Registry;\\n    using Assets for Assets.Asset;\\n\\n    /**\\n     * @dev Thrown when performing action or accessing data of an unknown warper.\\n     * @param warper Warper address.\\n     */\\n    error WarperIsNotRegistered(address warper);\\n\\n    /**\\n     * @dev Thrown upon attempting to register a warper twice.\\n     * @param warper Duplicate warper address.\\n     */\\n    error WarperIsAlreadyRegistered(address warper);\\n\\n    /**\\n     * @dev Thrown when the operation is not allowed due to the warper being paused.\\n     */\\n    error WarperIsPaused();\\n\\n    /**\\n     * @dev Thrown when the operation is not allowed due to the warper not being paused.\\n     */\\n    error WarperIsNotPaused();\\n\\n    /**\\n     * @dev Thrown when there are no registered warpers for a particular asset.\\n     * @param asset Asset address.\\n     */\\n    error UnsupportedAsset(address asset);\\n\\n    /**\\n     * @dev Thrown upon attempting to use the warper which is not registered for the provided asset.\\n     */\\n    error IncompatibleAsset(address asset);\\n\\n    /**\\n     * @dev Registered warper data.\\n     * @param original Original asset contract address.\\n     * @param controller Warper controller.\\n     * @param name Warper name.\\n     * @param universeId Warper universe ID.\\n     * @param paused Indicates whether the warper is paused.\\n     */\\n    struct Warper {\\n        address original;\\n        IWarperController controller;\\n        string name;\\n        uint256 universeId;\\n        bool paused;\\n    }\\n\\n    /**\\n     * @dev Reverts if the warper original does not match the `asset`;\\n     */\\n    function checkCompatibleAsset(Warper storage self, Assets.Asset memory asset) internal view {\\n        address original = asset.token();\\n        if (self.original != original) revert IncompatibleAsset(original);\\n    }\\n\\n    /**\\n     * @dev Puts the warper on pause.\\n     */\\n    function pause(Warper storage self) internal {\\n        if (self.paused) revert WarperIsPaused();\\n\\n        self.paused = true;\\n    }\\n\\n    /**\\n     * @dev Lifts the warper pause.\\n     */\\n    function unpause(Warper storage self) internal {\\n        if (!self.paused) revert WarperIsNotPaused();\\n\\n        self.paused = false;\\n    }\\n\\n    /**\\n     * @dev Reverts if the warper is paused.\\n     */\\n    function checkNotPaused(Warper storage self) internal view {\\n        if (self.paused) revert WarperIsPaused();\\n    }\\n\\n    /**\\n     * @dev Warper registry.\\n     * @param presetFactory Warper preset factory contract.\\n     * @param warperIndex Set of registered warper addresses.\\n     * @param universeWarperIndex Mapping from a universe ID to the set of warper addresses registered by the universe.\\n     * @param assetWarperIndex Mapping from an original asset address to the set of warper addresses,\\n     * registered for the asset.\\n     * @param warpers Mapping from a warper address to the warper details.\\n     */\\n    struct Registry {\\n        IWarperPresetFactory presetFactory;\\n        EnumerableSetUpgradeable.AddressSet warperIndex;\\n        mapping(uint256 => EnumerableSetUpgradeable.AddressSet) universeWarperIndex;\\n        mapping(address => EnumerableSetUpgradeable.AddressSet) assetWarperIndex;\\n        mapping(address => Warpers.Warper) warpers;\\n    }\\n\\n    /**\\n     * @dev Performs warper registration.\\n     */\\n    function register(\\n        Registry storage self,\\n        address warperAddress,\\n        Warper memory warper\\n    ) external {\\n        if (!self.warperIndex.add(warperAddress)) revert WarperIsAlreadyRegistered(warperAddress);\\n\\n        // Ensure warper compatibility with the current generation of asset controller.\\n        warper.controller.checkCompatibleWarper(warperAddress);\\n\\n        // Create warper main registration record.\\n        self.warpers[warperAddress] = warper;\\n        // Associate the warper with the universe.\\n        self.universeWarperIndex[warper.universeId].add(warperAddress);\\n        // Associate the warper with the original asset.\\n        self.assetWarperIndex[warper.original].add(warperAddress);\\n    }\\n\\n    /**\\n     * @dev Removes warper data from the registry.\\n     */\\n    function remove(Registry storage self, address warperAddress) external {\\n        Warper storage warper = self.warpers[warperAddress];\\n        // Clean up universe index.\\n        self.universeWarperIndex[warper.universeId].remove(warperAddress);\\n        // Clean up asset index.\\n        self.assetWarperIndex[warper.original].remove(warperAddress);\\n        // Clean up main index.\\n        self.warperIndex.remove(warperAddress);\\n        // Delete warper data.\\n        delete self.warpers[warperAddress];\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of warpers belonging to the particular universe.\\n     */\\n    function universeWarpers(\\n        Registry storage self,\\n        uint256 universeId,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory, Warpers.Warper[] memory) {\\n        return self.paginateIndexedWarpers(self.universeWarperIndex[universeId], offset, limit);\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of warpers associated with the particular original asset.\\n     */\\n    function assetWarpers(\\n        Registry storage self,\\n        address original,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory, Warpers.Warper[] memory) {\\n        return self.paginateIndexedWarpers(self.assetWarperIndex[original], offset, limit);\\n    }\\n\\n    /**\\n     * @dev Checks warper registration by address.\\n     */\\n    function isRegisteredWarper(Registry storage self, address warper) internal view returns (bool) {\\n        return self.warperIndex.contains(warper);\\n    }\\n\\n    /**\\n     * @dev Reverts if warper is not registered.\\n     */\\n    function checkRegisteredWarper(Registry storage self, address warper) internal view {\\n        if (!self.isRegisteredWarper(warper)) revert WarperIsNotRegistered(warper);\\n    }\\n\\n    /**\\n     * @dev Reverts if asset is not supported.\\n     * @param asset Asset address.\\n     */\\n    function checkSupportedAsset(Registry storage self, address asset) internal view {\\n        if (!self.isSupportedAsset(asset)) revert UnsupportedAsset(asset);\\n    }\\n\\n    /**\\n     * @dev Checks asset support by address.\\n     * The supported asset should have at least one warper.\\n     * @param asset Asset address.\\n     */\\n    function isSupportedAsset(Registry storage self, address asset) internal view returns (bool) {\\n        return self.assetWarperIndex[asset].length() > 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of warpers belonging to the particular universe.\\n     */\\n    function universeWarperCount(Registry storage self, uint256 universeId) internal view returns (uint256) {\\n        return self.universeWarperIndex[universeId].length();\\n    }\\n\\n    /**\\n     * @dev Returns the number of warpers associated with the particular original asset.\\n     */\\n    function assetWarperCount(Registry storage self, address original) internal view returns (uint256) {\\n        return self.assetWarperIndex[original].length();\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of registered warpers using provided index reference.\\n     */\\n    function paginateIndexedWarpers(\\n        Registry storage self,\\n        EnumerableSetUpgradeable.AddressSet storage warperIndex,\\n        uint256 offset,\\n        uint256 limit\\n    ) internal view returns (address[] memory, Warper[] memory) {\\n        uint256 indexSize = warperIndex.length();\\n        if (offset >= indexSize) return (new address[](0), new Warper[](0));\\n\\n        if (limit > indexSize - offset) {\\n            limit = indexSize - offset;\\n        }\\n\\n        Warper[] memory warpers = new Warper[](limit);\\n        address[] memory warperAddresses = new address[](limit);\\n        for (uint256 i = 0; i < limit; i++) {\\n            warperAddresses[i] = warperIndex.at(offset + i);\\n            warpers[i] = self.warpers[warperAddresses[i]];\\n        }\\n\\n        return (warperAddresses, warpers);\\n    }\\n}\\n\",\"keccak256\":\"0xf557071a3643bf86e836e0d48a535e1fe46081dbe34ba1333a87acd8dce4281e\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506103ef806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806301ffc9a714610046578063492f4e181461006e5780634ad0762614610083575b600080fd5b6100596100543660046101b0565b6100a4565b60405190151581526020015b60405180910390f35b60405163ce97773960e01b8152602001610065565b6100966100913660046101d2565b6100db565b604051908152602001610065565b60006001600160e01b031982166301ff9c1f60e11b14806100d557506301ffc9a760e01b6001600160e01b03198316145b92915050565b6000806100ef6100ea856102a1565b61011a565b905080610102608085016060860161034d565b63ffffffff166101129190610373565b949350505050565b60006101298260000151610141565b81602001518060200190518101906100d591906103a0565b63ce97773960e01b6001600160e01b0319821614610190576040805163dc5b665760e01b81526001600160e01b03198316600482015263ce97773960e01b602482015290519081900360440190fd5b50565b80356001600160e01b0319811681146101ab57600080fd5b919050565b6000602082840312156101c257600080fd5b6101cb82610193565b9392505050565b60008082840360c08112156101e657600080fd5b833567ffffffffffffffff8111156101fd57600080fd5b84016040818703121561020f57600080fd5b925060a0601f198201121561022357600080fd5b506020830190509250929050565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff8111828210171561026a5761026a610231565b60405290565b604051601f8201601f1916810167ffffffffffffffff8111828210171561029957610299610231565b604052919050565b6000604082360312156102b357600080fd5b6102bb610247565b6102c483610193565b815260208084013567ffffffffffffffff808211156102e257600080fd5b9085019036601f8301126102f557600080fd5b81358181111561030757610307610231565b610319601f8201601f19168501610270565b9150808252368482850101111561032f57600080fd5b80848401858401376000908201840152918301919091525092915050565b60006020828403121561035f57600080fd5b813563ffffffff811681146101cb57600080fd5b600081600019048311821515161561039b57634e487b7160e01b600052601160045260246000fd5b500290565b6000602082840312156103b257600080fd5b505191905056fea26469706673582212208d36d30a9a583784df49e001650cec240abe7546e60cff9c1772886e30b670b364736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c806301ffc9a714610046578063492f4e181461006e5780634ad0762614610083575b600080fd5b6100596100543660046101b0565b6100a4565b60405190151581526020015b60405180910390f35b60405163ce97773960e01b8152602001610065565b6100966100913660046101d2565b6100db565b604051908152602001610065565b60006001600160e01b031982166301ff9c1f60e11b14806100d557506301ffc9a760e01b6001600160e01b03198316145b92915050565b6000806100ef6100ea856102a1565b61011a565b905080610102608085016060860161034d565b63ffffffff166101129190610373565b949350505050565b60006101298260000151610141565b81602001518060200190518101906100d591906103a0565b63ce97773960e01b6001600160e01b0319821614610190576040805163dc5b665760e01b81526001600160e01b03198316600482015263ce97773960e01b602482015290519081900360440190fd5b50565b80356001600160e01b0319811681146101ab57600080fd5b919050565b6000602082840312156101c257600080fd5b6101cb82610193565b9392505050565b60008082840360c08112156101e657600080fd5b833567ffffffffffffffff8111156101fd57600080fd5b84016040818703121561020f57600080fd5b925060a0601f198201121561022357600080fd5b506020830190509250929050565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff8111828210171561026a5761026a610231565b60405290565b604051601f8201601f1916810167ffffffffffffffff8111828210171561029957610299610231565b604052919050565b6000604082360312156102b357600080fd5b6102bb610247565b6102c483610193565b815260208084013567ffffffffffffffff808211156102e257600080fd5b9085019036601f8301126102f557600080fd5b81358181111561030757610307610231565b610319601f8201601f19168501610270565b9150808252368482850101111561032f57600080fd5b80848401858401376000908201840152918301919091525092915050565b60006020828403121561035f57600080fd5b813563ffffffff811681146101cb57600080fd5b600081600019048311821515161561039b57634e487b7160e01b600052601160045260246000fd5b500290565b6000602082840312156103b257600080fd5b505191905056fea26469706673582212208d36d30a9a583784df49e001650cec240abe7546e60cff9c1772886e30b670b364736f6c634300080d0033",
  "devdoc": {
    "errors": {
      "ListingStrategyMismatch(bytes4,bytes4)": [
        {
          "details": "Thrown when the listing strategy ID does not match the required one.",
          "params": {
            "provided": "Provided listing strategy ID.",
            "required": "Required listing strategy ID."
          }
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "calculateRentalFee((bytes4,bytes),(uint256,address,address,uint32,address))": {
        "details": "Calculates rental fee based on renting params and implemented listing strategy.",
        "params": {
          "listingParams": "Listing strategy params.",
          "rentingParams": "Renting params."
        },
        "returns": {
          "_0": "Rental fee."
        }
      },
      "strategyId()": {
        "details": "Returns implemented strategy ID.",
        "returns": {
          "_0": "Listing strategy ID."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}